// This file is auto-generated by @hey-api/openapi-ts

export const ExtractVariablesRequestSchema = {
  type: 'object',
  required: ['prompt', 'canvasId', 'mode'],
  properties: {
    prompt: {
      type: 'string',
      description: 'Natural language prompt describing the desired functionality',
      minLength: 1,
      maxLength: 500,
      example: 'Create a user registration form with username, email, and password fields',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to retrieve existing variable context and content',
      pattern: '^[a-zA-Z0-9_-]+$',
      example: 'canvas-123',
    },
    mode: {
      type: 'string',
      enum: ['direct', 'candidate'],
      description: `Processing mode for variable extraction:
- direct: Directly update Canvas variables and return results
- candidate: Return candidate solutions for user selection
`,
      example: 'candidate',
    },
    sessionId: {
      type: 'string',
      description: `Optional session ID for direct mode to check for existing candidate records.
When provided in direct mode, the system will check if there are
unapplied candidate records for this session.
`,
      example: 'session-789',
    },
  },
} as const;

export const VariableExtractionResultSchema = {
  type: 'object',
  required: ['originalPrompt', 'processedPrompt', 'variables', 'reusedVariables'],
  properties: {
    originalPrompt: {
      type: 'string',
      description: 'Original natural language prompt from user input',
      example: 'Create a user registration form with username, email, and password fields',
    },
    processedPrompt: {
      type: 'string',
      description: `Processed prompt with variable references embedded.
Variables are represented using handlebars syntax (e.g., {{variableName}}).
`,
      example:
        'Create a user registration form with {{username}}, {{email}}, and {{password}} fields',
    },
    variables: {
      type: 'array',
      description: 'List of extracted workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    reusedVariables: {
      type: 'array',
      description: 'List of variables that were reused from existing context',
      items: {
        $ref: '#/components/schemas/VariableReuse',
      },
    },
    sessionId: {
      type: 'string',
      description: `Session ID for candidate mode responses.
This ID can be used in subsequent direct mode requests
to apply the selected candidate solution.
`,
      example: 'session-abc123',
    },
    extractionConfidence: {
      type: 'number',
      description: 'Confidence score for the extraction (0.0 to 1.0)',
      example: 0.78,
    },
  },
} as const;

export const VariableReuseSchema = {
  type: 'object',
  description: 'Information about variables reused from existing context',
  required: ['detectedText', 'reusedVariableName', 'confidence', 'reason'],
  properties: {
    detectedText: {
      type: 'string',
      description: 'Text in the prompt that triggered variable reuse detection',
      example: 'form',
    },
    reusedVariableName: {
      type: 'string',
      description: 'Name of the existing variable that was reused',
      example: 'formType',
    },
    confidence: {
      type: 'number',
      format: 'float',
      minimum: 0,
      maximum: 1,
      description: 'Confidence score for the reuse detection (0.0 to 1.0)',
      example: 0.78,
    },
    reason: {
      type: 'string',
      description: 'Explanation of why this variable was reused',
      example: 'Similar form structure detected in existing variables',
    },
  },
} as const;

export const McpServerTypeSchema = {
  type: 'string',
  description: 'MCP Server type',
  enum: ['sse', 'streamable', 'stdio'],
} as const;

export const McpServerDTOSchema = {
  type: 'object',
  required: ['name', 'type', 'enabled', 'isGlobal'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
      example: 'My MCP Server',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (for sse and streamable types)',
      example: 'https://example.com/mcp',
    },
    command: {
      type: 'string',
      description: 'Command to execute (for stdio type)',
      example: 'python',
    },
    args: {
      type: 'array',
      description: 'Command arguments (for stdio type)',
      items: {
        type: 'string',
      },
      example: ['-m', 'server.py'],
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        API_KEY: 'your_api_key',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        Authorization: 'Bearer token',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the MCP server is global',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server update time',
    },
  },
} as const;

export const ListMcpServersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerDTO',
          },
        },
      },
    },
  ],
} as const;

export const UpsertMcpServerRequestSchema = {
  type: 'object',
  required: ['name', 'type'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (required for sse and streamable types)',
    },
    command: {
      type: 'string',
      description: 'Command to execute (required for stdio type)',
    },
    args: {
      type: 'array',
      description: 'Command arguments (required for stdio type)',
      items: {
        type: 'string',
      },
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
  },
} as const;

export const UpsertMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/McpServerDTO',
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerRequestSchema = {
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP name to delete',
    },
  },
} as const;

export const McpServerToolSchema = {
  type: 'object',
  required: ['name', 'description'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name',
      example: 'tool_name',
    },
    description: {
      type: 'string',
      description: 'Tool description',
      example: 'This tool does something useful',
    },
  },
} as const;

export const ValidateMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerTool',
          },
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'null',
        },
      },
    },
  ],
} as const;

export const PageSchema = {
  type: 'object',
  required: ['pageId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    pageId: {
      type: 'string',
      description: 'Page ID',
      example: 'pg-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Page title',
      example: 'My Page',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    status: {
      type: 'string',
      description: 'Page status',
      enum: ['draft', 'published'],
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID associated with this page',
      example: 'cv-g30e1b80b5g1itbemc0g5jj3',
    },
    coverUrl: {
      type: 'string',
      description: 'Page cover URL',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page last update time',
    },
  },
} as const;

export const PageNodeRelationSchema = {
  type: 'object',
  required: ['relationId', 'nodeId', 'nodeType', 'entityId', 'orderIndex'],
  properties: {
    relationId: {
      type: 'string',
      description: 'Relation ID',
    },
    pageId: {
      type: 'string',
      description: 'Page ID',
    },
    nodeId: {
      type: 'string',
      description: 'Node ID',
    },
    nodeType: {
      type: 'string',
      description: 'Node type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    orderIndex: {
      type: 'integer',
      description: 'Order index',
    },
    nodeData: {
      description: 'Node data',
      $ref: '#/components/schemas/CanvasNodeData',
    },
  },
} as const;

export const PageDetailSchema = {
  type: 'object',
  allOf: [
    {
      $ref: '#/components/schemas/Page',
    },
    {
      type: 'object',
      properties: {
        nodeRelations: {
          type: 'array',
          description: 'List of node relations',
          items: {
            $ref: '#/components/schemas/PageNodeRelation',
          },
        },
        pageConfig: {
          type: 'object',
          description: 'Page configuration',
        },
      },
    },
  ],
} as const;

export const UpdatePageRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Page title',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    nodeRelations: {
      type: 'array',
      description: 'List of node relations with updated order',
      items: {
        type: 'object',
        properties: {
          nodeId: {
            type: 'string',
            description: 'Node ID',
          },
          orderIndex: {
            type: 'integer',
            description: 'New order index',
          },
        },
      },
    },
  },
} as const;

export const UpdatePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          allOf: [
            {
              $ref: '#/components/schemas/Page',
            },
            {
              type: 'object',
              properties: {
                nodeRelations: {
                  type: 'array',
                  description: 'List of node relations',
                  items: {
                    $ref: '#/components/schemas/PageNodeRelation',
                  },
                },
              },
            },
          ],
        },
      },
    },
  ],
} as const;

export const DeletePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'ID of the deleted page',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the deleted page',
            },
          },
        },
      },
    },
  ],
} as const;

export const SharePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            shareId: {
              type: 'string',
              description: 'Share ID',
            },
            shareUrl: {
              type: 'string',
              description: 'Share URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const DeletePageNodeResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            nodeId: {
              type: 'string',
              description: 'ID of the deleted node',
            },
          },
        },
      },
    },
  ],
} as const;

export const ListPagesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            total: {
              type: 'integer',
              description: 'Total number of pages',
            },
            pages: {
              type: 'array',
              description: 'List of pages',
              items: {
                $ref: '#/components/schemas/Page',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const PageDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/PageDetail',
        },
      },
    },
  ],
} as const;

export const AddPageNodesRequestSchema = {
  type: 'object',
  required: ['nodeIds'],
  properties: {
    nodeIds: {
      type: 'array',
      description: 'List of node IDs to add to the page',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const AddPageNodesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const CanvasPageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const UserSchema = {
  type: 'object',
  description: 'Refly user, used as JWT payload',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    email: {
      type: 'string',
      description: 'Email',
    },
  },
} as const;

export const AuthTypeSchema = {
  type: 'string',
  description: 'Auth type',
  enum: ['email', 'oauth'],
} as const;

export const AccountSchema = {
  type: 'object',
  description: 'Auth account',
  required: ['type', 'provider', 'providerAccountId'],
  properties: {
    type: {
      $ref: '#/components/schemas/AuthType',
      description: 'Auth type',
    },
    provider: {
      type: 'string',
      description: 'Provider',
    },
    scope: {
      type: 'array',
      description: 'Auth scope',
      items: {
        type: 'string',
      },
    },
    providerAccountId: {
      type: 'string',
      description: 'Provider account ID',
    },
  },
} as const;

export const ListAccountsResponseSchema = {
  type: 'object',
  description: 'List auth accounts response',
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of auth accounts',
          items: {
            $ref: '#/components/schemas/Account',
          },
        },
      },
    },
  ],
} as const;

export const CheckToolOAuthStatusResponseSchema = {
  type: 'object',
  description: 'Check tool OAuth status response',
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'OAuth status information',
          properties: {
            authorized: {
              type: 'boolean',
              description: 'Whether user has sufficient OAuth authorization',
            },
            provider: {
              type: 'string',
              description: 'OAuth provider',
            },
            scope: {
              type: 'array',
              description: 'Required OAuth scopes',
              items: {
                type: 'string',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const ShareUserSchema = {
  type: 'object',
  description: 'Refly user in shared entity',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    name: {
      type: 'string',
      description: 'User name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'User creation time',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
  },
} as const;

export const ListOrderSchema = {
  type: 'string',
  description: 'List order',
  enum: ['creationAsc', 'creationDesc', 'updationAsc', 'updationDesc'],
} as const;

export const CanvasStatusSchema = {
  type: 'string',
  description: 'Canvas status',
  enum: ['ready', 'duplicating', 'duplicate_failed'],
} as const;

export const CanvasSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My canvas',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this canvas is read-only',
    },
    status: {
      type: 'string',
      description: 'Canvas status',
      $ref: '#/components/schemas/CanvasStatus',
    },
    owner: {
      description: 'Canvas owner',
      $ref: '#/components/schemas/ShareUser',
    },
    shareRecord: {
      description: 'Canvas share record',
      $ref: '#/components/schemas/ShareRecord',
    },
    usedToolsets: {
      type: 'array',
      description: 'Used toolsets in the canvas',
      items: {
        type: 'object',
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    minimapUrl: {
      type: 'string',
      description: 'Minimap URL',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas update time',
    },
  },
} as const;

export const CanvasTemplateCategorySchema = {
  type: 'object',
  required: ['categoryId', 'name', 'labelDict', 'descriptionDict'],
  properties: {
    categoryId: {
      type: 'string',
      description: 'Category ID',
    },
    name: {
      type: 'string',
      description: 'Category name',
    },
    labelDict: {
      type: 'object',
      description: 'Category label dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Category description dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
  },
} as const;

export const CanvasTemplateSchema = {
  type: 'object',
  required: ['templateId', 'shareId', 'title', 'description', 'language', 'createdAt', 'updatedAt'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
      example: 'ct-g30e1b80b5g1itbemc0g5jj3',
    },
    shareId: {
      type: 'string',
      description: 'Share ID',
      example: 'can-g30e1b80b5g1itbemc0g5jj3',
    },
    shareUser: {
      description: 'Share user',
      $ref: '#/components/schemas/ShareUser',
    },
    version: {
      type: 'integer',
      description: 'Canvas template version',
    },
    category: {
      description: 'Canvas template category',
      $ref: '#/components/schemas/CanvasTemplateCategory',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    featured: {
      type: 'boolean',
      description: 'Whether this canvas template is featured',
    },
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
    coverUrl: {
      type: 'string',
      description: 'Canvas template cover image URL',
    },
    appShareId: {
      type: 'string',
      description: 'Associated workflow app share ID',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template update time',
    },
  },
} as const;

export const ResourceMetaSchema = {
  type: 'object',
  description: 'Resource metadata',
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
      example: 'https://www.google.com',
    },
    title: {
      type: 'string',
      description: 'Weblink title',
      example: 'Google',
    },
    contentType: {
      type: 'string',
      description: 'File content type (MIME type)',
      example: 'application/pdf',
    },
  },
} as const;

export const ResourceTypeSchema = {
  type: 'string',
  description: 'Resource type',
  enum: ['weblink', 'text', 'file', 'document', 'image', 'video', 'audio'],
} as const;

export const IndexErrorSchema = {
  type: 'object',
  description: 'Error message for resource indexing',
  properties: {
    type: {
      type: 'string',
      description: 'Error type',
      enum: ['pageLimitExceeded', 'unknownError'],
    },
    metadata: {
      type: 'object',
      description: 'Error metadata',
    },
  },
} as const;

export const ResourceSchema = {
  type: 'object',
  required: ['resourceId', 'resourceType', 'title'],
  properties: {
    resourceId: {
      type: 'string',
      description: "Resource ID (empty if it's external)",
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    title: {
      type: 'string',
      description: 'Resource title',
    },
    data: {
      type: 'object',
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    indexStatus: {
      description: 'Resource index status',
      $ref: '#/components/schemas/IndexStatus',
    },
    indexError: {
      description: 'Error message for resource indexing',
      $ref: '#/components/schemas/IndexError',
    },
    storageKey: {
      type: 'string',
      description: 'Resource storage key',
    },
    storageSize: {
      type: 'string',
      description: 'Resource storage size (in bytes)',
    },
    vectorSize: {
      type: 'string',
      description: 'Resource vector storage size (in bytes)',
    },
    rawFileKey: {
      type: 'string',
      description: 'Raw file storage key (used to download the file)',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource update time',
    },
    contentPreview: {
      type: 'string',
      description: 'Preview content for this resource',
    },
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    content: {
      type: 'string',
      description: 'Document content for this resource (only returned in getResourceDetail API)',
    },
    downloadURL: {
      type: 'string',
      description: 'Download URL for this resource (for file type only)',
    },
    publicURL: {
      type: 'string',
      description: 'Publicly accessible URL for this resource (file type only)',
    },
  },
} as const;

export const DocumentSchema = {
  type: 'object',
  required: ['docId', 'title'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Document title',
      example: 'My document',
    },
    contentPreview: {
      type: 'string',
      description: 'Document content preview',
    },
    content: {
      type: 'string',
      description: 'Full document content (only returned in detail api)',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document update time',
    },
  },
} as const;

export const EntityTypeSchema = {
  type: 'string',
  description: 'Entity type',
  enum: [
    'document',
    'resource',
    'canvas',
    'share',
    'user',
    'project',
    'skillResponse',
    'codeArtifact',
    'page',
    'mediaResult',
    'workflowApp',
  ],
} as const;

export const EntitySchema = {
  type: 'object',
  description: 'Entity',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
  },
} as const;

export const ProjectSourceSchema = {
  type: 'object',
  description: 'Project source',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    title: {
      type: 'string',
      description: 'Project title',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const ProjectSchema = {
  type: 'object',
  description: 'Project',
  required: ['projectId', 'name'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverUrl: {
      type: 'string',
      description: 'Project cover URL',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions for the project',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const LabelClassSchema = {
  type: 'object',
  description: 'Label class',
  required: ['labelClassId', 'name', 'displayName', 'createdAt', 'updatedAt'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'Related Dataset',
    },
    displayName: {
      type: 'string',
      description: 'Label class display name',
      example: 'Label display name',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class update time',
    },
  },
} as const;

export const LabelInstanceSchema = {
  type: 'object',
  description: 'Label instances related to entities',
  required: ['labelId', 'labelClassId', 'value'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label instance ID',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClass: {
      description: 'Label class',
      $ref: '#/components/schemas/LabelClass',
    },
    value: {
      type: 'string',
      description: 'Label value',
      example: 'HotPotQA',
    },
  },
} as const;

export const InputModeSchema = {
  type: 'string',
  description: 'Data input mode',
  enum: ['text', 'textarea', 'number', 'select', 'multiSelect', 'radio', 'switch'],
} as const;

export const ConfigScopeSchema = {
  type: 'array',
  description: 'Config scope',
  items: {
    type: 'string',
    enum: ['runtime', 'template'],
  },
} as const;

export const SelectOptionSchema = {
  type: 'object',
  description: 'Select option',
  required: ['value'],
  properties: {
    value: {
      type: 'string',
      description: 'Option value',
    },
    labelDict: {
      type: 'object',
      description: 'Option label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    disabled: {
      type: 'boolean',
      description: 'Whether this option is disabled',
      default: false,
    },
  },
} as const;

export const DynamicConfigItemSchema = {
  type: 'object',
  description: 'Dynamic config item',
  required: ['key', 'inputMode', 'labelDict', 'descriptionDict'],
  properties: {
    key: {
      type: 'string',
      description: 'Config key',
    },
    inputMode: {
      description: 'Config input mode',
      $ref: '#/components/schemas/InputMode',
    },
    required: {
      type: 'boolean',
      description: 'Specifies whether this config is required',
      default: false,
    },
    labelDict: {
      type: 'object',
      description: 'Config label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Config description (key is locale, value is description)',
      additionalProperties: {
        type: 'string',
      },
    },
    defaultValue: {
      description: 'Default value',
      oneOf: [
        {
          type: 'number',
        },
        {
          type: 'string',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
      ],
    },
    options: {
      type: 'array',
      description: 'Config options',
      items: {
        $ref: '#/components/schemas/SelectOption',
      },
    },
    inputProps: {
      type: 'object',
      description: 'Additional input properties',
      properties: {
        min: {
          type: 'number',
          description: 'Minimum value for number input',
        },
        max: {
          type: 'number',
          description: 'Maximum value for number input',
        },
        step: {
          type: 'number',
          description: 'Step value for number input',
        },
        precision: {
          type: 'number',
          description: 'Decimal precision for number input',
        },
        passwordType: {
          type: 'boolean',
          description: 'Whether to display as password input',
        },
      },
    },
  },
} as const;

export const DynamicConfigValueSchema = {
  type: 'object',
  description: 'Dynamic config value',
  required: ['label', 'value', 'displayValue'],
  properties: {
    label: {
      type: 'string',
      description: 'Config key label',
    },
    value: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'number',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
        {
          type: 'object',
          additionalProperties: true,
        },
      ],
      description: 'Config value',
    },
    displayValue: {
      type: 'string',
      description: 'Config display value',
    },
    configScope: {
      description: 'The contexts in which the requirement applies',
      $ref: '#/components/schemas/ConfigScope',
    },
  },
} as const;

export const SkillTemplateConfigDefinitionSchema = {
  type: 'object',
  description: 'Skill template config schema',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Config items',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
  },
} as const;

export const IconTypeSchema = {
  type: 'string',
  description: 'Icon type',
  enum: ['emoji', 'image'],
} as const;

export const IconSchema = {
  type: 'object',
  description: 'Icon',
  required: ['type', 'value'],
  properties: {
    type: {
      description: 'Icon type',
      $ref: '#/components/schemas/IconType',
    },
    value: {
      type: 'string',
      description: 'Icon value',
    },
  },
} as const;

export const SkillSchema = {
  type: 'object',
  description: 'Skill',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
    configSchema: {
      description: 'Skill config schema',
      $ref: '#/components/schemas/SkillTemplateConfigDefinition',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const SkillTriggerTypeSchema = {
  type: 'string',
  description: 'Skill trigger type',
  enum: ['timer', 'simpleEvent'],
} as const;

export const SimpleEventNameSchema = {
  type: 'string',
  description: 'Simple event name',
  enum: ['onResourceReady'],
} as const;

export const SimpleEventSchema = {
  type: 'object',
  required: ['name', 'displayName'],
  properties: {
    name: {
      description: 'Simple event name',
      $ref: '#/components/schemas/SimpleEventName',
    },
    displayName: {
      type: 'object',
      description: 'Simple event display name (key is locale, value is display name)',
    },
  },
} as const;

export const TimerIntervalSchema = {
  type: 'string',
  description: 'Timer interval',
  enum: ['hour', 'day', 'week', 'month', 'year'],
} as const;

export const TimerTriggerConfigSchema = {
  type: 'object',
  required: ['datetime'],
  properties: {
    datetime: {
      type: 'string',
      format: 'date-time',
      description: 'Time to run',
    },
    repeatInterval: {
      type: 'string',
      description: 'Repeat interval',
      $ref: '#/components/schemas/TimerInterval',
    },
  },
} as const;

export const SkillTriggerSchema = {
  type: 'object',
  description: 'Skill triggers',
  required: [
    'skillId',
    'displayName',
    'triggerId',
    'triggerType',
    'enabled',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
      example: 'tr-g30e1b80b5g1itbemc0g5jj3',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Trigger enabled',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger update time',
    },
  },
} as const;

export const SkillMetaSchema = {
  type: 'object',
  description: 'Skill metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ActionMetaSchema = {
  type: 'object',
  description: 'Action metadata',
  required: ['name'],
  properties: {
    type: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    name: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const SkillRuntimeConfigSchema = {
  type: 'object',
  description: 'Skill runtime config',
  properties: {
    disableLinkParsing: {
      type: 'boolean',
      description: 'Whether to disable link parsing for input query',
    },
    enabledKnowledgeBase: {
      type: 'boolean',
      description: 'Whether to enable knowledge base for input query',
    },
  },
} as const;

export const SkillTemplateConfigSchema = {
  type: 'object',
  description: 'Skill template config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const ActionConfigSchema = {
  type: 'object',
  description: 'Action config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const SkillInstanceSchema = {
  type: 'object',
  description: 'Skill',
  allOf: [
    {
      $ref: '#/components/schemas/SkillMeta',
    },
    {
      type: 'object',
      required: ['createdAt', 'updatedAt', 'invocationConfig'],
      properties: {
        description: {
          type: 'string',
          description: 'Skill instance description',
        },
        promptHint: {
          type: 'string',
          description: 'Skill instance prompt hint',
        },
        tplConfig: {
          description: 'Skill template config',
          $ref: '#/components/schemas/SkillTemplateConfig',
        },
        tplConfigSchema: {
          description: 'Skill template config schema',
          $ref: '#/components/schemas/SkillTemplateConfigDefinition',
        },
        pinnedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill pinned time',
        },
        createdAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill creation time',
        },
        updatedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill update time',
        },
      },
    },
  ],
} as const;

export const SourceMetaSchema = {
  type: 'object',
  description: 'Source metadata',
  properties: {
    source: {
      type: 'string',
      description: 'Source URL',
      deprecated: true,
    },
    title: {
      type: 'string',
      description: 'Source title',
      deprecated: true,
    },
    publishedTime: {
      type: 'string',
      format: 'date-time',
      description: 'Source publish timesss',
    },
    entityId: {
      type: 'string',
      description: 'Related entity ID',
    },
    entityType: {
      type: 'string',
      description: 'Related entity type',
    },
    originalLocale: {
      type: 'string',
      description: 'Original locale',
    },
    translatedDisplayLocale: {
      type: 'string',
      description: 'Translated display locale',
    },
    isTranslated: {
      type: 'boolean',
      description: 'Whether the source is translated',
    },
    originalQuery: {
      type: 'string',
      description: 'Original query',
    },
    translatedQuery: {
      type: 'string',
      description: 'Translated query',
    },
    sourceType: {
      type: 'string',
      description: 'Source type',
      enum: ['webSearch', 'library'],
    },
  },
} as const;

export const SourceSelectionSchema = {
  type: 'object',
  description: 'Source selection',
  required: ['content', 'type'],
  properties: {
    xPath: {
      type: 'string',
      description: 'Selected xPath',
      deprecated: true,
    },
    content: {
      type: 'string',
      description: 'Selected content',
    },
    type: {
      type: 'string',
      description: 'Selection type',
      enum: ['text', 'table', 'link', 'image', 'video', 'audio'],
    },
  },
} as const;

export const SourceSchema = {
  type: 'object',
  description: 'Source of the message',
  required: ['pageContent'],
  properties: {
    url: {
      type: 'string',
      description: 'Source URL',
    },
    title: {
      type: 'string',
      description: 'Source title',
    },
    pageContent: {
      type: 'string',
      description: 'Source content',
    },
    score: {
      type: 'number',
      description: 'Relativity score',
    },
    metadata: {
      type: 'object',
      description: 'Source metadata',
      $ref: '#/components/schemas/SourceMeta',
    },
    selections: {
      type: 'array',
      description: 'Source selections',
      items: {
        $ref: '#/components/schemas/SourceSelection',
      },
    },
  },
} as const;

export const SearchStepSchema = {
  type: 'object',
  description: 'Search step',
  properties: {
    step: {
      type: 'string',
      description: 'Search step name',
    },
    duration: {
      type: 'number',
      description: 'Step duration in milliseconds',
    },
    result: {
      type: 'object',
      description: 'Step-specific result data',
    },
  },
} as const;

export const ModelTierSchema = {
  type: 'string',
  description: 'Model tier',
  enum: ['t1', 't2', 'free'],
} as const;

export const TokenUsageItemSchema = {
  type: 'object',
  description: 'Token usage item',
  required: ['modelName', 'modelProvider', 'inputTokens', 'outputTokens'],
  properties: {
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    modelProvider: {
      type: 'string',
      description: 'Model provider',
    },
    modelLabel: {
      type: 'string',
      description: 'Model label',
    },
    inputTokens: {
      type: 'number',
      description: 'Input tokens',
    },
    outputTokens: {
      type: 'number',
      description: 'Output tokens',
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
      deprecated: true,
    },
  },
} as const;

export const ActionStatusSchema = {
  type: 'string',
  description: 'Action status',
  enum: ['waiting', 'executing', 'finish', 'failed'],
} as const;

export const ArtifactTypeSchema = {
  type: 'string',
  description: 'Artifact type',
  enum: ['document', 'codeArtifact', 'image', 'video', 'audio'],
} as const;

export const ArtifactStatusSchema = {
  type: 'string',
  description: 'Artifact status',
  enum: ['waiting', 'generating', 'finish', 'failed'],
} as const;

export const ArtifactSchema = {
  type: 'object',
  description: 'Artifact',
  required: ['type', 'entityId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/ArtifactType',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    status: {
      description: 'Artifact status',
      $ref: '#/components/schemas/ArtifactStatus',
    },
    content: {
      type: 'string',
      description: 'Artifact content',
    },
    metadata: {
      type: 'object',
      description: 'Artifact metadata',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact update time',
    },
  },
} as const;

export const ActionStepMetaSchema = {
  type: 'object',
  description: 'Action step metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
  },
} as const;

export const ActionLogSchema = {
  type: 'object',
  description: 'Action log',
  required: ['key'],
  properties: {
    key: {
      type: 'string',
      description: 'Log key',
    },
    titleArgs: {
      type: 'object',
      description: 'Log title arguments',
    },
    descriptionArgs: {
      type: 'object',
      description: 'Log description arguments',
    },
  },
} as const;

export const ActionStepSchema = {
  type: 'object',
  description: 'Action step',
  required: ['name', 'status'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
    content: {
      type: 'string',
      description: 'Step content',
    },
    reasoningContent: {
      type: 'string',
      description: 'Step reasoning content',
    },
    artifacts: {
      type: 'array',
      description: 'Step artifacts',
      items: {
        $ref: '#/components/schemas/Artifact',
      },
    },
    structuredData: {
      type: 'object',
      description: 'Step structured data output',
      example: {
        sources: ['Source'],
        relatedQuestions: ['string'],
      },
    },
    logs: {
      type: 'array',
      description: 'Action step logs',
      items: {
        $ref: '#/components/schemas/ActionLog',
      },
    },
    tokenUsage: {
      type: 'array',
      description: 'Token usage',
      items: {
        $ref: '#/components/schemas/TokenUsageItem',
      },
    },
    toolCalls: {
      type: 'array',
      description: 'Tool calls in this step',
      items: {
        $ref: '#/components/schemas/ToolCallResult',
      },
    },
  },
} as const;

export const CodeArtifactTypeSchema = {
  type: 'string',
  description: 'Code artifact type',
  enum: [
    'application/refly.artifacts.react',
    'image/svg+xml',
    'application/refly.artifacts.mermaid',
    'text/markdown',
    'application/refly.artifacts.code',
    'text/html',
    'application/refly.artifacts.mindmap',
  ],
} as const;

export const CodeArtifactSchema = {
  type: 'object',
  description: 'Code artifact',
  required: ['type', 'artifactId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/CodeArtifactType',
    },
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Action result version',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
    },
  },
} as const;

export const ActionResultSchema = {
  type: 'object',
  description: 'Action result',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      readOnly: true,
      description: 'Action result ID',
      example: 'ar-g30e1b80b5g1itbemc0g5jj3',
    },
    version: {
      type: 'number',
      description: 'Action result version',
    },
    title: {
      type: 'string',
      description: 'Action result title',
    },
    input: {
      description: 'Action input',
      $ref: '#/components/schemas/SkillInput',
    },
    tier: {
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    status: {
      type: 'string',
      description: 'Step status',
      $ref: '#/components/schemas/ActionStatus',
    },
    type: {
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    modelInfo: {
      description: 'Selected model',
      $ref: '#/components/schemas/ModelInfo',
    },
    targetType: {
      description: 'Action target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Action target ID',
    },
    actionMeta: {
      type: 'object',
      description: 'Action metadata',
      $ref: '#/components/schemas/ActionMeta',
    },
    context: {
      type: 'object',
      description: 'Action context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      type: 'object',
      description: 'Action template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
      deprecated: true,
    },
    runtimeConfig: {
      type: 'object',
      description: 'Action runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
      deprecated: true,
    },
    history: {
      type: 'array',
      description: 'Action result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
    steps: {
      type: 'array',
      description: 'Action steps',
      items: {
        $ref: '#/components/schemas/ActionStep',
      },
    },
    errors: {
      type: 'array',
      description: 'Errors',
      items: {
        type: 'string',
      },
    },
    toolsets: {
      type: 'array',
      description: 'Action toolsets',
      items: {
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    toolCalls: {
      type: 'array',
      description: 'Tool calls during action execution',
      items: {
        $ref: '#/components/schemas/ToolCallResult',
      },
    },
    outputUrl: {
      type: 'string',
      format: 'uri',
      description: 'Media generation output URL (for media type actions)',
      example: 'https://example.com/generated/image_123.png',
    },
    storageKey: {
      type: 'string',
      description: 'Media generation output storage key',
    },
    pilotStepId: {
      type: 'string',
      description: 'Pilot step ID',
    },
    pilotSessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    workflowExecutionId: {
      type: 'string',
      description: 'Workflow execution ID for workflow context',
    },
    workflowNodeExecutionId: {
      type: 'string',
      description: 'Workflow node execution ID for workflow context',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message update time',
    },
  },
} as const;

export const IndexStatusSchema = {
  type: 'string',
  description: 'Resource index status',
  enum: ['init', 'wait_parse', 'wait_index', 'finish', 'parse_failed', 'index_failed'],
} as const;

export const SubscriptionIntervalSchema = {
  type: 'string',
  description: 'Payment recurring interval',
  enum: ['monthly', 'yearly'],
} as const;

export const SubscriptionPlanTypeSchema = {
  type: 'string',
  description: 'Subscription plan type',
  enum: ['free', 'starter', 'maker', 'enterprise'],
} as const;

export const SubscriptionStatusSchema = {
  type: 'string',
  description: 'Subscription status',
  enum: [
    'active',
    'canceled',
    'incomplete',
    'incomplete_expired',
    'past_due',
    'paused',
    'trialing',
    'unpaid',
  ],
} as const;

export const SubscriptionSchema = {
  type: 'object',
  required: ['subscriptionId', 'planType', 'status'],
  properties: {
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    lookupKey: {
      type: 'string',
      description: 'Subscription lookup key',
    },
    planType: {
      type: 'string',
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Payment recurring interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
    status: {
      type: 'string',
      description: 'Subscription status',
      $ref: '#/components/schemas/SubscriptionStatus',
    },
    isTrial: {
      type: 'boolean',
      description: 'Whether the subscription is a trial',
    },
    cancelAt: {
      type: 'string',
      format: 'date-time',
      description: 'Subscription cancel time',
    },
  },
} as const;

export const TokenUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'startAt',
    't1TokenQuota',
    't1TokenUsed',
    't2TokenQuota',
    't2TokenUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Token usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    startAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter start time',
    },
    endAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter end time',
    },
    t1CountQuota: {
      type: 'number',
      description: 'Request count quota (T1)',
      example: 1000000,
    },
    t1CountUsed: {
      type: 'number',
      description: 'Request count used (T1)',
      example: 100000,
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota (T1)',
      example: 1000000,
      deprecated: true,
    },
    t1TokenUsed: {
      type: 'number',
      description: 'Token used (T1)',
      example: 100000,
      deprecated: true,
    },
    t2CountQuota: {
      type: 'number',
      description: 'Request count quota (T2)',
      example: 1000000,
    },
    t2CountUsed: {
      type: 'number',
      description: 'Request count used (T2)',
      example: 100000,
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota (T2)',
      example: 1000000,
      deprecated: true,
    },
    t2TokenUsed: {
      type: 'number',
      description: 'Token used (T2)',
      example: 100000,
      deprecated: true,
    },
  },
} as const;

export const StorageUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'objectStorageQuota',
    'resourceSize',
    'canvasSize',
    'fileSize',
    'vectorStorageQuota',
    'vectorStorageUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Storage usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    fileCountUsed: {
      type: 'number',
      description: 'File count used',
      example: 100,
    },
    fileCountQuota: {
      type: 'number',
      description: 'File count quota',
      example: 1000,
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes), including resource, canvas and static files',
      example: '104857600',
      deprecated: true,
    },
    resourceSize: {
      type: 'string',
      description: 'Resource storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    canvasSize: {
      type: 'string',
      description: 'Canvas storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    fileSize: {
      type: 'string',
      description: 'Static file storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageUsed: {
      type: 'string',
      description: 'Vector storage size used (in bytes)',
      example: '1048576',
      deprecated: true,
    },
  },
} as const;

export const FileParsingMeterSchema = {
  type: 'object',
  required: ['pagesParsed', 'pagesLimit'],
  properties: {
    pagesParsed: {
      type: 'number',
      description: 'File pages parsed',
    },
    pagesLimit: {
      type: 'number',
      description: 'File pages limit',
    },
    fileUploadLimit: {
      type: 'number',
      description: 'File upload limit (in MB)',
    },
  },
} as const;

export const OperationModeSchema = {
  type: 'string',
  description: 'Operation mode',
  enum: ['mouse', 'touchpad'],
} as const;

export const ProviderConfigSchema = {
  type: 'object',
  description: 'Provider config',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
  },
} as const;

export const ModelSceneSchema = {
  type: 'string',
  description: 'Model usage scene',
  enum: ['chat', 'agent', 'queryAnalysis', 'titleGeneration', 'image', 'video', 'audio'],
} as const;

export const DefaultModelConfigSchema = {
  type: 'object',
  description: 'Default model config',
  properties: {
    chat: {
      description: 'Default chat model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    agent: {
      description: 'Default agent model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    queryAnalysis: {
      description: 'Query analysis and context processing model',
      $ref: '#/components/schemas/ProviderItem',
    },
    titleGeneration: {
      description: 'Title generation model for canvas and documents',
      $ref: '#/components/schemas/ProviderItem',
    },
    image: {
      description: 'Default image generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
    video: {
      description: 'Default video generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
    audio: {
      description: 'Default audio generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
  },
} as const;

export const ProviderModeSchema = {
  type: 'string',
  description: 'Provider mode',
  enum: ['global', 'custom'],
} as const;

export const UserPreferencesSchema = {
  type: 'object',
  description: 'User preferences',
  properties: {
    operationMode: {
      description: 'Operation mode',
      $ref: '#/components/schemas/OperationMode',
    },
    providerMode: {
      description: 'Provider mode',
      $ref: '#/components/schemas/ProviderMode',
    },
    disableHoverCard: {
      type: 'boolean',
      description: 'Whether to disable hover tutorial',
      default: false,
    },
    webSearch: {
      description: 'Web search config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    urlParsing: {
      description: 'URL parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    pdfParsing: {
      description: 'PDF parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    defaultModel: {
      description: 'Default model config',
      $ref: '#/components/schemas/DefaultModelConfig',
    },
  },
} as const;

export const OnboardingStatusSchema = {
  type: 'string',
  description: 'Onboarding status',
  enum: ['not_started', 'skipped', 'completed'],
} as const;

export const OnboardingConfigSchema = {
  type: 'object',
  properties: {
    settings: {
      description: 'Settings onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
    tour: {
      description: 'Tour onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
  },
} as const;

export const UserSettingsSchema = {
  type: 'object',
  required: ['uid', 'avatar', 'name', 'email'],
  properties: {
    uid: {
      type: 'string',
      description: 'User ID',
      example: 'u-g30e1b80b5g1itbemc0g5jj3',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
      example: 'https://static.refly.ai/avatar/1.jpg',
    },
    name: {
      type: 'string',
      description: 'Username (can only contains letters, numbers, and underscores)',
      example: 'john_doe',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    email: {
      type: 'string',
      description: 'User email',
      example: '6XJpZ@example.com',
    },
    emailVerified: {
      type: 'boolean',
      description: 'Whether email is verified',
      default: false,
    },
    uiLocale: {
      type: 'string',
      description: 'User UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'User output locale',
      example: 'en',
    },
    customerId: {
      type: 'string',
      description: 'Stripe customer ID',
    },
    subscription: {
      description: 'User subscription',
      $ref: '#/components/schemas/Subscription',
    },
    hasBetaAccess: {
      type: 'boolean',
      description: 'Whether the user has beta access',
      default: false,
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const AuthProviderSchema = {
  type: 'string',
  description: 'Auth provider',
  enum: ['email', 'google', 'github'],
} as const;

export const AuthConfigItemSchema = {
  type: 'object',
  required: ['provider'],
  properties: {
    provider: {
      description: 'Auth provider',
      $ref: '#/components/schemas/AuthProvider',
    },
  },
} as const;

export const AuthConfigResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Auth providers',
          items: {
            $ref: '#/components/schemas/AuthConfigItem',
          },
        },
      },
    },
  ],
} as const;

export const EmailSignupRequestSchema = {
  type: 'object',
  description: 'Email signup request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailSignupDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    skipVerification: {
      type: 'boolean',
      description: 'Whether email verification is skipped',
    },
  },
} as const;

export const EmailSignupResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailSignupData',
        },
      },
    },
  ],
} as const;

export const VerificationPurposeSchema = {
  type: 'string',
  description: 'Verification purpose',
  enum: ['signup', 'resetPassword'],
} as const;

export const CreateVerificationRequestSchema = {
  type: 'object',
  description: 'Create verification session request',
  required: ['email', 'purpose'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    purpose: {
      type: 'string',
      description: 'Verification purpose',
      $ref: '#/components/schemas/VerificationPurpose',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const CreateVerificationDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CreateVerificationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CreateVerificationData',
        },
      },
    },
  ],
} as const;

export const ResendVerificationRequestSchema = {
  type: 'object',
  description: 'Resend verification request',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CheckVerificationRequestSchema = {
  type: 'object',
  description: 'Check verification code request',
  required: ['sessionId', 'code'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    code: {
      type: 'string',
      description: 'Verification code',
    },
  },
} as const;

export const EmailLoginRequestSchema = {
  type: 'object',
  description: 'Email login request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailLoginDataSchema = {
  type: 'object',
  properties: {
    accessToken: {
      type: 'string',
      description: 'Access token',
    },
  },
} as const;

export const EmailLoginResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailLoginData',
        },
      },
    },
  ],
} as const;

export const GetUserSettingsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/UserSettings',
        },
      },
    },
  ],
} as const;

export const CollabTokenDataSchema = {
  type: 'object',
  required: ['token'],
  properties: {
    token: {
      type: 'string',
      description: 'Collab token',
    },
    expiresAt: {
      type: 'number',
      description: 'Token expiration time (in unix milliseconds)',
    },
  },
} as const;

export const GetCollabTokenResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CollabTokenData',
        },
      },
    },
  ],
} as const;

export const BaseResponseSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
      example: true,
    },
    errCode: {
      type: 'string',
      description: 'Error code',
    },
    errMsg: {
      type: 'string',
      description: 'Error message',
      example: 'Operation failed',
    },
    traceId: {
      type: 'string',
      description: 'Trace ID',
    },
    stack: {
      type: 'string',
      description: 'Error stack (only returned in development environment)',
    },
  },
} as const;

export const ListCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Canvas',
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const CanvasHistoryVersionSchema = {
  type: 'object',
  required: ['version', 'hash', 'timestamp'],
  properties: {
    version: {
      type: 'string',
      description: 'Canvas version',
    },
    hash: {
      type: 'string',
      description: 'Canvas hash',
    },
    timestamp: {
      type: 'number',
      description: 'Canvas timestamp (in unix milliseconds)',
    },
  },
} as const;

export const CanvasDataSchema = {
  type: 'object',
  description: 'Canvas data',
  required: ['nodes', 'edges'],
  properties: {
    nodes: {
      type: 'array',
      description: 'Canvas nodes',
      items: {
        $ref: '#/components/schemas/CanvasNode',
      },
    },
    edges: {
      type: 'array',
      description: 'Canvas edges',
      items: {
        $ref: '#/components/schemas/CanvasEdge',
      },
    },
  },
} as const;

export const CanvasStateSchema = {
  type: 'object',
  description: 'Canvas state',
  allOf: [
    {
      $ref: '#/components/schemas/CanvasData',
    },
    {
      type: 'object',
      properties: {
        version: {
          type: 'string',
          description: 'Canvas version',
        },
        hash: {
          type: 'string',
          description: 'Canvas state hash (sha256), calculated from nodes and edges',
        },
        transactions: {
          type: 'array',
          description: 'Canvas transaction list',
          items: {
            $ref: '#/components/schemas/CanvasTransaction',
          },
        },
        history: {
          type: 'array',
          description: 'Canvas history versions',
          items: {
            $ref: '#/components/schemas/CanvasHistoryVersion',
          },
        },
        createdAt: {
          type: 'number',
          description: 'Canvas creation timestamp (in unix milliseconds)',
        },
        updatedAt: {
          type: 'number',
          description: 'Canvas last updated timestamp (in unix milliseconds)',
        },
      },
    },
  ],
} as const;

export const RawCanvasDataSchema = {
  type: 'object',
  description: 'Raw canvas data',
  allOf: [
    {
      $ref: '#/components/schemas/CanvasData',
    },
    {
      type: 'object',
      properties: {
        canvasId: {
          type: 'string',
          description: 'Canvas ID',
        },
        title: {
          type: 'string',
          description: 'Canvas title',
        },
        owner: {
          type: 'object',
          description: 'Canvas owner',
          $ref: '#/components/schemas/ShareUser',
        },
        minimapUrl: {
          type: 'string',
          description: 'Minimap URL',
        },
        variables: {
          type: 'array',
          description: 'Workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasDataResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/RawCanvasData',
        },
      },
    },
  ],
} as const;

export const SharedCanvasDataSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/RawCanvasData',
    },
    {
      type: 'object',
      properties: {
        resources: {
          type: 'array',
          description: 'Resources in the canvas',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const ExportCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            downloadUrl: {
              type: 'string',
              description: 'Download URL for the canvas data',
            },
          },
        },
      },
    },
  ],
} as const;

export const ImportCanvasRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'File to import',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to specify',
    },
  },
} as const;

export const DuplicateCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom canvas title',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    duplicateEntities: {
      type: 'boolean',
      description: 'Whether to duplicate entities within the canvas',
    },
  },
} as const;

export const DuplicateDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom document title for the duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const DuplicateResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom resource title for the duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const UpsertCanvasRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID (only used for update)',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
    variables: {
      type: 'array',
      description: 'Workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    visibility: {
      type: 'boolean',
      description: 'Whether this canvas is visible in lists',
      default: true,
    },
  },
} as const;

export const UpsertCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const DeleteCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to delete',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    deleteAllFiles: {
      type: 'boolean',
      description: 'Whether to delete all files in the canvas',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    directUpdate: {
      type: 'boolean',
      description: 'Whether to directly update the canvas title',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Auto name canvas result',
          properties: {
            title: {
              type: 'string',
              description: 'New canvas title',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasStateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CanvasState',
        },
      },
    },
  ],
} as const;

export const SetCanvasStateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'state'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    state: {
      type: 'object',
      description: 'Canvas state to set',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const GetCanvasTransactionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas diff list',
          items: {
            $ref: '#/components/schemas/CanvasTransaction',
          },
        },
      },
    },
  ],
} as const;

export const DiffTypeSchema = {
  type: 'string',
  description: 'Diff type',
  enum: ['add', 'update', 'delete'],
} as const;

export const NodeDiffSchema = {
  type: 'object',
  required: ['id', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Node ID',
    },
    type: {
      type: 'string',
      description: 'Node diff type',
      $ref: '#/components/schemas/DiffType',
    },
    from: {
      type: 'object',
      description: 'Node diff from (only the fields that are different will be included)',
      additionalProperties: true,
    },
    to: {
      type: 'object',
      description: 'Node diff to (only the fields that are different will be included)',
      additionalProperties: true,
    },
  },
} as const;

export const EdgeDiffSchema = {
  type: 'object',
  required: ['id', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Edge ID',
    },
    type: {
      type: 'string',
      description: 'Edge diff type',
      $ref: '#/components/schemas/DiffType',
    },
    from: {
      type: 'object',
      description: 'Edge diff from',
      $ref: '#/components/schemas/CanvasEdge',
    },
    to: {
      type: 'object',
      description: 'Edge diff to',
      $ref: '#/components/schemas/CanvasEdge',
    },
  },
} as const;

export const CanvasTransactionSourceSchema = {
  type: 'object',
  description: 'Canvas transaction source',
  required: ['type'],
  properties: {
    type: {
      type: 'string',
      description: 'Source type',
      enum: ['user', 'system'],
    },
    uid: {
      type: 'string',
      description: 'Source user ID',
    },
  },
} as const;

export const CanvasTransactionSchema = {
  type: 'object',
  required: ['txId', 'nodeDiffs', 'edgeDiffs', 'createdAt'],
  properties: {
    txId: {
      type: 'string',
      description: 'Transaction ID',
    },
    nodeDiffs: {
      type: 'array',
      description: 'Node diffs',
      items: {
        $ref: '#/components/schemas/NodeDiff',
      },
    },
    edgeDiffs: {
      type: 'array',
      description: 'Edge diffs',
      items: {
        $ref: '#/components/schemas/EdgeDiff',
      },
    },
    revoked: {
      type: 'boolean',
      description: 'Whether the transaction is revoked',
    },
    source: {
      type: 'object',
      description: 'Transaction source',
      $ref: '#/components/schemas/CanvasTransactionSource',
    },
    deleted: {
      type: 'boolean',
      description: 'Whether the transaction is deleted',
    },
    createdAt: {
      type: 'number',
      description: 'Transaction creation timestamp (in unix milliseconds)',
    },
    syncedAt: {
      type: 'number',
      description: 'Transaction synchronization timestamp (in unix milliseconds)',
    },
  },
} as const;

export const SyncCanvasStateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'transactions'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    version: {
      type: 'string',
      description: 'Canvas state version',
    },
    transactions: {
      type: 'array',
      description: 'Transaction list',
      items: {
        $ref: '#/components/schemas/CanvasTransaction',
      },
    },
  },
} as const;

export const SyncCanvasStateResultSchema = {
  type: 'object',
  required: ['transactions'],
  properties: {
    transactions: {
      type: 'array',
      description: 'Transaction list',
      items: {
        $ref: '#/components/schemas/CanvasTransaction',
      },
    },
  },
} as const;

export const SyncCanvasStateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Apply canvas state result',
          $ref: '#/components/schemas/SyncCanvasStateResult',
        },
      },
    },
  ],
} as const;

export const CreateCanvasVersionRequestSchema = {
  type: 'object',
  required: ['canvasId', 'state'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    state: {
      type: 'object',
      description: 'Canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const VersionConflictSchema = {
  type: 'object',
  required: ['localState', 'remoteState'],
  properties: {
    localState: {
      type: 'object',
      description: 'Local canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
    remoteState: {
      type: 'object',
      description: 'Server canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const CreateCanvasVersionResultSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    conflict: {
      type: 'object',
      description: 'Version conflict (when there is a conflict)',
      $ref: '#/components/schemas/VersionConflict',
    },
    newState: {
      type: 'object',
      description: 'New canvas state (when there is no conflict)',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const CreateCanvasVersionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Create canvas version result',
          $ref: '#/components/schemas/CreateCanvasVersionResult',
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template list',
          items: {
            $ref: '#/components/schemas/CanvasTemplate',
          },
        },
      },
    },
  ],
} as const;

export const CreateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'description', 'language'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
  },
} as const;

export const UpdateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['templateId'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
  },
} as const;

export const UpsertCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Canvas template',
          $ref: '#/components/schemas/CanvasTemplate',
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateCategoryResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template category list',
          items: {
            $ref: '#/components/schemas/CanvasTemplateCategory',
          },
        },
      },
    },
  ],
} as const;

export const UpsertResourceRequestSchema = {
  type: 'object',
  required: ['title', 'resourceType'],
  properties: {
    title: {
      type: 'string',
      description: 'Resource title',
      example: 'My Resource',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    resourceId: {
      type: 'string',
      description: 'Resource ID (only used for update)',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    data: {
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key',
    },
    content: {
      type: 'string',
      description: 'Resource content (this will be ignored if storageKey was set)',
    },
  },
} as const;

export const UpsertResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const BatchCreateResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const ReindexResourceRequestSchema = {
  type: 'object',
  required: ['resourceIds'],
  properties: {
    resourceIds: {
      type: 'array',
      description: 'Resource ID list',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ReindexResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const DeleteResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to delete',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const GetResourceDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Resource data',
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const ListDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Document',
          },
        },
      },
    },
  ],
} as const;

export const GetDocumentDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Document data',
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const UpsertDocumentRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    docId: {
      type: 'string',
      description: 'Document ID (only used for update)',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
      default: false,
    },
    initialContent: {
      type: 'string',
      description: 'Document initial content',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID to bind with',
    },
  },
} as const;

export const UpsertDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const DeleteDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to delete',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const GetActionResultResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ActionResult',
        },
      },
    },
  ],
} as const;

export const AbortActionRequestSchema = {
  type: 'object',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    version: {
      type: 'integer',
      description: 'Action result version',
    },
  },
} as const;

export const ListProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Project list',
          items: {
            $ref: '#/components/schemas/Project',
          },
        },
      },
    },
  ],
} as const;

export const GetProjectDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpsertProjectRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID (only used for update)',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Project cover storage key',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions',
    },
  },
} as const;

export const UpsertProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpdateProjectItemsRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    operation: {
      type: 'string',
      description: 'Operation type',
      enum: ['add', 'remove'],
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const DeleteProjectRequestSchema = {
  type: 'object',
  required: ['projectId'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID to delete',
      example: 'p-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const DeleteProjectItemsRequestSchema = {
  type: 'object',
  required: ['projectId', 'items'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const SkillEventTypeSchema = {
  type: 'string',
  description: 'Skill event type',
  enum: [
    'start',
    'end',
    'stream',
    'log',
    'artifact',
    'structured_data',
    'token_usage',
    'create_node',
    'tool_call_start',
    'tool_call_stream',
    'error',
  ],
} as const;

export const SkillEventSchema = {
  type: 'object',
  required: ['event', 'resultId'],
  properties: {
    event: {
      description: 'Event type',
      $ref: '#/components/schemas/SkillEventType',
    },
    skillMeta: {
      description: 'Skill metadata',
      $ref: '#/components/schemas/SkillMeta',
    },
    step: {
      description: 'Action step metadata',
      $ref: '#/components/schemas/ActionStepMeta',
    },
    resultId: {
      type: 'string',
      description: 'Result ID',
    },
    version: {
      type: 'number',
      description: 'Result version',
    },
    content: {
      type: 'string',
      description: 'Event content. Only present when `event` is `stream`',
    },
    reasoningContent: {
      type: 'string',
      description: 'Reasoning content. Only present when `event` is `stream`',
    },
    tokenUsage: {
      description: 'Token usage data. Only present when `event` is `token_usage`.',
      $ref: '#/components/schemas/TokenUsageItem',
    },
    log: {
      description: 'Log data. Only present when `event` is `log`.',
      $ref: '#/components/schemas/ActionLog',
    },
    structuredData: {
      type: 'object',
      description: 'Structured data. Only present when `event` is `structured_data`.',
    },
    artifact: {
      description: 'Artifact data. Only present when `event` is `artifact`.',
      $ref: '#/components/schemas/Artifact',
    },
    node: {
      description: 'Canvas node data. Only present when `event` is `create_node`.',
      $ref: '#/components/schemas/CanvasNode',
    },
    error: {
      description: 'Error data. Only present when `event` is `error`.',
      $ref: '#/components/schemas/BaseResponse',
    },
    originError: {
      type: 'string',
      description: 'Original error message. Only present when `event` is `error`.',
    },
    toolCallResult: {
      description: 'Tool call result data.',
      $ref: '#/components/schemas/ToolCallResult',
    },
  },
} as const;

export const ToolCallResultSchema = {
  type: 'object',
  required: ['callId', 'status', 'createdAt', 'updatedAt'],
  properties: {
    callId: {
      type: 'string',
      description: 'Tool call ID (run_id from LangChain)',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    toolsetId: {
      type: 'string',
      description: 'Toolset ID (toolsetKey)',
    },
    toolName: {
      type: 'string',
      description: 'Tool name',
    },
    stepName: {
      type: 'string',
      description: 'Step name (the action step in which this tool was called)',
    },
    input: {
      oneOf: [
        {
          type: 'object',
        },
        {
          type: 'string',
        },
      ],
      description: 'Tool input arguments',
    },
    output: {
      oneOf: [
        {
          type: 'object',
        },
        {
          type: 'string',
        },
      ],
      description: 'Tool output result',
    },
    error: {
      type: 'string',
      description: 'Error message if tool execution failed',
    },
    status: {
      type: 'string',
      description: 'Tool call status',
      enum: ['executing', 'completed', 'failed'],
    },
    createdAt: {
      type: 'number',
      description: 'Tool call start timestamp (milliseconds)',
    },
    updatedAt: {
      type: 'number',
      description: 'Tool call last update timestamp (milliseconds)',
    },
    deletedAt: {
      type: 'number',
      description: 'Tool call deletion timestamp (milliseconds)',
    },
  },
} as const;

export const ShareRecordSchema = {
  type: 'object',
  required: ['shareId', 'entityType', 'entityId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    createdAt: {
      type: 'string',
      description: 'Create timestamp',
    },
    updatedAt: {
      type: 'string',
      description: 'Update timestamp',
    },
  },
} as const;

export const UpsertCodeArtifactRequestSchema = {
  type: 'object',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Code artifact ID (not needed for creation)',
    },
    title: {
      type: 'string',
      description: 'Code artifact title',
    },
    type: {
      type: 'string',
      description: 'Code artifact type',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Action result version',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    previewStorageKey: {
      type: 'string',
      description: 'Code artifact preview storage key',
    },
    createIfNotExists: {
      type: 'boolean',
      description: 'Whether to create the code artifact if it does not exist',
      default: false,
    },
  },
} as const;

export const UpsertCodeArtifactResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const ListCodeArtifactResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Code artifact list',
          items: {
            $ref: '#/components/schemas/CodeArtifact',
          },
        },
      },
    },
  ],
} as const;

export const GetCodeArtifactDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const DuplicateCodeArtifactRequestSchema = {
  type: 'object',
  required: ['artifactId'],
  properties: {
    artifactId: {
      type: 'string',
      description: 'Code artifact ID to duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const CreateShareRequestSchema = {
  type: 'object',
  required: ['entityType', 'entityId'],
  properties: {
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
      default: false,
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    shareData: {
      type: 'string',
      description: 'Raw share data (JSON string)',
    },
    shareDataStorageKey: {
      type: 'string',
      description: 'Share data storage key',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
    creditUsage: {
      type: 'number',
      description: 'Credit usage',
    },
  },
} as const;

export const CreateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ShareRecord',
          description: 'Share created',
        },
      },
    },
  ],
} as const;

export const ListShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Share record list',
          items: {
            $ref: '#/components/schemas/ShareRecord',
          },
        },
      },
    },
  ],
} as const;

export const DeleteShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
  },
} as const;

export const DuplicateShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to duplicate the share to',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
    title: {
      type: 'string',
      description: 'Custom title for the duplicated entity',
    },
  },
} as const;

export const DuplicateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Duplicated entity',
          $ref: '#/components/schemas/Entity',
        },
      },
    },
  ],
} as const;

export const ListLabelClassesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label class list',
          items: {
            $ref: '#/components/schemas/LabelClass',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelClassRequestSchema = {
  type: 'object',
  required: ['name', 'displayName', 'prompt'],
  properties: {
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'my_class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpdateLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'My Class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpsertLabelClassResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Label class upserted',
          $ref: '#/components/schemas/LabelClass',
        },
      },
    },
  ],
} as const;

export const DeleteLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID to delete',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListLabelInstancesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label list',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelClassId', 'valueList', 'entityType', 'entityId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    valueList: {
      type: 'array',
      description: 'Label value list',
      items: {
        type: 'string',
        example: 'label-1',
      },
    },
    entityType: {
      description: 'Label entity type',
      $ref: '#/components/schemas/EntityType',
    },
    entityId: {
      description: 'Label entity ID',
      type: 'string',
    },
  },
} as const;

export const UpdateLabelInstanceRequestSchema = {
  type: 'object',
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to update',
    },
    value: {
      type: 'string',
      description: 'Updated label value',
    },
  },
} as const;

export const UpsertLabelInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label instance upserted',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const DeleteLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelId'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to delete',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ActionSchema = {
  type: 'object',
  required: ['actionType', 'actionName'],
  properties: {
    actionType: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    actionName: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ListActionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Action list',
          items: {
            $ref: '#/components/schemas/Action',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/Skill',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const SkillInstanceCreateParamSchema = {
  type: 'object',
  required: ['displayName'],
  properties: {
    tplName: {
      type: 'string',
      description: 'Skill template name',
      example: 'online-search',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const CreateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['instanceList'],
  properties: {
    instanceList: {
      type: 'array',
      description: 'Skill instances to upsert',
      items: {
        $ref: '#/components/schemas/SkillInstanceCreateParam',
      },
    },
  },
} as const;

export const CreateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill instance list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 's-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const UpdateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Skill instance list',
          $ref: '#/components/schemas/SkillInstance',
        },
      },
    },
  ],
} as const;

export const PinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to pin',
    },
  },
} as const;

export const UnpinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to unpin',
    },
  },
} as const;

export const DeleteSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to delete',
    },
  },
} as const;

export const SkillInputSchema = {
  type: 'object',
  description: 'Skill input',
  properties: {
    query: {
      type: 'string',
      description: 'User query',
    },
    originalQuery: {
      type: 'string',
      description: 'Original user query',
    },
    images: {
      type: 'array',
      description: 'Image list (storage keys)',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const SkillContextResourceItemSchema = {
  type: 'object',
  description: 'Skill context resource item',
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID (if empty, this will be considered as external resource)',
    },
    resource: {
      description: 'Resource',
      $ref: '#/components/schemas/Resource',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this resource is current',
    },
    metadata: {
      type: 'object',
      description: 'Resource context metadata',
    },
  },
} as const;

export const SkillContextDocumentItemSchema = {
  type: 'object',
  description: 'Skill context document item',
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
    },
    document: {
      description: 'Document',
      $ref: '#/components/schemas/Document',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this document is current',
    },
    metadata: {
      type: 'object',
      description: 'Canvas context metadata',
    },
  },
} as const;

export const SkillContextCodeArtifactItemSchema = {
  type: 'object',
  description: 'Skill context code artifact item',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    codeArtifact: {
      description: 'Code artifact',
      $ref: '#/components/schemas/CodeArtifact',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this code artifact is current',
    },
    metadata: {
      type: 'object',
      description: 'Code artifact context metadata',
    },
  },
} as const;

export const SkillContextContentItemSchema = {
  type: 'object',
  description: 'Skill context content item',
  required: ['content'],
  properties: {
    content: {
      type: 'string',
      description: 'Content',
    },
    metadata: {
      type: 'object',
      description: 'Content context metadata',
    },
  },
} as const;

export const SkillContextUrlItemSchema = {
  type: 'object',
  description: 'Skill context url item',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'URL',
    },
    metadata: {
      type: 'object',
      description: 'URL context metadata',
    },
  },
} as const;

export const SkillContextMediaItemSchema = {
  type: 'object',
  description: 'Skill context media item',
  required: ['mediaType', 'entityId', 'title', 'url', 'storageKey'],
  properties: {
    mediaType: {
      type: 'string',
      description: 'Media type',
      $ref: '#/components/schemas/MediaType',
    },
    entityId: {
      type: 'string',
      description: 'Media entity ID',
    },
    title: {
      type: 'string',
      description: 'Media title',
    },
    url: {
      type: 'string',
      description: 'Media URL',
    },
    storageKey: {
      type: 'string',
      description: 'Media storage key',
    },
    metadata: {
      type: 'object',
      description: 'Media context metadata',
    },
  },
} as const;

export const SkillContextSchema = {
  type: 'object',
  description: 'Skill invocation context',
  properties: {
    resources: {
      type: 'array',
      description: 'Context resources',
      items: {
        $ref: '#/components/schemas/SkillContextResourceItem',
      },
    },
    documents: {
      type: 'array',
      description: 'Context documents',
      items: {
        $ref: '#/components/schemas/SkillContextDocumentItem',
      },
    },
    codeArtifacts: {
      type: 'array',
      description: 'Context code artifacts',
      items: {
        $ref: '#/components/schemas/SkillContextCodeArtifactItem',
      },
    },
    contentList: {
      type: 'array',
      description: 'Context content list',
      items: {
        $ref: '#/components/schemas/SkillContextContentItem',
      },
    },
    urls: {
      type: 'array',
      description: 'List of URLs',
      items: {
        $ref: '#/components/schemas/SkillContextUrlItem',
      },
      deprecated: true,
    },
    mediaList: {
      type: 'array',
      description: 'List of media',
      items: {
        $ref: '#/components/schemas/SkillContextMediaItem',
      },
    },
  },
} as const;

export const SelectionKeySchema = {
  type: 'string',
  enum: [
    'documentSelection',
    'resourceSelection',
    'skillResponseSelection',
    'extensionWeblinkSelection',
    'documentCursorSelection',
    'documentBeforeCursorSelection',
    'documentAfterCursorSelection',
  ],
} as const;

export const ActionTypeSchema = {
  type: 'string',
  enum: ['skill', 'tool', 'media'],
} as const;

export const AgentModeSchema = {
  type: 'string',
  enum: ['copilot_agent', 'node_agent'],
} as const;

export const InvokeSkillRequestSchema = {
  type: 'object',
  properties: {
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    resultHistory: {
      type: 'array',
      description: 'Skill result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
    runtimeConfig: {
      description: 'Skill runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
      deprecated: true,
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
      deprecated: true,
    },
    skillName: {
      type: 'string',
      description: 'Skill name (if not provided, commonQnA will be used)',
      deprecated: true,
    },
    target: {
      description: 'Skill invocation target',
      $ref: '#/components/schemas/Entity',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    resultId: {
      type: 'string',
      description: `Result ID associated with this invocation.
1) If not provided, a new resultId will be generated.
2) If there is no existing result with this resultId, it will be created and run.
3) If there is an existing result with this resultId, it will be rerun.
`,
    },
    locale: {
      type: 'string',
      description: 'Selected output locale',
    },
    modelName: {
      type: 'string',
      description: 'Selected model',
      deprecated: true,
    },
    modelItemId: {
      type: 'string',
      description: 'Selected model item ID',
    },
    skillId: {
      type: 'string',
      description: 'Skill ID',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
    },
    selectedMcpServers: {
      type: 'array',
      description: 'Selected MCP servers (deprecated, use `tools` instead)',
      items: {
        type: 'string',
      },
      deprecated: true,
    },
    toolsets: {
      type: 'array',
      description: 'Selected toolsets',
      items: {
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    mode: {
      description: 'Agent mode',
      $ref: '#/components/schemas/AgentMode',
      default: 'node_agent',
    },
    copilotSessionId: {
      type: 'string',
      description: 'Copilot session ID',
    },
    workflowExecutionId: {
      type: 'string',
      description: 'Workflow execution ID for workflow context',
    },
    workflowNodeExecutionId: {
      type: 'string',
      description: 'Workflow node execution ID for workflow context',
    },
  },
} as const;

export const InvokeSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        resultId: {
          type: 'string',
          description: 'Skill result ID',
        },
      },
    },
  ],
} as const;

export const ListSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const SkillTriggerCreateParamSchema = {
  type: 'object',
  required: ['skillId', 'displayName', 'triggerType'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether this trigger is enabled',
    },
  },
} as const;

export const CreateSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerList'],
  properties: {
    triggerList: {
      type: 'array',
      description: 'Skill triggers to upsert',
      items: {
        $ref: '#/components/schemas/SkillTriggerCreateParam',
      },
    },
  },
} as const;

export const CreateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerRequestSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/SkillTriggerCreateParam',
    },
    {
      type: 'object',
      required: ['triggerId'],
      properties: {
        triggerId: {
          type: 'string',
          description: 'Trigger ID',
          example: 'tr-g30e1b80b5g1itbemc0g5jj3',
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Updated skill trigger',
          $ref: '#/components/schemas/SkillTrigger',
        },
      },
    },
  ],
} as const;

export const DeleteSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerId'],
  properties: {
    triggerId: {
      type: 'string',
      description: 'Trigger ID to delete',
    },
  },
} as const;

export const MediaTypeSchema = {
  type: 'string',
  description: 'media type',
  enum: ['image', 'video', 'audio'],
  example: 'image',
} as const;

export const MediaGenerateRequestSchema = {
  type: 'object',
  required: ['mediaType', 'prompt'],
  properties: {
    mediaType: {
      $ref: '#/components/schemas/MediaType',
    },
    model: {
      type: 'string',
      description: 'Model name for content generation',
    },
    targetType: {
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Target ID',
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    provider: {
      type: 'string',
      description: 'Optional provider selection (use providerItemId instead)',
      nullable: true,
    },
    prompt: {
      type: 'string',
      description: 'Text prompt for content generation',
    },
    wait: {
      type: 'boolean',
      description: 'Whether to wait for the generation to complete',
      default: false,
    },
    resultId: {
      type: 'string',
      description: 'Media generation result ID',
    },
    parentResultId: {
      type: 'string',
      description: 'Parent result ID for the media generation (usually the actor agent result ID)',
    },
    apiKey: {
      type: 'string',
      description: 'API key for the provider',
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    input: {
      type: 'object',
      description: 'Flexible key-value pairs for additional input parameters',
      additionalProperties: true,
    },
    unitCost: {
      type: 'number',
      description: 'Unit cost for the media generation',
    },
  },
} as const;

export const MediaGenerateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        resultId: {
          type: 'string',
          description: 'Media generation result ID',
          example: 'ar-g30e1b80b5g1itbemc0g5jj3',
        },
        outputUrl: {
          type: 'string',
          description: 'Media generation output URL (only available when `wait` is true)',
        },
        storageKey: {
          type: 'string',
          description: 'Media generation output storage key (only available when `wait` is true)',
        },
        originalResult: {
          type: 'object',
          description: 'Media generation original result from provider',
        },
      },
    },
  ],
} as const;

export const PilotStepStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'finish', 'failed'],
} as const;

export const PilotStepSchema = {
  type: 'object',
  properties: {
    stepId: {
      type: 'string',
      description: 'Pilot step ID',
    },
    name: {
      type: 'string',
      description: 'Pilot step name',
    },
    epoch: {
      type: 'number',
      description: 'Pilot step epoch',
    },
    entityId: {
      type: 'string',
      description: 'Pilot step entity ID',
    },
    entityType: {
      type: 'string',
      description: 'Pilot step entity type',
    },
    status: {
      description: 'Pilot step status',
      $ref: '#/components/schemas/PilotStepStatus',
    },
    rawOutput: {
      type: 'string',
      description: 'Pilot step raw output',
    },
    actionResult: {
      description: 'Pilot step action result',
      $ref: '#/components/schemas/ActionResult',
    },
    createdAt: {
      type: 'string',
      description: 'Pilot step created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Pilot step updated at',
    },
  },
} as const;

export const PilotSessionStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'waiting', 'finish', 'failed'],
} as const;

export const PilotSessionSchema = {
  type: 'object',
  required: [
    'sessionId',
    'status',
    'targetType',
    'targetId',
    'title',
    'input',
    'currentEpoch',
    'maxEpoch',
  ],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    title: {
      type: 'string',
      description: 'Pilot session title',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    status: {
      description: 'Pilot session status',
      $ref: '#/components/schemas/PilotSessionStatus',
    },
    targetType: {
      description: 'Pilot session target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Pilot session target ID',
    },
    currentEpoch: {
      type: 'number',
      description: 'Pilot session current epoch',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
    },
    steps: {
      type: 'array',
      description: 'Pilot steps',
      items: {
        $ref: '#/components/schemas/PilotStep',
      },
    },
    createdAt: {
      type: 'string',
      description: 'Pilot session created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Pilot session updated at',
    },
  },
} as const;

export const CreatePilotSessionRequestSchema = {
  type: 'object',
  required: ['targetId', 'targetType', 'input'],
  properties: {
    targetId: {
      type: 'string',
      description: 'Pilot session target ID',
    },
    targetType: {
      description: 'Pilot session target type',
      $ref: '#/components/schemas/EntityType',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
      default: 2,
    },
    title: {
      type: 'string',
      description: 'Pilot session title',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    providerItemId: {
      type: 'string',
      description: 'Pilot session provider item ID',
    },
  },
} as const;

export const UpdatePilotSessionRequestSchema = {
  type: 'object',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
      default: 2,
    },
  },
} as const;

export const RecoverPilotSessionRequestSchema = {
  type: 'object',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID to recover',
    },
    stepIds: {
      type: 'array',
      description:
        'Optional array of specific step IDs to recover. If not provided, recovers all failed steps in the current epoch.',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const UpsertPilotSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Upserted pilot session',
          $ref: '#/components/schemas/PilotSession',
        },
      },
    },
  ],
} as const;

export const ListPilotSessionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Pilot session list',
          items: {
            $ref: '#/components/schemas/PilotSession',
          },
        },
      },
    },
  ],
} as const;

export const GetPilotSessionDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Pilot session detail',
          $ref: '#/components/schemas/PilotSession',
        },
      },
    },
  ],
} as const;

export const CopilotSessionSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Copilot session ID',
    },
    title: {
      type: 'string',
      description: 'Copilot session title',
    },
    canvasId: {
      type: 'string',
      description: 'Copilot session canvas ID',
    },
    createdAt: {
      type: 'string',
      description: 'Copilot session created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Copilot session updated at',
    },
    results: {
      type: 'array',
      description: 'Copilot session results (only returned in detail API)',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
  },
} as const;

export const ListCopilotSessionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Copilot session list',
          items: {
            $ref: '#/components/schemas/CopilotSession',
          },
        },
      },
    },
  ],
} as const;

export const GetCopilotSessionDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Copilot session detail',
          $ref: '#/components/schemas/CopilotSession',
        },
      },
    },
  ],
} as const;

export const UpdateUserSettingsRequestSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'User name',
      example: 'john_name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
    avatarStorageKey: {
      type: 'string',
      description: 'User avatar storage key',
    },
    uiLocale: {
      type: 'string',
      description: 'UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'Output locale',
      example: 'en',
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const CheckSettingsFieldResultSchema = {
  type: 'object',
  required: ['field', 'value', 'available'],
  properties: {
    field: {
      type: 'string',
      description: 'Settings field',
    },
    value: {
      type: 'string',
      description: 'Settings field value',
    },
    available: {
      type: 'boolean',
      description: 'Whether the field value is available',
    },
  },
} as const;

export const CheckSettingsFieldResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Settings field check result',
          $ref: '#/components/schemas/CheckSettingsFieldResult',
        },
      },
    },
  ],
} as const;

export const CreateCheckoutSessionRequestSchema = {
  type: 'object',
  required: ['planType'],
  properties: {
    planType: {
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Subscription billing interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
  },
} as const;

export const CreateCheckoutSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Checkout session',
          properties: {
            url: {
              type: 'string',
              description: 'Checkout session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const CreatePortalSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Portal session',
          properties: {
            url: {
              type: 'string',
              description: 'Portal session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditRechargeResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit recharge data with pagination',
          properties: {
            data: {
              type: 'array',
              description: 'Credit recharge list',
              items: {
                $ref: '#/components/schemas/CreditRecharge',
              },
            },
            total: {
              type: 'integer',
              description: 'Total number of records',
            },
            page: {
              type: 'integer',
              description: 'Current page number',
            },
            pageSize: {
              type: 'integer',
              description: 'Number of items per page',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage data with pagination',
          properties: {
            data: {
              type: 'array',
              description: 'Credit usage list',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
            total: {
              type: 'integer',
              description: 'Total number of records',
            },
            page: {
              type: 'integer',
              description: 'Current page number',
            },
            pageSize: {
              type: 'integer',
              description: 'Number of items per page',
            },
          },
        },
      },
    },
  ],
} as const;

export const getCreditBalanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit balance',
          properties: {
            creditBalance: {
              type: 'number',
              description: 'Credit balance',
            },
            creditAmount: {
              type: 'number',
              description: 'Credit amount',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByResultIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by result ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by result ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by result ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByExecutionIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by execution ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by execution ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by execution ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByCanvasIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by canvas ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by canvas ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by canvas ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionPlanSchema = {
  type: 'object',
  properties: {
    planType: {
      type: 'string',
      description: 'Subscription plan type',
    },
    creditQuota: {
      type: 'number',
      description: 'Credit quota per month',
    },
    dailyGiftCreditQuota: {
      type: 'number',
      description: 'Daily gift credit quota',
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T1)',
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T2)',
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes)',
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
    },
  },
} as const;

export const GetSubscriptionPlansResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Subscription plans',
          items: {
            $ref: '#/components/schemas/SubscriptionPlan',
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionUsageDataSchema = {
  type: 'object',
  properties: {
    token: {
      description: 'Token usage meter',
      $ref: '#/components/schemas/TokenUsageMeter',
    },
    storage: {
      description: 'Storage usage meter',
      $ref: '#/components/schemas/StorageUsageMeter',
    },
    fileParsing: {
      description: 'File parsing meter',
      $ref: '#/components/schemas/FileParsingMeter',
    },
  },
} as const;

export const GetSubscriptionUsageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Subscription usage',
          $ref: '#/components/schemas/SubscriptionUsageData',
        },
      },
    },
  ],
} as const;

export const WebSearchRequestSchema = {
  type: 'object',
  properties: {
    q: {
      type: 'string',
      description: 'Search query',
    },
    hl: {
      type: 'string',
      description: 'Language/locale code',
    },
    gl: {
      type: 'string',
      description: 'Country/region code',
    },
    location: {
      type: 'string',
      description: 'Location string',
    },
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
  },
} as const;

export const BatchWebSearchRequestSchema = {
  type: 'object',
  properties: {
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
    queries: {
      type: 'array',
      description: 'Web search queries',
      items: {
        $ref: '#/components/schemas/WebSearchRequest',
      },
    },
  },
} as const;

export const MultiLingualWebSearchRequestSchema = {
  type: 'object',
  required: ['query', 'searchLocaleList'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query',
    },
    searchLocaleList: {
      type: 'array',
      description: 'List of search locales',
      items: {
        type: 'string',
      },
    },
    displayLocale: {
      type: 'string',
      description: 'Display locale',
      default: 'auto',
    },
    searchLimit: {
      type: 'number',
      description: 'Web search result limit per locale',
    },
    enableRerank: {
      type: 'boolean',
      description: 'Whether to enable reranking of search results',
    },
    rerankLimit: {
      type: 'number',
      description: 'Limit for reranked results',
    },
    rerankRelevanceThreshold: {
      type: 'number',
      description: 'Relevance threshold for reranking',
    },
  },
} as const;

export const MultiLingualWebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Multilingual web search results',
          required: ['sources', 'searchSteps'],
          properties: {
            sources: {
              type: 'array',
              description: 'Search result sources',
              items: {
                $ref: '#/components/schemas/Source',
              },
            },
            searchSteps: {
              type: 'array',
              description: 'Search steps',
              items: {
                $ref: '#/components/schemas/SearchStep',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const WebSearchResultSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Web search result name',
    },
    url: {
      type: 'string',
      description: 'Web search result url',
    },
    snippet: {
      type: 'string',
      description: 'Web search result snippet',
    },
    locale: {
      type: 'string',
      description: 'Web search result locale',
    },
  },
} as const;

export const WebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Web search results',
          items: {
            $ref: '#/components/schemas/WebSearchResult',
          },
        },
      },
    },
  ],
} as const;

export const RerankResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Reranked results',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const SearchOptionsSchema = {
  type: 'object',
  description: 'Search options for internal use',
  properties: {
    enableReranker: {
      type: 'boolean',
      description: 'Whether to enable reranker',
      default: true,
    },
  },
} as const;

export const SearchDomainSchema = {
  type: 'string',
  enum: ['resource', 'document', 'canvas'],
} as const;

export const SearchModeSchema = {
  type: 'string',
  enum: ['keyword', 'vector', 'hybrid'],
} as const;

export const SearchRequestSchema = {
  type: 'object',
  required: ['query'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query (if empty, return last updated data)',
    },
    domains: {
      type: 'array',
      description: 'Search domains (if not specified, return all domains)',
      items: {
        $ref: '#/components/schemas/SearchDomain',
      },
    },
    entities: {
      type: 'array',
      description: 'Search entities',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
    mode: {
      type: 'string',
      description: 'Search mode',
      $ref: '#/components/schemas/SearchMode',
      default: 'keyword',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    limit: {
      type: 'number',
      description: 'Search result limit for each domain',
      default: 5,
    },
  },
} as const;

export const SearchResultSnippetSchema = {
  type: 'object',
  properties: {
    text: {
      type: 'string',
      description: 'Search result content text',
    },
    highlightedText: {
      type: 'string',
      description: 'Search result highlighted content text with em html tags',
    },
  },
} as const;

export const SearchResultSchema = {
  type: 'object',
  required: ['id', 'domain', 'title'],
  properties: {
    id: {
      type: 'string',
      description: 'Search result ID to navigate to',
    },
    domain: {
      description: 'Search result domain',
      $ref: '#/components/schemas/SearchDomain',
    },
    title: {
      type: 'string',
      description: 'Search result title',
    },
    highlightedTitle: {
      type: 'string',
      description: 'Search result highlighted title with em html tags',
    },
    contentPreview: {
      type: 'string',
      description: 'Search result content preview',
    },
    snippets: {
      type: 'array',
      description: 'Search result content list with highlight marks',
      items: {
        $ref: '#/components/schemas/SearchResultSnippet',
      },
    },
    relevanceScore: {
      type: 'number',
      description: 'Search result relevance score',
    },
    metadata: {
      type: 'object',
      description: 'Search result metadata',
      additionalProperties: true,
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data update time',
    },
  },
} as const;

export const SearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Search result',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const ScrapeWeblinkRequestSchema = {
  type: 'object',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
    },
  },
} as const;

export const ScrapeWeblinkResultSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Weblink title',
    },
    description: {
      type: 'string',
      description: 'Weblink description',
    },
    image: {
      type: 'string',
      description: 'Weblink image',
    },
  },
} as const;

export const ScrapeWeblinkResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Weblink scrape result',
          $ref: '#/components/schemas/ScrapeWeblinkResult',
        },
      },
    },
  ],
} as const;

export const FileVisibilitySchema = {
  type: 'string',
  enum: ['public', 'private'],
} as const;

export const UploadRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'File to upload',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    visibility: {
      description: 'File visibility (default is private)',
      $ref: '#/components/schemas/FileVisibility',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key (if provided, the file will be replaced if it already exists)',
    },
  },
} as const;

export const UploadResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'File upload result',
          required: ['url', 'storageKey'],
          properties: {
            url: {
              type: 'string',
              description: 'File URL',
            },
            storageKey: {
              type: 'string',
              description: 'Storage key',
            },
          },
        },
      },
    },
  ],
} as const;

export const ConvertRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'The file to convert',
    },
    from: {
      type: 'string',
      description: 'Source format (e.g., html)',
      default: 'html',
    },
    to: {
      type: 'string',
      description: 'Target format (e.g., markdown)',
      default: 'markdown',
    },
  },
} as const;

export const ConvertResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description: 'Converted markdown content',
            },
          },
        },
      },
    },
  ],
} as const;

export const MediaGenerationModelCapabilitiesSchema = {
  type: 'object',
  properties: {
    image: {
      type: 'boolean',
      description: 'Whether this model supports image generation',
    },
    video: {
      type: 'boolean',
      description: 'Whether this model supports video generation',
    },
    audio: {
      type: 'boolean',
      description: 'Whether this model supports audio generation',
    },
  },
} as const;

export const ModelCapabilitiesSchema = {
  type: 'object',
  properties: {
    functionCall: {
      type: 'boolean',
      description: 'Whether this model supports function calling',
    },
    vision: {
      type: 'boolean',
      description: 'Whether this model can take images as input',
    },
    reasoning: {
      type: 'boolean',
      description: 'Whether this model includes reasoning content',
    },
    contextCaching: {
      type: 'boolean',
      description: 'Whether this model supports context caching',
    },
    image: {
      type: 'boolean',
      description: 'Whether this model supports image generation',
    },
    video: {
      type: 'boolean',
      description: 'Whether this model supports video generation',
    },
    audio: {
      type: 'boolean',
      description: 'Whether this model supports audio generation',
    },
  },
} as const;

export const ModelInfoSchema = {
  type: 'object',
  required: ['name', 'label', 'provider', 'contextLimit', 'maxOutput'],
  properties: {
    name: {
      type: 'string',
      description: 'Model name',
    },
    label: {
      type: 'string',
      description: 'Model label',
    },
    provider: {
      type: 'string',
      description: 'Model provider',
    },
    providerItemId: {
      type: 'string',
      description: 'Model provider item ID',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
    isDefault: {
      type: 'boolean',
      description: 'Whether this model is the default model',
    },
    group: {
      type: 'string',
      description: 'Model group',
    },
    category: {
      type: 'string',
      description: 'Model category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    creditBilling: {
      $ref: '#/components/schemas/CreditBilling',
      description: 'Credit billing info',
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
  },
} as const;

export const ListModelsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Model list',
          items: {
            $ref: '#/components/schemas/ModelInfo',
          },
        },
      },
    },
  ],
} as const;

export const ProviderCategorySchema = {
  type: 'string',
  enum: [
    'llm',
    'embedding',
    'reranker',
    'webSearch',
    'urlParsing',
    'pdfParsing',
    'mediaGeneration',
  ],
} as const;

export const ProviderSchema = {
  type: 'object',
  description: 'General provider info',
  required: ['providerId', 'providerKey', 'categories', 'name', 'enabled'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the provider is global',
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key (this will never be exposed to the frontend)',
    },
  },
} as const;

export const LLMModelConfigSchema = {
  type: 'object',
  description: 'Provider config for LLMs',
  required: ['modelId', 'modelName'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Model ID',
    },
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    disallowTemperature: {
      type: 'boolean',
      description: 'Whether the model disallow setting custom temperature',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
  },
} as const;

export const MediaModelParameterSchema = {
  type: 'object',
  description: 'Media generation parameter configuration',
  required: ['name', 'type', 'required', 'visible'],
  properties: {
    name: {
      type: 'string',
      description: 'Parameter name',
    },
    type: {
      type: 'string',
      description: 'Parameter type',
      enum: ['url', 'text', 'option'],
    },
    value: {
      oneOf: [
        {
          type: 'string',
          description: 'String value for url/text type or option value',
        },
        {
          type: 'array',
          description: 'Array of URLs for url type',
          items: {
            type: 'string',
          },
        },
        {
          type: 'number',
          description: 'Numeric value for option type',
        },
        {
          type: 'integer',
          description: 'Integer value for option type',
        },
        {
          type: 'boolean',
          description: 'Boolean value for option type',
        },
      ],
    },
    options: {
      type: 'array',
      description: 'Available options for option type',
      items: {
        oneOf: [
          {
            type: 'string',
            description: 'String option',
          },
          {
            type: 'number',
            description: 'Numeric option',
          },
          {
            type: 'integer',
            description: 'Integer option',
          },
          {
            type: 'boolean',
            description: 'Boolean option',
          },
        ],
      },
    },
    description: {
      type: 'string',
      description: 'Parameter description',
    },
    required: {
      type: 'boolean',
      description: 'Whether this parameter is required',
    },
    visible: {
      type: 'boolean',
      description: 'Whether this parameter should be displayed in UI',
    },
  },
} as const;

export const MediaGenerationModelConfigSchema = {
  type: 'object',
  description: 'Provider config for media generation',
  required: ['modelId', 'modelName'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Model ID',
    },
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/MediaGenerationModelCapabilities',
    },
    description: {
      type: 'string',
      description: 'Model description',
    },
    supportedLanguages: {
      type: 'array',
      description: 'Supported languages for translation',
      items: {
        type: 'string',
        example: ['en', 'zh', 'ja', 'ko'],
      },
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    outputParameters: {
      type: 'array',
      description: 'Output parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    baseModel: {
      type: 'string',
      description: 'Base model for the model',
    },
  },
} as const;

export const EmbeddingModelConfigSchema = {
  type: 'object',
  description: 'Provider config for embeddings',
  required: ['modelId', 'dimensions'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Embedding model ID',
    },
    modelName: {
      type: 'string',
      description: 'Embedding model name',
    },
    dimensions: {
      type: 'number',
      description: 'Embedding model dimension',
    },
    batchSize: {
      type: 'number',
      description: 'Embedding model batch size',
    },
  },
} as const;

export const RerankerModelConfigSchema = {
  type: 'object',
  description: 'Provider config for rerankers',
  required: ['modelId'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Reranking model ID',
    },
    modelName: {
      type: 'string',
      description: 'Reranking model name',
    },
    topN: {
      type: 'number',
      description: 'Number of top results to return',
    },
    relevanceThreshold: {
      type: 'number',
      description: 'Minimum relevance score threshold (0.0-1.0)',
    },
  },
} as const;

export const ProviderItemConfigSchema = {
  oneOf: [
    {
      $ref: '#/components/schemas/LLMModelConfig',
    },
    {
      $ref: '#/components/schemas/EmbeddingModelConfig',
    },
    {
      $ref: '#/components/schemas/RerankerModelConfig',
    },
    {
      $ref: '#/components/schemas/MediaGenerationModelConfig',
    },
  ],
} as const;

export const CreditBillingSchema = {
  type: 'object',
  description: 'Credit billing configuration for provider items',
  required: ['unitCost', 'unit', 'minCharge'],
  properties: {
    unitCost: {
      type: 'number',
      description: 'Credit consumption per unit usage',
      minimum: 0,
    },
    unit: {
      type: 'string',
      description: 'Measurement unit (e.g., token, product, second)',
      example: '5k_tokens',
    },
    minCharge: {
      type: 'number',
      description: 'Minimum credit charge per request',
      minimum: 0,
    },
    isEarlyBirdFree: {
      type: 'boolean',
      description: 'Whether this billing is free for early bird users',
      default: false,
    },
  },
} as const;

export const ProviderItemOptionSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      type: 'string',
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    config: {
      type: 'object',
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
  },
} as const;

export const ProviderItemSchema = {
  type: 'object',
  required: ['itemId', 'name', 'providerId', 'category', 'enabled'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    provider: {
      type: 'object',
      description: 'Provider detail info',
      $ref: '#/components/schemas/Provider',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
    creditBilling: {
      description: 'Credit billing info',
      $ref: '#/components/schemas/CreditBilling',
    },
  },
} as const;

export const CreditRechargeSchema = {
  type: 'object',
  description: 'Credit recharge record for user balance management',
  required: [
    'rechargeId',
    'uid',
    'amount',
    'balance',
    'enabled',
    'expiresAt',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    rechargeId: {
      type: 'string',
      description: 'Unique recharge record ID',
    },
    uid: {
      type: 'string',
      description: 'User UID who owns this recharge record',
    },
    amount: {
      type: 'integer',
      description: 'Original recharge amount in credits',
      minimum: 0,
    },
    balance: {
      type: 'integer',
      description: 'Remaining balance for this recharge record',
      minimum: 0,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether this recharge record is enabled (false after 30 days)',
      default: true,
    },
    source: {
      type: 'string',
      description: 'Recharge source type',
      enum: ['subscription', 'purchase', 'gift', 'promotion', 'refund', 'commission'],
      default: 'purchase',
    },
    description: {
      type: 'string',
      description: 'Optional description for this recharge',
    },
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    extraData: {
      type: 'string',
      description: 'Extra data for this recharge (JSON)',
      $ref: '#/components/schemas/CreditRechargeExtraData',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID (if applicable)',
    },
    title: {
      type: 'string',
      description: 'Related share title (if applicable)',
    },
    expiresAt: {
      type: 'string',
      format: 'date-time',
      description: 'Expiration timestamp (30 days from creation)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Record creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Record last update timestamp',
    },
  },
} as const;

export const CreditUsageSchema = {
  type: 'object',
  description: 'Credit usage record for tracking consumption',
  required: ['usageId', 'uid', 'amount', 'usageType', 'createdAt'],
  properties: {
    usageId: {
      type: 'string',
      description: 'Unique usage record ID',
    },
    uid: {
      type: 'string',
      description: 'User UID who consumed the credits',
    },
    amount: {
      type: 'integer',
      description: 'Amount of credits consumed',
      minimum: 0,
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID that consumed the credits',
    },
    modelName: {
      type: 'string',
      description: 'Model name used for this consumption',
    },
    usageType: {
      type: 'string',
      description: 'Type of usage that consumed credits',
      enum: ['model_call', 'media_generation', 'embedding', 'reranking', 'commission', 'other'],
      default: 'model_call',
    },
    actionResultId: {
      type: 'string',
      description: 'Related action result ID (if applicable)',
    },
    pilotSessionId: {
      type: 'string',
      description: 'Related pilot session ID (if applicable)',
    },
    description: {
      type: 'string',
      description: 'Optional description for this usage',
    },
    modelUsageDetails: {
      type: 'string',
      description: 'Model usage details for skill execution (JSON array of model usage)',
    },
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    extraData: {
      type: 'string',
      description: 'Extra data for this usage (JSON)',
      $ref: '#/components/schemas/CreditUsageExtraData',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID (if applicable)',
    },
    title: {
      type: 'string',
      description: 'Related share title (if applicable)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Usage record creation timestamp',
    },
  },
} as const;

export const CreditRechargeExtraDataSchema = {
  type: 'object',
  description: 'Extra data for credit recharge',
  properties: {
    appId: {
      type: 'string',
      description: 'Related app ID',
    },
    executionId: {
      type: 'string',
      description: 'Related execution ID',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID',
    },
    title: {
      type: 'string',
      description: 'Related share title',
    },
    commissionRate: {
      type: 'number',
      description: 'Commission rate',
    },
  },
} as const;

export const CreditUsageExtraDataSchema = {
  type: 'object',
  description: 'Extra data for credit usage',
  properties: {
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    executionId: {
      type: 'string',
      description: 'Related execution ID',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID',
    },
    title: {
      type: 'string',
      description: 'Related share title',
    },
    commissionRate: {
      type: 'number',
      description: 'Commission rate',
    },
    toolsetKey: {
      type: 'string',
      description: 'Related toolset key',
    },
    toolsetName: {
      type: 'string',
      description: 'Related toolset name',
    },
    toolKey: {
      type: 'string',
      description: 'Related tool key',
    },
    toolName: {
      type: 'string',
      description: 'Related tool name',
    },
  },
} as const;

export const ListProvidersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Provider',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderRequestSchema = {
  type: 'object',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID (only for update)',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key',
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
  },
} as const;

export const UpsertProviderResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Provider',
        },
      },
    },
  ],
} as const;

export const DeleteProviderRequestSchema = {
  type: 'object',
  required: ['providerId'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
  },
} as const;

export const TestProviderConnectionRequestSchema = {
  type: 'object',
  required: ['providerId'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID to test',
    },
    category: {
      description: 'Provider category to test (optional)',
      $ref: '#/components/schemas/ProviderCategory',
    },
  },
} as const;

export const ProviderTestResultSchema = {
  type: 'object',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        type: 'string',
      },
    },
    status: {
      type: 'string',
      description: 'Test result status',
      enum: ['success', 'failed', 'unknown'],
    },
    message: {
      type: 'string',
      description: 'Test result message',
    },
    details: {
      type: 'object',
      description: 'Detailed test results',
      additionalProperties: true,
    },
    timestamp: {
      type: 'string',
      description: 'Test timestamp',
      format: 'date-time',
    },
  },
} as const;

export const TestProviderConnectionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ProviderTestResult',
        },
      },
    },
  ],
} as const;

export const ListProviderItemOptionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItemOption',
          },
        },
      },
    },
  ],
} as const;

export const ListProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderItemRequestSchema = {
  type: 'object',
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID (only for update)',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    globalItemId: {
      type: 'string',
      description: 'Global provider item ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
  },
} as const;

export const UpsertProviderItemResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ProviderItem',
        },
      },
    },
  ],
} as const;

export const BatchUpsertProviderItemsRequestSchema = {
  type: 'object',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Provider items to upsert',
      items: {
        $ref: '#/components/schemas/UpsertProviderItemRequest',
      },
    },
  },
} as const;

export const BatchUpsertProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Upserted provider items',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const DeleteProviderItemRequestSchema = {
  type: 'object',
  required: ['itemId'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
  },
} as const;

export const ToolsetAuthTypeSchema = {
  type: 'string',
  description: 'Toolset auth type',
  enum: ['credentials', 'oauth'],
} as const;

export const ToolDefinitionSchema = {
  type: 'object',
  required: ['name', 'descriptionDict'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name',
    },
    descriptionDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Tool description dictionary for humans',
    },
  },
} as const;

export const AuthPatternSchema = {
  type: 'object',
  required: ['type', 'pattern'],
  properties: {
    type: {
      type: 'string',
      description: 'Auth pattern type',
      $ref: '#/components/schemas/ToolsetAuthType',
    },
    credentialItems: {
      type: 'array',
      description: 'Credential items, only for `credentials` type',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
    provider: {
      type: 'string',
      description: 'Auth provider, only for `oauth` type',
    },
    scope: {
      type: 'array',
      description: 'Auth scope, only for `oauth` type',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ToolsetDefinitionSchema = {
  type: 'object',
  required: ['key', 'labelDict', 'descriptionDict'],
  properties: {
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    domain: {
      type: 'string',
      description: 'Toolset domain (used for display icon)',
    },
    labelDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset label dictionary',
    },
    descriptionDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset description dictionary for humans',
    },
    tools: {
      type: 'array',
      description: 'Toolset tools',
      items: {
        $ref: '#/components/schemas/ToolDefinition',
      },
    },
    requiresAuth: {
      type: 'boolean',
      description: 'Whether the toolset requires auth',
      default: false,
    },
    authPatterns: {
      type: 'array',
      description: 'Toolset auth patterns',
      items: {
        $ref: '#/components/schemas/AuthPattern',
      },
    },
    configItems: {
      type: 'array',
      description: 'Toolset config items',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
  },
} as const;

export const ToolsetInstanceSchema = {
  type: 'object',
  required: ['toolsetId', 'name', 'key'],
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the toolset is global',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the toolset is enabled',
    },
    authType: {
      $ref: '#/components/schemas/ToolsetAuthType',
      description: 'Toolset auth type',
    },
    authData: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset auth data',
    },
    config: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset config',
    },
    definition: {
      description: 'Toolset definition',
      $ref: '#/components/schemas/ToolsetDefinition',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Toolset creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Toolset update timestamp',
    },
  },
} as const;

export const ListToolsetInventoryResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolsetDefinition',
          },
        },
      },
    },
  ],
} as const;

export const ListToolsetsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolsetInstance',
          },
        },
      },
    },
  ],
} as const;

export const UpsertToolsetRequestSchema = {
  type: 'object',
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID (only for update)',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the toolset is enabled',
    },
    authType: {
      $ref: '#/components/schemas/ToolsetAuthType',
      description: 'Toolset auth type',
    },
    authData: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset auth data',
    },
    config: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset config',
    },
    provider: {
      type: 'string',
      description: 'OAuth toolset provider',
    },
    scope: {
      type: 'array',
      description: 'OAuth toolset scope',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const UpsertToolsetResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ToolsetInstance',
        },
      },
    },
  ],
} as const;

export const InitiateComposioConnectionResponseSchema = {
  type: 'object',
  required: ['redirectUrl', 'connectionRequestId', 'app'],
  properties: {
    redirectUrl: {
      type: 'string',
      format: 'uri',
      description: 'OAuth redirect URL provided by Composio.',
    },
    connectionRequestId: {
      type: 'string',
      description: 'Connection request identifier from Composio.',
    },
    app: {
      type: 'string',
      description: 'Composio app slug (e.g., gmail, slack).',
    },
  },
} as const;

export const ComposioConnectionStatusSchema = {
  type: 'string',
  description: 'Current status of the Composio connection.',
  enum: ['active', 'revoked'],
} as const;

export const ComposioConnectionStatusResponseSchema = {
  type: 'object',
  required: ['status', 'integrationId'],
  properties: {
    status: {
      $ref: '#/components/schemas/ComposioConnectionStatus',
    },
    connectedAccountId: {
      type: 'string',
      nullable: true,
      description: 'Connected account identifier returned by Composio, if available.',
    },
    integrationId: {
      type: 'string',
      description: 'Composio integration identifier (app slug).',
    },
  },
} as const;

export const ComposioRevokeResponseSchema = {
  type: 'object',
  required: ['success', 'message'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the connection was revoked successfully.',
    },
    message: {
      type: 'string',
      description: 'Human-readable message describing the outcome.',
    },
  },
} as const;

export const GenericToolsetTypeSchema = {
  type: 'string',
  enum: ['regular', 'mcp', 'external_oauth'],
} as const;

export const GenericToolsetSchema = {
  type: 'object',
  required: ['type', 'id', 'name'],
  properties: {
    type: {
      $ref: '#/components/schemas/GenericToolsetType',
      description: 'Toolset type',
    },
    id: {
      type: 'string',
      description: 'Toolset ID (toolsetId for regular toolset, name for MCP toolset)',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    builtin: {
      type: 'boolean',
      description: 'Whether the toolset is builtin',
    },
    uninstalled: {
      type: 'boolean',
      description: 'Whether the toolset is uninstalled',
    },
    toolset: {
      $ref: '#/components/schemas/ToolsetInstance',
      description: 'Toolset detail',
    },
    mcpServer: {
      $ref: '#/components/schemas/McpServerDTO',
      description: 'MCP server',
    },
    selectedTools: {
      type: 'array',
      description: 'Selected tools (used for skill invocation)',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ListToolsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/GenericToolset',
          },
        },
      },
    },
  ],
} as const;

export const DeleteToolsetRequestSchema = {
  type: 'object',
  required: ['toolsetId'],
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
  },
} as const;

export const DocumentInterfaceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description:
        'An optional identifier for the document. Ideally this should be unique across the document collection and formatted as a UUID.',
    },
    pageContent: {
      type: 'string',
      description: 'The main content of the document.',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Metadata associated with the document.',
    },
  },
} as const;

export const InMemorySearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/DocumentInterface',
          },
        },
      },
    },
  ],
} as const;

export const CanvasNodeTypeSchema = {
  type: 'string',
  enum: [
    'document',
    'codeArtifact',
    'website',
    'resource',
    'skill',
    'tool',
    'skillResponse',
    'toolResponse',
    'memo',
    'group',
    'image',
    'video',
    'audio',
    'mediaSkill',
    'mediaSkillResponse',
    'start',
  ],
} as const;

export const CanvasNodeDataSchema = {
  type: 'object',
  description: 'Node data',
  required: ['title', 'entityId'],
  properties: {
    title: {
      type: 'string',
      description: 'Node title',
    },
    editedTitle: {
      type: 'string',
      description: 'Node edited title',
    },
    entityId: {
      type: 'string',
      description: 'Node entity ID',
    },
    contentPreview: {
      type: 'string',
      description: 'Node content preview',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Node metadata',
    },
  },
} as const;

export const XYPositionSchema = {
  type: 'object',
  required: ['x', 'y'],
  properties: {
    x: {
      type: 'number',
      description: 'Node position x',
    },
    y: {
      type: 'number',
      description: 'Node position y',
    },
  },
} as const;

export const CanvasNodeSchema = {
  type: 'object',
  required: ['id', 'type', 'position', 'data'],
  properties: {
    id: {
      type: 'string',
      description: 'Node ID',
    },
    type: {
      description: 'Node type',
      $ref: '#/components/schemas/CanvasNodeType',
    },
    position: {
      $ref: '#/components/schemas/XYPosition',
      description: 'Node position',
    },
    offsetPosition: {
      $ref: '#/components/schemas/XYPosition',
      description: 'Node offset position',
    },
    data: {
      type: 'object',
      description: 'Node data',
      $ref: '#/components/schemas/CanvasNodeData',
    },
    style: {
      type: 'object',
      description: 'Node style',
    },
    selected: {
      type: 'boolean',
      description: 'Whether the node is selected',
    },
    dragging: {
      type: 'boolean',
      description: 'Whether the node is being dragged',
    },
    parentId: {
      type: 'string',
      description: 'Parent node ID',
    },
  },
} as const;

export const CanvasEdgeSchema = {
  type: 'object',
  required: ['id', 'source', 'target', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Edge ID',
    },
    source: {
      type: 'string',
      description: 'Edge source node ID',
    },
    target: {
      type: 'string',
      description: 'Edge target node ID',
    },
    type: {
      type: 'string',
      description: 'Edge type',
    },
  },
} as const;

export const InitializeWorkflowRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to initialize workflow for',
      example: 'canvas-123',
    },
    sourceCanvasId: {
      type: 'string',
      description: 'Source canvas ID',
      example: 'canvas-456',
    },
    sourceCanvasData: {
      description: 'Source canvas data',
      $ref: '#/components/schemas/RawCanvasData',
    },
    createNewCanvas: {
      description: 'Whether to create a new canvas',
      type: 'boolean',
      default: false,
    },
    nodeBehavior: {
      description: 'Node behavior when executing workflow',
      type: 'string',
      enum: ['create', 'update'],
      default: 'update',
    },
    variables: {
      type: 'array',
      description: 'Workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    startNodes: {
      type: 'array',
      description: 'Start node IDs',
      items: {
        type: 'string',
        example: 'node-123',
      },
    },
  },
} as const;

export const InitializeWorkflowResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          required: ['workflowExecutionId'],
          properties: {
            workflowExecutionId: {
              type: 'string',
              description: 'Workflow execution ID',
              example: 'we-abc123',
            },
          },
        },
      },
    },
  ],
} as const;

export const WorkflowNodeExecutionSchema = {
  type: 'object',
  required: ['nodeId'],
  properties: {
    nodeExecutionId: {
      type: 'string',
      description: 'Node execution ID',
    },
    nodeId: {
      type: 'string',
      description: 'Node ID',
    },
    nodeType: {
      type: 'string',
      description: 'Node type',
    },
    nodeData: {
      type: 'string',
      description: 'Node data',
    },
    entityId: {
      type: 'string',
      description: 'Node entity ID',
    },
    newEntityId: {
      type: 'string',
      description: 'New node entity ID',
    },
    title: {
      type: 'string',
      description: 'Node title',
    },
    status: {
      description: 'Node status',
      $ref: '#/components/schemas/ActionStatus',
    },
    progress: {
      type: 'number',
      description: 'Node progress',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Node creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Node update timestamp',
    },
  },
} as const;

export const WorkflowExecutionStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'finish', 'failed'],
} as const;

export const WorkflowExecutionSchema = {
  type: 'object',
  required: ['executionId'],
  properties: {
    executionId: {
      type: 'string',
      description: 'Workflow execution ID',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Workflow title',
    },
    status: {
      $ref: '#/components/schemas/WorkflowExecutionStatus',
      description: 'Workflow status',
    },
    nodeExecutions: {
      type: 'array',
      description: 'Node executions',
      items: {
        $ref: '#/components/schemas/WorkflowNodeExecution',
      },
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow update timestamp',
    },
  },
} as const;

export const GetWorkflowDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          $ref: '#/components/schemas/WorkflowExecution',
        },
      },
    },
  ],
} as const;

export const CreateWorkflowAppRequestSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'description', 'query', 'variables', 'coverStorageKey'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Workflow app title',
    },
    description: {
      type: 'string',
      description: 'Workflow app description',
    },
    query: {
      type: 'string',
      description: 'Workflow app query',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    resultNodeIds: {
      type: 'array',
      description: 'Result node IDs',
      items: {
        type: 'string',
      },
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover image storage key',
    },
    remixEnabled: {
      type: 'boolean',
      description: 'Whether remix is enabled for this app',
    },
  },
} as const;

export const DeleteWorkflowAppRequestSchema = {
  type: 'object',
  required: ['appId'],
  properties: {
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
  },
} as const;

export const WorkflowAppSchema = {
  type: 'object',
  required: ['appId', 'canvasId', 'variables'],
  properties: {
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
    shareId: {
      type: 'string',
      description: 'Share ID for public access and URL generation',
    },
    title: {
      type: 'string',
      description: 'Workflow app title',
    },
    description: {
      type: 'string',
      description: 'Workflow app description',
    },
    owner: {
      description: 'Workflow app owner',
      $ref: '#/components/schemas/ShareUser',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    query: {
      type: 'string',
      description: 'Workflow app query',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    resultNodeIds: {
      type: 'array',
      description: 'Result node IDs',
      items: {
        type: 'string',
      },
    },
    remixEnabled: {
      type: 'boolean',
      description: 'Whether remix is enabled for this app',
    },
    coverUrl: {
      type: 'string',
      description: 'Cover image URL',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow app creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow app update timestamp',
    },
  },
} as const;

export const CreateWorkflowAppResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/WorkflowApp',
        },
      },
    },
  ],
} as const;

export const GetWorkflowAppDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/WorkflowApp',
        },
      },
    },
  ],
} as const;

export const ListWorkflowAppsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of workflow apps',
          items: {
            $ref: '#/components/schemas/WorkflowApp',
          },
        },
      },
    },
  ],
} as const;

export const ExecuteWorkflowAppRequestSchema = {
  type: 'object',
  required: ['shareId', 'variables'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Workflow app share ID for execution',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
  },
} as const;

export const ExecuteWorkflowAppResultSchema = {
  type: 'object',
  required: ['executionId'],
  properties: {
    executionId: {
      type: 'string',
      description: 'Workflow execution ID',
    },
  },
} as const;

export const ExecuteWorkflowAppResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ExecuteWorkflowAppResult',
        },
      },
    },
  ],
} as const;

export const ValueTypeSchema = {
  type: 'string',
  enum: ['text', 'resource'],
} as const;

export const ResourceValueSchema = {
  type: 'object',
  required: ['name', 'fileType', 'storageKey'],
  properties: {
    name: {
      type: 'string',
      description: 'Resource name',
    },
    fileType: {
      description: 'Resource file type',
      $ref: '#/components/schemas/VariableResourceType',
    },
    storageKey: {
      type: 'string',
      description: 'Resource storage key',
    },
    entityId: {
      type: 'string',
      description: 'Resource ID',
    },
  },
} as const;

export const VariableValueSchema = {
  type: 'object',
  required: ['type'],
  properties: {
    type: {
      description: 'Variable type',
      $ref: '#/components/schemas/ValueType',
    },
    text: {
      type: 'string',
      description: 'Variable text value (for text type)',
    },
    resource: {
      description: 'Variable resource value (for resource type)',
      $ref: '#/components/schemas/ResourceValue',
    },
  },
} as const;

export const VariableResourceTypeSchema = {
  type: 'string',
  enum: ['document', 'image', 'video', 'audio'],
} as const;

export const WorkflowVariableSchema = {
  type: 'object',
  description: 'Workflow variable definition',
  required: ['name', 'value', 'variableId'],
  properties: {
    variableId: {
      type: 'string',
      description: 'Variable ID, unique and readonly',
    },
    name: {
      type: 'string',
      description: 'Variable name',
      example: 'userName',
    },
    value: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VariableValue',
      },
      description: 'Variable values',
    },
    description: {
      type: 'string',
      description: 'Variable description',
      example: '',
    },
    createdAt: {
      type: 'string',
      description: 'Variable created at',
      example: '2021-01-01T00:00:00.000Z',
    },
    updatedAt: {
      type: 'string',
      description: 'Variable updated at',
      example: '2021-01-01T00:00:00.000Z',
    },
    variableType: {
      type: 'string',
      description: 'Variable type',
      enum: ['string', 'option', 'resource'],
    },
    required: {
      type: 'boolean',
      description: 'Whether the variable is required',
      example: true,
    },
    isSingle: {
      type: 'boolean',
      description: 'Whether the variable value is single (not multiple)',
      example: true,
    },
    options: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Variable options (only valid when variable type is option)',
      example: ['', ''],
    },
    resourceTypes: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VariableResourceType',
      },
      description: 'Supported resource types (only valid when variable type is resource)',
    },
  },
} as const;

export const GetWorkflowVariablesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const UpdateWorkflowVariablesRequestSchema = {
  type: 'object',
  required: ['canvasId', 'variables'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    variables: {
      type: 'array',
      description: 'List of workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
  },
} as const;

export const UpdateWorkflowVariablesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Updated list of workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const SendEmailRequestSchema = {
  type: 'object',
  required: ['subject', 'html'],
  properties: {
    subject: {
      type: 'string',
      description: 'Email subject',
    },
    html: {
      type: 'string',
      description: 'Email HTML content',
    },
    to: {
      type: 'string',
      description: 'Email recipient. If not specified, the email will be sent to current user.',
    },
    from: {
      type: 'string',
      description: 'Email sender. If not specified, server will use the default sender.',
    },
    attachments: {
      type: 'array',
      description: 'Email attachments, should be array of URLs.',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const GenerateAppTemplateRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to generate template for',
      pattern: '^[a-zA-Z0-9_-]+$',
      example: 'canvas-123',
    },
  },
} as const;

export const AppTemplateResultSchema = {
  type: 'object',
  required: ['templateContent', 'variables', 'metadata'],
  properties: {
    templateContent: {
      type: 'string',
      description: `Template with placeholders for user interaction.
Variables are represented using handlebars syntax (e.g., {{variableName}}).
`,
      example:
        'Create a {{workflowType}} workflow with {{variableCount}} variables including {{primarySkill}} functionality',
    },
    variables: {
      type: 'array',
      description: 'List of related workflow variables used in the template',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    metadata: {
      type: 'object',
      required: ['extractedAt', 'variableCount'],
      properties: {
        extractedAt: {
          type: 'number',
          description: 'Template generation timestamp (for version control)',
          example: 1703123456789,
        },
        variableCount: {
          type: 'number',
          description: 'Total variable count (for frontend statistics display)',
          example: 5,
        },
        promptCount: {
          type: 'number',
          description: 'Original prompt count (for quality assessment)',
          example: 3,
        },
        canvasComplexity: {
          type: 'string',
          description: 'Canvas complexity level',
          enum: ['simple', 'medium', 'complex'],
          example: 'medium',
        },
        workflowType: {
          type: 'string',
          description: 'Workflow type (for template classification and display)',
          example: 'data-processing',
        },
        templateVersion: {
          type: 'number',
          description: 'Template version number (supports template iteration)',
          example: 1,
        },
        workflowTitle: {
          type: 'string',
          description: 'Workflow title for display',
          example: 'Data Processing Pipeline',
        },
        workflowDescription: {
          type: 'string',
          description: 'Workflow description',
          example: 'Automated data processing workflow',
        },
        estimatedExecutionTime: {
          type: 'string',
          description: 'Estimated execution time',
          example: '5-10 minutes',
        },
        skillTags: {
          type: 'array',
          description: 'Skill tags for categorization',
          items: {
            type: 'string',
          },
          example: ['data-processing', 'automation'],
        },
      },
    },
  },
} as const;

import { z } from 'zod/v3';
import { GenericToolset, RawCanvasData } from '@refly/openapi-schema';
import { genNodeEntityId, genNodeID, genUniqueId } from '@refly/utils';
import { IContextItem } from '@refly/common-types';

export const workflowPlanSchema = z.object({
  tasks: z
    .array(
      z.object({
        id: z.string().min(1, 'Task ID cannot be empty').describe('Unique ID for the task'),
        title: z
          .string()
          .min(1, 'Task title cannot be empty')
          .describe('Display title for the task'),
        prompt: z
          .string()
          .min(1, 'Task prompt cannot be empty')
          .describe('The prompt or instruction for this task'),
        products: z
          .array(z.string().min(1, 'Product ID cannot be empty').describe('Product ID'))
          .optional()
          .describe('Products expected to be generated by this task'),
        dependentTasks: z
          .array(z.string().describe('Task ID'))
          .optional()
          .describe('Tasks that must be executed before this task'),
        dependentProducts: z
          .array(z.string().describe('Product ID'))
          .optional()
          .describe('Products from previous tasks that should be consumed by this task'),
        toolsets: z
          .array(z.string().describe('Toolset ID'))
          .describe('Toolsets selected for this task'),
      }),
    )
    .describe('Array of workflow tasks to be executed'),
  products: z
    .array(
      z.object({
        id: z
          .string()
          .min(1, 'Product ID cannot be empty')
          .describe('Unique identifier for the product'),
        type: z
          .enum(['document', 'codeArtifact', 'image', 'video', 'audio'])
          .describe('Type of the product'),
        title: z
          .string()
          .min(1, 'Product title cannot be empty')
          .describe('Display title of the product'),
        intermediate: z.boolean().describe('Whether this product is intermediate').optional(),
      }),
    )
    .describe('Array of products to be generated by the workflow'),
  variables: z
    .array(
      z.object({
        variableId: z
          .string()
          .min(1, 'Variable ID cannot be empty')
          .describe('Variable ID, unique and readonly'),
        variableType: z
          .literal('string')
          .describe('Variable type (currently only string is supported)'),
        name: z
          .string()
          .min(1, 'Variable name cannot be empty')
          .describe('Variable name used in the workflow'),
        description: z.string().describe('Description of what this variable represents'),
        value: z
          .array(
            z.object({
              type: z.literal('text'),
              text: z.string().min(1, 'Variable text value cannot be empty'),
            }),
          )
          .min(1, 'Variable values are required')
          .describe('Variable values'),
      }),
    )
    .describe('Array of variables defined for the workflow'),
});

export type WorkflowPlan = z.infer<typeof workflowPlanSchema>;

// Enhanced parsing function with detailed error reporting
export type ParseWorkflowPlanResult = {
  success: boolean;
  data?: WorkflowPlan;
  error?: string;
};

export const parseWorkflowPlan = (data: unknown): ParseWorkflowPlanResult => {
  const result = workflowPlanSchema.safeParse(data);

  if (result.success) {
    return { success: true, data: result.data };
  }

  // Collect detailed error messages
  const errorMessages: string[] = [];

  for (const issue of result.error.issues) {
    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
    errorMessages.push(`[${path}]: ${issue.message}`);
  }

  return {
    success: false,
    error: `Workflow plan validation failed:\n${errorMessages.join('\n')}`,
  };
};

export const normalizeWorkflowPlan = (plan: WorkflowPlan): WorkflowPlan => {
  return {
    ...plan,
    tasks:
      plan.tasks?.map((task) => {
        // Ensure toolsets array exists
        const toolsets = Array.isArray(task.toolsets) ? [...task.toolsets] : [];

        // Check if task has products
        if (Array.isArray(task.products) && task.products.length > 0) {
          // Get product types for this task
          const productTypes = new Set<string>();
          for (const productId of task.products) {
            const product = plan.products?.find((p) => p.id === productId);
            if (product?.type) {
              productTypes.add(product.type);
            }
          }

          // Add required toolsets based on product types
          if (productTypes.has('document') && !toolsets.includes('generate_doc')) {
            toolsets.push('generate_doc');
          }

          if (productTypes.has('codeArtifact') && !toolsets.includes('generate_code_artifact')) {
            toolsets.push('generate_code_artifact');
          }
        }

        return {
          ...task,
          toolsets,
        };
      }) ?? [],
  };
};

// Generate canvas data from workflow plan
// 1. each task should be represented as a 'skillResponse' node
// 2. each product should be represented as a product node (e.g. 'document' or 'codeArtifact' nodes) with type being the product type
// 3. connect task nodes to parent 'skillResponse' nodes according to its 'dependentTasks' definition
// 4. connect task nodes to parent product nodes according to its 'dependentProducts' definition
// 4. connect product nodes to parent task nodes according to parent task's 'products' definition
export const generateCanvasDataFromWorkflowPlan = (
  workflowPlan: WorkflowPlan,
  toolsets: GenericToolset[],
): RawCanvasData => {
  const nodes: RawCanvasData['nodes'] = [];
  const edges: RawCanvasData['edges'] = [];

  // Maps to resolve context references
  const taskIdToNodeId = new Map<string, string>();
  const productIdToNodeId = new Map<string, string>();
  const taskIdToEntityId = new Map<string, string>();
  const productIdToEntityId = new Map<string, string>();

  // Simple layout positions
  const taskStartX = 0;
  const productOffsetX = 480;
  const rowStepY = 240;
  const productStepY = 180;

  if (Array.isArray(workflowPlan.tasks)) {
    // Phase 1: Create all task and product nodes, establish mappings
    workflowPlan.tasks.forEach((task, taskIndex) => {
      const taskId = task?.id ?? `task-${taskIndex}`;
      const taskTitle = task?.title ?? '';
      const taskPrompt = task?.prompt ?? '';

      // Build selected toolsets metadata from task toolset ids
      const selectedToolsets: GenericToolset[] = [];
      if (Array.isArray(task.toolsets)) {
        for (const toolsetId of task.toolsets) {
          // Find the corresponding toolset from the available toolsets
          const toolset =
            toolsets?.find((t) => t.id === toolsetId) ||
            toolsets?.find((t) => t.toolset?.key === toolsetId);
          if (toolset) {
            selectedToolsets.push(toolset);
          }
        }
      }

      // Create task node (skillResponse) with empty contextItems for now
      const taskNodeId = genNodeID();
      const taskEntityId = genNodeEntityId('skillResponse');
      const taskNode = {
        id: taskNodeId,
        type: 'skillResponse' as const,
        position: { x: taskStartX, y: taskIndex * rowStepY },
        data: {
          title: taskTitle,
          editedTitle: taskTitle,
          entityId: taskEntityId,
          contentPreview: '',
          metadata: {
            structuredData: { query: taskPrompt },
            selectedToolsets,
            contextItems: [], // Will be populated in phase 2
          },
        },
      };

      nodes.push(taskNode);
      taskIdToNodeId.set(taskId, taskNodeId);
      taskIdToEntityId.set(taskId, taskEntityId);

      // Create product nodes and connect from task node
      if (Array.isArray(task.products) && task.products.length > 0) {
        task.products.forEach((productId, pIndex) => {
          // Find the product definition from the plan's products array
          const productDef = workflowPlan.products?.find((p) => p.id === productId);
          if (!productDef) return;

          const productType = productDef.type;
          const productTitle = productDef.title;

          const productNodeId = genNodeID();
          const productEntityId = genNodeEntityId(productType as any);
          const productNode = {
            id: productNodeId,
            type: productType as any,
            position: {
              x: productOffsetX,
              y: taskIndex * rowStepY + pIndex * productStepY,
            },
            data: {
              title: productTitle,
              entityId: productEntityId,
              contentPreview: '',
              metadata: {
                parentResultId: taskEntityId,
                contextItems: [],
              },
            },
          };

          nodes.push(productNode);
          productIdToNodeId.set(productId, productNodeId);
          productIdToEntityId.set(productId, productEntityId);

          edges.push({
            id: `edge-${genUniqueId()}`,
            source: taskNodeId,
            target: productNodeId,
            type: 'default',
          });
        });
      }
    });

    // Phase 2: Update task nodes with proper contextItems and create dependency edges
    workflowPlan.tasks.forEach((task, taskIndex) => {
      const taskId = task?.id ?? `task-${taskIndex}`;
      const taskNodeId = taskIdToNodeId.get(taskId);
      const taskEntityId = taskIdToEntityId.get(taskId);

      if (!taskNodeId || !taskEntityId) return;

      // Build context items from dependent tasks and products
      const contextItems: IContextItem[] = [];

      // Add dependent tasks to context items
      if (Array.isArray(task.dependentTasks)) {
        for (const dependentTaskId of task.dependentTasks) {
          const dependentEntityId = taskIdToEntityId.get(dependentTaskId);
          if (dependentEntityId) {
            contextItems.push({
              entityId: dependentEntityId,
              type: 'skillResponse',
            });
          }
        }
      }

      // Add dependent products to context items
      if (Array.isArray(task.dependentProducts)) {
        for (const dependentProductId of task.dependentProducts) {
          const dependentEntityId = productIdToEntityId.get(dependentProductId);
          if (dependentEntityId) {
            // Find the product definition to get its type
            const productDef = workflowPlan.products?.find((p) => p.id === dependentProductId);
            if (productDef) {
              contextItems.push({
                entityId: dependentEntityId,
                type: productDef.type as any,
              });
            }
          }
        }
      }

      // Update the task node's contextItems
      const taskNode = nodes.find((n) => n.id === taskNodeId);
      if (taskNode?.data?.metadata) {
        taskNode.data.metadata.contextItems = contextItems;
      }

      // Create edges from dependent tasks to this task
      if (Array.isArray(task.dependentTasks)) {
        for (const dependentTaskId of task.dependentTasks) {
          const sourceNodeId = taskIdToNodeId.get(dependentTaskId);
          if (sourceNodeId) {
            edges.push({
              id: `edge-${genUniqueId()}`,
              source: sourceNodeId,
              target: taskNodeId,
              type: 'default',
            });
          }
        }
      }

      // Create edges from dependent products to this task
      if (Array.isArray(task.dependentProducts)) {
        for (const dependentProductId of task.dependentProducts) {
          const sourceNodeId = productIdToNodeId.get(dependentProductId);
          if (sourceNodeId) {
            edges.push({
              id: `edge-${genUniqueId()}`,
              source: sourceNodeId,
              target: taskNodeId,
              type: 'default',
            });
          }
        }
      }
    });
  }

  return { nodes, edges };
};

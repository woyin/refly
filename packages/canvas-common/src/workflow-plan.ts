import { z } from 'zod/v3';
import { GenericToolset, RawCanvasData } from '@refly/openapi-schema';
import { genNodeEntityId, genNodeID, genUniqueId } from '@refly/utils';

export const workflowPlanSchema = z.object({
  tasks: z
    .array(
      z.object({
        id: z.string().describe('Unique ID for the task'),
        title: z.string().describe('Display title for the task'),
        prompt: z.string().describe('The prompt or instruction for this task'),
        products: z
          .array(z.string().describe('Product ID'))
          .optional()
          .describe('Products expected to be generated by this task'),
        dependentTasks: z
          .array(z.string().describe('Task ID'))
          .optional()
          .describe('Tasks that must be executed before this task'),
        dependentProducts: z
          .array(z.string().describe('Product ID'))
          .optional()
          .describe('Products from previous tasks that should be consumed by this task'),
        toolsets: z
          .array(z.string().describe('Toolset key'))
          .describe('Toolsets selected for this task'),
      }),
    )
    .describe('Array of workflow tasks to be executed'),
  products: z
    .array(
      z.object({
        id: z.string().describe('Unique identifier for the product'),
        type: z
          .enum(['document', 'codeArtifact', 'image', 'video', 'audio'])
          .describe('Type of the product'),
        title: z.string().describe('Display title of the product'),
        intermediate: z.boolean().describe('Whether this product is intermediate').optional(),
      }),
    )
    .describe('Array of products to be generated by the workflow'),
  variables: z
    .array(
      z.object({
        name: z.string().describe('Variable name used in the workflow'),
        type: z.string().describe('Data type of the variable (e.g., string, number, boolean)'),
        description: z.string().describe('Description of what this variable represents'),
      }),
    )
    .describe('Array of variables defined for the workflow'),
});

export type WorkflowPlan = z.infer<typeof workflowPlanSchema>;

// Generate canvas data from workflow plan
// 1. each task should be represented as a 'skillResponse' node
// 2. each product should be represented as a product node (e.g. 'document' or 'codeArtifact' nodes) with type being the product type
// 3. connect task nodes to parent 'skillResponse' nodes according to its 'dependentTasks' definition
// 4. connect task nodes to parent product nodes according to its 'dependentProducts' definition
// 4. connect product nodes to parent task nodes according to parent task's 'products' definition
export const generateCanvasDataFromWorkflowPlan = (
  workflowPlan: WorkflowPlan,
  toolsets: GenericToolset[],
): RawCanvasData => {
  const nodes: RawCanvasData['nodes'] = [];
  const edges: RawCanvasData['edges'] = [];

  // Maps to resolve context references
  const taskIdToNodeId = new Map<string, string>();
  const productIdToNodeId = new Map<string, string>();
  const taskIdToEntityId = new Map<string, string>();

  // Simple layout positions
  const taskStartX = 0;
  const productOffsetX = 480;
  const rowStepY = 240;
  const productStepY = 180;

  if (Array.isArray(workflowPlan.tasks)) {
    workflowPlan.tasks.forEach((task, taskIndex) => {
      const taskId = task?.id ?? `task-${taskIndex}`;
      const taskTitle = task?.title ?? '';
      const taskPrompt = task?.prompt ?? '';

      // Build selected toolsets metadata from task toolset keys
      const selectedToolsets = [];
      if (Array.isArray(task.toolsets)) {
        for (const toolsetKey of task.toolsets) {
          // Find the corresponding toolset from the available toolsets
          const toolset = toolsets?.find((t) => t.id === toolsetKey);
          if (toolset) {
            selectedToolsets.push({
              type: toolset.type,
              id: toolset.id,
              name: toolset.name,
              selectedTools: toolset.selectedTools,
              builtin: toolset.builtin,
            });
          }
        }
      }

      // Create task node (skillResponse)
      const taskNodeId = genNodeID();
      const taskEntityId = genNodeEntityId('skillResponse');
      const taskNode = {
        id: taskNodeId,
        type: 'skillResponse' as const,
        position: { x: taskStartX, y: taskIndex * rowStepY },
        data: {
          title: taskTitle,
          entityId: taskEntityId,
          contentPreview: '',
          metadata: {
            structuredData: { query: taskPrompt },
            selectedToolsets,
            contextItems: [],
          },
        },
      };

      nodes.push(taskNode);
      taskIdToNodeId.set(taskId, taskNodeId);
      taskIdToEntityId.set(taskId, taskEntityId);

      // Create edges from dependent tasks to this task
      if (Array.isArray(task.dependentTasks)) {
        for (const dependentTaskId of task.dependentTasks) {
          const sourceNodeId = taskIdToNodeId.get(dependentTaskId);
          if (sourceNodeId) {
            edges.push({
              id: `edge-${genUniqueId()}`,
              source: sourceNodeId,
              target: taskNodeId,
              type: 'default',
            });
          }
        }
      }

      // Create edges from dependent products to this task
      if (Array.isArray(task.dependentProducts)) {
        for (const dependentProductId of task.dependentProducts) {
          const sourceNodeId = productIdToNodeId.get(dependentProductId);
          if (sourceNodeId) {
            edges.push({
              id: `edge-${genUniqueId()}`,
              source: sourceNodeId,
              target: taskNodeId,
              type: 'default',
            });
          }
        }
      }

      // Create product nodes and connect from task node
      if (Array.isArray(task.products) && task.products.length > 0) {
        task.products.forEach((productId, pIndex) => {
          // Find the product definition from the plan's products array
          const productDef = workflowPlan.products?.find((p) => p.id === productId);
          if (!productDef) return;

          const productType = productDef.type;
          const productTitle = productDef.title;

          const productNodeId = genNodeID();
          const productEntityId = genNodeEntityId(productType as any);
          const productNode = {
            id: productNodeId,
            type: productType as any,
            position: {
              x: productOffsetX,
              y: taskIndex * rowStepY + pIndex * productStepY,
            },
            data: {
              title: productTitle,
              entityId: productEntityId,
              contentPreview: '',
              metadata: {
                parentResultId: taskEntityId,
                contextItems: [],
              },
            },
          };

          nodes.push(productNode);
          productIdToNodeId.set(productId, productNodeId);

          edges.push({
            id: `edge-${genUniqueId()}`,
            source: taskNodeId,
            target: productNodeId,
            type: 'default',
          });
        });
      }
    });
  }

  return { nodes, edges };
};

# LangChain é›†æˆå®Œæ•´æŒ‡å—

## æ–‡æ¡£æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è¯´æ˜ HttpHandler æ¡†æ¶å¦‚ä½•ä¸ LangChain DynamicStructuredTool é›†æˆï¼Œå½¢æˆå®Œæ•´çš„å·¥å…·è°ƒç”¨é“¾è·¯ã€‚

**é‡è¦ï¼š** HttpHandler åªæ˜¯å·¥å…·æ‰§è¡Œå±‚çš„å¢å¼ºï¼Œå®Œæ•´çš„å·¥å…·ç³»ç»Ÿéœ€è¦ä¸ LangChain æ·±åº¦é›†æˆã€‚

---

## ç›®å½•

1. [å®Œæ•´è°ƒç”¨é“¾è·¯](#å®Œæ•´è°ƒç”¨é“¾è·¯)
2. [LangChain Tool ç³»ç»Ÿæ¶æ„](#langchain-tool-ç³»ç»Ÿæ¶æ„)
3. [DynamicStructuredTool è¯¦è§£](#dynamicstructuredtool-è¯¦è§£)
4. [HttpHandler ä½œä¸ºæ‰§è¡Œä»£ç†](#httphandler-ä½œä¸ºæ‰§è¡Œä»£ç†)
   - [è¾“å…¥èµ„æºå¤„ç† (Pre-Handler)](#è¾“å…¥èµ„æºå¤„ç†-pre-handler)
   - [è¾“å‡ºèµ„æºå¤„ç† (Post-Handler)](#è¾“å‡ºèµ„æºå¤„ç†-post-handler)
   - [å“åº” Schema é…ç½®](#å“åº”-schema-é…ç½®)
   - [è‡ªå®šä¹‰ Handler](#è‡ªå®šä¹‰-handler)
5. [å®Œæ•´é›†æˆå®ä¾‹](#å®Œæ•´é›†æˆå®ä¾‹)
   - [å·¥å…·é…ç½®æŒä¹…åŒ– (Tool Inventory)](#å·¥å…·é…ç½®æŒä¹…åŒ–-tool-inventory)
   - [çƒ­æ›´æ–°æœºåˆ¶](#çƒ­æ›´æ–°æœºåˆ¶-1)
   - [Handler æ”¹é€ ](#handler-æ”¹é€ )
   - [LangChain é›†æˆ](#langchain-é›†æˆ)
   - [å“åº”æ ¼å¼åŒ–å¤„ç†](#å“åº”æ ¼å¼åŒ–å¤„ç†)
   - [è®¡è´¹å¤„ç†](#è®¡è´¹å¤„ç†)
   - [å¼‚å¸¸å¤„ç†](#å¼‚å¸¸å¤„ç†)
6. [é…ç½®é©±åŠ¨çš„å·¥å…·æ³¨å†Œ](#é…ç½®é©±åŠ¨çš„å·¥å…·æ³¨å†Œ)
7. [Agent è°ƒç”¨æµç¨‹](#agent-è°ƒç”¨æµç¨‹)
8. [æœ€ä½³å®è·µæ¡ˆä¾‹](#æœ€ä½³å®è·µæ¡ˆä¾‹)
9. [å·¥å…·çƒ­æ›´æ–°æœºåˆ¶](#å·¥å…·çƒ­æ›´æ–°æœºåˆ¶)
10. [å·¥å…·é…ç½®æŒä¹…åŒ–è¡¨è®¾è®¡](#å·¥å…·é…ç½®æŒä¹…åŒ–è¡¨è®¾è®¡)

---

## å®Œæ•´è°ƒç”¨é“¾è·¯

### ç«¯åˆ°ç«¯æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         å®Œæ•´ LangChain å·¥å…·è°ƒç”¨é“¾è·¯                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  ğŸ‘¤ USER INPUT                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  "å¸®æˆ‘ç”Ÿæˆä¸€æ®µè¯­éŸ³ï¼šä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹"                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  ğŸ¤– LANGCHAIN AGENT                                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                              â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  1. LLM ç†è§£æ„å›¾                                                 â”‚   â”‚
â”‚  â”‚     - åˆ†æç”¨æˆ·éœ€æ±‚                                               â”‚   â”‚
â”‚  â”‚     - è¯†åˆ«éœ€è¦è°ƒç”¨çš„å·¥å…·                                          â”‚   â”‚
â”‚  â”‚     - æå–å‚æ•°                                                   â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  è¾“å‡º:                                                           â”‚   â”‚
â”‚  â”‚  {                                                               â”‚   â”‚
â”‚  â”‚    tool: "fish-audio__text_to_speech",                          â”‚   â”‚
â”‚  â”‚    args: {                                                       â”‚   â”‚
â”‚  â”‚      text: "ä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹"                               â”‚   â”‚
â”‚  â”‚    }                                                             â”‚   â”‚
â”‚  â”‚  }                                                               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  ğŸ”§ DYNAMIC STRUCTURED TOOL                                             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                              â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  2. å·¥å…·å®šä¹‰ä¸éªŒè¯                                               â”‚   â”‚
â”‚  â”‚     name: "fish-audio__text_to_speech"                          â”‚   â”‚
â”‚  â”‚     description: "Convert text to speech using Fish Audio"      â”‚   â”‚
â”‚  â”‚     schema: z.object({                                          â”‚   â”‚
â”‚  â”‚       text: z.string().describe("Text to convert"),             â”‚   â”‚
â”‚  â”‚       voice: z.string().optional()                              â”‚   â”‚
â”‚  â”‚     })                                                           â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  3. Zod Schema éªŒè¯                                              â”‚   â”‚
â”‚  â”‚     âœ… text: "ä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹" (valid)                      â”‚   â”‚
â”‚  â”‚     âœ… voice: undefined (optional)                               â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  4. è°ƒç”¨ func (HttpHandler)                                      â”‚   â”‚
â”‚  â”‚     await func({                                                â”‚   â”‚
â”‚  â”‚       text: "ä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹"                              â”‚   â”‚
â”‚  â”‚     })                                                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  ğŸš€ HTTP HANDLER (æ‰§è¡Œä»£ç†)                                             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                              â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  5. Pre-Handlers (èµ„æºå‡†å¤‡)                                      â”‚   â”‚
â”‚  â”‚     - ResourceResolver: å¤„ç†æ–‡ä»¶å¼•ç”¨                             â”‚   â”‚
â”‚  â”‚     - Custom Pre-Handlers: è‡ªå®šä¹‰å¤„ç†                            â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  6. API è°ƒç”¨                                                     â”‚   â”‚
â”‚  â”‚     POST https://api.fish.audio/v1/tts                          â”‚   â”‚
â”‚  â”‚     Headers: { Authorization: "Bearer ..." }                    â”‚   â”‚
â”‚  â”‚     Body: { text: "ä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹" }                      â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  7. å“åº”å¤„ç†                                                     â”‚   â”‚
â”‚  â”‚     - æ¥æ”¶ API å“åº”: { audio: <binary_data>, duration: 5.2 }    â”‚   â”‚
â”‚  â”‚     - ä¿å­˜åˆ°æœ¬åœ°: ./output/fish-audio_123.mp3                    â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  8. è§£æ ResponseSchema                                         â”‚   â”‚
â”‚  â”‚     - è¯»å– responseSchema é…ç½®                                   â”‚   â”‚
â”‚  â”‚     - éå† schema è¯†åˆ«æ‰€æœ‰ isResource: true çš„å­—æ®µ               â”‚   â”‚
â”‚  â”‚     - æå–èµ„æºå­—æ®µè·¯å¾„: ["audio"]                                â”‚   â”‚
â”‚  â”‚     - èµ„æºç±»å‹: audio                                            â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  9. Post-Handlers (èµ„æºä¸Šä¼ )                                     â”‚   â”‚
â”‚  â”‚     - é’ˆå¯¹æ¯ä¸ªèµ„æºå­—æ®µè‡ªåŠ¨å¤„ç†:                                   â”‚   â”‚
â”‚  â”‚       â€¢ è¯»å–æœ¬åœ°æ–‡ä»¶                                             â”‚   â”‚
â”‚  â”‚       â€¢ ResourceUploader: ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡                         â”‚   â”‚
â”‚  â”‚       â€¢ åˆ›å»ºæ•°æ®åº“è®°å½• (staticFile)                              â”‚   â”‚
â”‚  â”‚       â€¢ ç”Ÿæˆ CDN URL                                             â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  10. è¿”å›å¢å¼ºå“åº”                                                â”‚   â”‚
â”‚  â”‚      {                                                           â”‚   â”‚
â”‚  â”‚        success: true,                                            â”‚   â”‚
â”‚  â”‚        localPath: "./output/fish-audio_123.mp3",                 â”‚   â”‚
â”‚  â”‚        fileId: "file_123",                                       â”‚   â”‚
â”‚  â”‚        entityId: "audio_123",                                    â”‚   â”‚
â”‚  â”‚        storageKey: "generated/fish-audio/123.mp3",               â”‚   â”‚
â”‚  â”‚        url: "https://cdn.example.com/audio_123.mp3",             â”‚   â”‚
â”‚  â”‚        data: { duration: 5.2, format: "mp3" }                    â”‚   â”‚
â”‚  â”‚      }                                                           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  ğŸ”§ BACK TO DYNAMIC STRUCTURED TOOL                                     â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                              â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  11. æ ¼å¼åŒ–å·¥å…·è¾“å‡º                                              â”‚   â”‚
â”‚  â”‚      - ResponseFormatter.formatToolResponse()                   â”‚   â”‚
â”‚  â”‚      - æ ¹æ®èµ„æºç±»å‹ (audio) é€‰æ‹©æ ¼å¼åŒ–æ¨¡æ¿                       â”‚   â”‚
â”‚  â”‚      - å°† HttpHandler è¿”å›å€¼è½¬æ¢ä¸ºç”¨æˆ·å‹å¥½çš„æ–‡æœ¬                 â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚      Tool Output:                                                â”‚   â”‚
â”‚  â”‚      "ğŸµ éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼\n"                                        â”‚   â”‚
â”‚  â”‚      "\n"                                                        â”‚   â”‚
â”‚  â”‚      "ğŸ“ æ–‡ä»¶ä¿¡æ¯:\n"                                             â”‚   â”‚
â”‚  â”‚      "  - æ–‡ä»¶ID: audio_123\n"                                   â”‚   â”‚
â”‚  â”‚      "  - æ ¼å¼: mp3\n"                                           â”‚   â”‚
â”‚  â”‚      "  - æ—¶é•¿: 5.2ç§’\n"                                         â”‚   â”‚
â”‚  â”‚      "\n"                                                        â”‚   â”‚
â”‚  â”‚      "ğŸ”— è®¿é—®é“¾æ¥:\n"                                             â”‚   â”‚
â”‚  â”‚      "  https://cdn.example.com/audio_123.mp3"                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚  ğŸ¤– BACK TO LANGCHAIN AGENT                                             â”‚
â”‚  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”  â”‚
â”‚                              â†“                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  11. LLM ç”Ÿæˆæœ€ç»ˆå›å¤                                            â”‚   â”‚
â”‚  â”‚      - æ•´åˆå·¥å…·è¾“å‡º                                              â”‚   â”‚
â”‚  â”‚      - ç”Ÿæˆç”¨æˆ·å‹å¥½çš„å›å¤                                         â”‚   â”‚
â”‚  â”‚                                                                  â”‚   â”‚
â”‚  â”‚  Final Response:                                                 â”‚   â”‚
â”‚  â”‚  "æˆ‘å·²ç»ä¸ºä½ ç”Ÿæˆäº†è¯­éŸ³ï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®ï¼š\n"                â”‚   â”‚
â”‚  â”‚  "https://cdn.example.com/audio_123.mp3"                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                              â†“                                          â”‚
â”‚  ğŸ“¤ USER OUTPUT                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  "æˆ‘å·²ç»ä¸ºä½ ç”Ÿæˆäº†è¯­éŸ³ï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®ï¼š\n"                â”‚   â”‚
â”‚  â”‚  "https://cdn.example.com/audio_123.mp3"                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## LangChain Tool ç³»ç»Ÿæ¶æ„

### æ ¸å¿ƒç»„ä»¶å…³ç³»

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   é…ç½®é©±åŠ¨çš„ LangChain å·¥å…·ç³»ç»Ÿ                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  æ•°æ®åº“é…ç½® (toolsets è¡¨)                              â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  {                                                    â”‚     â”‚
â”‚  â”‚    domain: "fish.audio",                              â”‚     â”‚
â”‚  â”‚    credentials: { apiKey: "..." },                    â”‚     â”‚
â”‚  â”‚    methods: [                                         â”‚     â”‚
â”‚  â”‚      {                                                â”‚     â”‚
â”‚  â”‚        name: "text_to_speech",                        â”‚     â”‚
â”‚  â”‚        endpoint: "https://api.fish.audio/v1/tts",     â”‚     â”‚
â”‚  â”‚        schema: "{...}",                               â”‚     â”‚
â”‚  â”‚        responseSchema: "{...}"                        â”‚     â”‚
â”‚  â”‚      }                                                â”‚     â”‚
â”‚  â”‚    ]                                                  â”‚     â”‚
â”‚  â”‚  }                                                    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â†“                                  â”‚
â”‚                         è¯»å–é…ç½® & çƒ­æ›´æ–°                        â”‚
â”‚                              â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  DynamicToolRegistry                                  â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  - è§£æé…ç½® (JSON.parse)                              â”‚     â”‚
â”‚  â”‚  - æ„å»º Zod Schema                                    â”‚     â”‚
â”‚  â”‚  - åˆ›å»º HttpHandler                                   â”‚     â”‚
â”‚  â”‚  - ç”Ÿæˆ DynamicStructuredTool[]                       â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  DynamicStructuredTool â­                              â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  ğŸ“ è¿è¡Œæ—¶åŠ¨æ€åˆ›å»ºï¼Œæ— éœ€ç»§æ‰¿ï¼                         â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  new DynamicStructuredTool({                          â”‚     â”‚
â”‚  â”‚    name: "fish_audio__text_to_speech",                â”‚     â”‚
â”‚  â”‚    description: "Convert text to speech...",          â”‚     â”‚
â”‚  â”‚    schema: z.object({                                 â”‚     â”‚
â”‚  â”‚      text: z.string(),                                â”‚     â”‚
â”‚  â”‚      reference: z.object({...}).optional()            â”‚     â”‚
â”‚  â”‚    }),                                                â”‚     â”‚
â”‚  â”‚    func: async (args) => {                            â”‚     â”‚
â”‚  â”‚      // ğŸ‘‰ è°ƒç”¨ HttpHandler å¤„ç†                       â”‚     â”‚
â”‚  â”‚      const response = await handler.handle(args);     â”‚     â”‚
â”‚  â”‚      // ğŸ‘‰ æ ¼å¼åŒ–å“åº”                                  â”‚     â”‚
â”‚  â”‚      return ResponseFormatter.format(response);       â”‚     â”‚
â”‚  â”‚    }                                                  â”‚     â”‚
â”‚  â”‚  })                                                   â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  âœ… é…ç½®é©±åŠ¨ï¼šä»æ•°æ®åº“è‡ªåŠ¨ç”Ÿæˆ                         â”‚     â”‚
â”‚  â”‚  âœ… çƒ­æ›´æ–°ï¼šé…ç½®å˜æ›´è‡ªåŠ¨é‡è½½                           â”‚     â”‚
â”‚  â”‚  âœ… ç±»å‹å®‰å…¨ï¼šZod Schema éªŒè¯                          â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â†“                                  â”‚
â”‚                          æ³¨å†Œåˆ° Agent                           â”‚
â”‚                              â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Refly Skill System (LangGraph StateGraph)            â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  - BaseSkill: æŠ€èƒ½åŸºç±»                                 â”‚     â”‚
â”‚  â”‚    â€¢ toRunnable(): ç¼–è¯‘ StateGraph å·¥ä½œæµ              â”‚     â”‚
â”‚  â”‚    â€¢ streamEvents(): æµå¼äº‹ä»¶å‘å°„                      â”‚     â”‚
â”‚  â”‚  - SkillEngine: æä¾› ReflyService èƒ½åŠ›                â”‚     â”‚
â”‚  â”‚    â€¢ åª’ä½“ç”Ÿæˆã€æ–‡æ¡£ç®¡ç†ã€Web æœç´¢ã€RAG æ“ä½œ             â”‚     â”‚
â”‚  â”‚  - ToolService: å·¥å…·å®ä¾‹åŒ–                             â”‚     â”‚
â”‚  â”‚    â€¢ å†…ç½®å·¥å…· (web_search, library_search)            â”‚     â”‚
â”‚  â”‚    â€¢ MCP å·¥å…·ã€OAuth å·¥å…·é›†ã€è‡ªå®šä¹‰å·¥å…·                â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  æ‰§è¡Œæµç¨‹:                                             â”‚     â”‚
â”‚  â”‚  ç”¨æˆ·è¯·æ±‚ â†’ SkillService é¢„æ£€ â†’ SkillInvoker æ‰§è¡Œ     â”‚     â”‚
â”‚  â”‚  â†’ StateGraph èŠ‚ç‚¹æµè½¬ â†’ LLM + bindTools()            â”‚     â”‚
â”‚  â”‚  â†’ æ¡ä»¶è·¯ç”± (tool_calls?) â†’ ToolNode æ‰§è¡Œ             â”‚     â”‚
â”‚  â”‚  â†’ ç»“æœèšåˆ â†’ SSE æµå¼è¿”å› â†’ ä¿å­˜ ActionResult        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              HttpHandler (æ‰§è¡Œå±‚ï¼Œç‹¬ç«‹äº LangChain)               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  BaseHttpHandler (åŸºç¡€å®ç°)                           â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  - handle(request): Promise<response>                 â”‚     â”‚
â”‚  â”‚  - use(preHandler)                                    â”‚     â”‚
â”‚  â”‚  - usePost(postHandler)                               â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  å†…ç½®åŠŸèƒ½:                                             â”‚     â”‚
â”‚  â”‚  âœ“ ResourceResolver (Pre-Handler)                    â”‚     â”‚
â”‚  â”‚    â†’ è§£æ schema ä¸­çš„ isResource å­—æ®µ                 â”‚     â”‚
â”‚  â”‚    â†’ entityId â†’ ä¸‹è½½æ–‡ä»¶ â†’ Buffer                     â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  âœ“ ResponseProcessor                                 â”‚     â”‚
â”‚  â”‚    â†’ è‡ªåŠ¨æ£€æµ‹å“åº”ç±»å‹                                  â”‚     â”‚
â”‚  â”‚    â†’ ä¿å­˜åˆ°æœ¬åœ°æ–‡ä»¶                                    â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  âœ“ ResourceUploader (Post-Handler)                   â”‚     â”‚
â”‚  â”‚    â†’ è§£æ responseSchema è¯†åˆ«èµ„æºå­—æ®µ                  â”‚     â”‚
â”‚  â”‚    â†’ ä¸Šä¼ æ–‡ä»¶ â†’ åˆ›å»ºæ•°æ®åº“è®°å½• â†’ ç”Ÿæˆ CDN URL          â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                              â†‘                                  â”‚
â”‚                          å¯é€‰ï¼šç»§æ‰¿æ‰©å±•                          â”‚
â”‚                              â†“                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Custom Handlers (å¤„ç†ç‰¹æ®Šåœºæ™¯)                        â”‚     â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚     â”‚
â”‚  â”‚  - FishAudioHandler extends BaseHttpHandler          â”‚     â”‚
â”‚  â”‚    â†’ è‡ªå®šä¹‰å‚æ•°éªŒè¯ã€é…é¢æ£€æŸ¥                          â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  - HeyGenHandler extends BaseHttpHandler             â”‚     â”‚
â”‚  â”‚    â†’ å¼‚æ­¥ä»»åŠ¡è½®è¯¢ã€å¤šèµ„æºå¤„ç†                          â”‚     â”‚
â”‚  â”‚                                                       â”‚     â”‚
â”‚  â”‚  - ReplicateHandler extends BaseHttpHandler          â”‚     â”‚
â”‚  â”‚    â†’ Webhook å›è°ƒã€é•¿æ—¶é—´ä»»åŠ¡                          â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒä¼˜åŠ¿

| ç‰¹æ€§ | è¯´æ˜ | å¥½å¤„ |
|------|------|------|
| **é…ç½®é©±åŠ¨** | å·¥å…·å®šä¹‰å­˜å‚¨åœ¨æ•°æ®åº“ï¼Œé€šè¿‡é…ç½®ç”Ÿæˆ | æ— éœ€ä¿®æ”¹ä»£ç å³å¯æ·»åŠ /ä¿®æ”¹å·¥å…· |
| **é›¶ç»§æ‰¿** | DynamicStructuredTool è¿è¡Œæ—¶åˆ›å»º | ç®€åŒ–å¼€å‘ï¼Œé™ä½å­¦ä¹ æˆæœ¬ |
| **çƒ­æ›´æ–°** | é…ç½®å˜æ›´è‡ªåŠ¨æ£€æµ‹å¹¶é‡è½½ | é›¶åœæœºéƒ¨ç½²ï¼Œå¿«é€Ÿè¿­ä»£ |
| **ç±»å‹å®‰å…¨** | Zod Schema è‡ªåŠ¨éªŒè¯ | é˜²æ­¢å‚æ•°é”™è¯¯ï¼Œæé«˜å¯é æ€§ |
| **èµ„æºè‡ªåŠ¨åŒ–** | Pre/Post-Handler è‡ªåŠ¨å¤„ç†æ–‡ä»¶ | ç»Ÿä¸€èµ„æºç®¡ç†ï¼Œé¿å…é‡å¤ä»£ç  |

---

## DynamicStructuredTool è¯¦è§£

### ä»€ä¹ˆæ˜¯ DynamicStructuredToolï¼Ÿ

`DynamicStructuredTool` æ˜¯ LangChain æä¾›çš„å·¥å…·ç±»ï¼Œç”¨äº**åŠ¨æ€åˆ›å»ºç»“æ„åŒ–å·¥å…·**ï¼š

- âœ… **è¿è¡Œæ—¶åˆ›å»º** - ä¸éœ€è¦å®šä¹‰æ–°ç±»
- âœ… **Zod Schema éªŒè¯** - è‡ªåŠ¨å‚æ•°éªŒè¯
- âœ… **ç±»å‹å®‰å…¨** - TypeScript ç±»å‹æ¨æ–­
- âœ… **çµæ´»çš„ func** - å¯ä»¥è°ƒç”¨ä»»ä½•å¼‚æ­¥å‡½æ•°

### åŸºæœ¬ç”¨æ³•

```typescript
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';

const tool = new DynamicStructuredTool({
  // å·¥å…·åç§°ï¼ˆå”¯ä¸€æ ‡è¯†ï¼‰
  name: 'text_to_speech',

  // å·¥å…·æè¿°ï¼ˆLLM ç”¨äºç†è§£å·¥å…·ç”¨é€”ï¼‰
  description: 'Convert text to speech using Fish Audio API',

  // Zod Schemaï¼ˆå®šä¹‰å‚æ•°ç»“æ„ï¼‰
  schema: z.object({
    text: z.string().describe('The text to convert to speech'),
    voice: z.string().optional().describe('Voice ID (optional)')
  }),

  // æ‰§è¡Œå‡½æ•°ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰
  func: async (args) => {
    // args å·²ç»é€šè¿‡ schema éªŒè¯
    // args.text: string
    // args.voice?: string

    // è¿™é‡Œè°ƒç”¨å®é™…çš„ API æˆ–æœåŠ¡
    const result = await callAPI(args);

    // è¿”å›å­—ç¬¦ä¸²ç»“æœï¼ˆLLM å¯ä»¥ç†è§£çš„æ ¼å¼ï¼‰
    return JSON.stringify(result);
  }
});
```

### ä¸ HttpHandler é›†æˆ

```typescript
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { ImprovedHttpHandler } from './handler/http';

// 1. åˆ›å»º ImprovedHttpHandler
const handler = new ImprovedHttpHandler({
  endpoint: 'https://api.fish.audio/v1/tts',
  credentials: { apiKey: process.env.FISH_AUDIO_API_KEY },
  responseSchema: {
    type: 'object',
    properties: {
      audio: {
        type: 'string',
        isResource: true,
        resourceType: 'audio'
      }
    }
  },
  resourceUploader: {
    uploadFile: async (localPath, metadata) => {
      // ä¸Šä¼ é€»è¾‘
      return { fileId, entityId, storageKey, url };
    }
  }
});

// 2. åˆ›å»º DynamicStructuredTool
const tool = new DynamicStructuredTool({
  name: 'fish_audio__text_to_speech',
  description: 'Convert text to speech using Fish Audio API. Returns audio file URL.',

  schema: z.object({
    text: z.string().describe('The text to convert to speech'),
    reference: z.object({
      entityId: z.string().describe('Reference audio file entity ID')
    }).optional().describe('Optional reference audio for voice cloning')
  }),

  // 3. func è°ƒç”¨ HttpHandler
  func: async (args) => {
    try {
      // è°ƒç”¨ HttpHandler
      const response = await handler.handle({
        provider: 'fish-audio',
        method: 'text_to_speech',
        params: args  // ç›´æ¥ä¼ é€’ Zod éªŒè¯åçš„å‚æ•°
      });

      // æ£€æŸ¥æˆåŠŸ
      if (!response.success) {
        return `Error: ${response.error || 'Unknown error'}`;
      }

      // æ ¼å¼åŒ–è¾“å‡ºï¼ˆLLM å¯ç†è§£çš„æ ¼å¼ï¼‰
      return `éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼
æ–‡ä»¶ID: ${response.entityId}
è®¿é—®é“¾æ¥: ${response.url}
æœ¬åœ°è·¯å¾„: ${response.localPath}`;

    } catch (error) {
      return `Error: ${error.message}`;
    }
  }
});

// 4. æ³¨å†Œåˆ° Agent
const tools = [tool];
const agent = createAgent({ tools, llm });
```

---

## HttpHandler ä½œä¸ºæ‰§è¡Œä»£ç†

### HttpHandler çš„å®šä½

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  LangChain å·¥å…·è°ƒç”¨æ ˆ                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                         â”‚
â”‚  Layer 1: Agent Executor (è°ƒåº¦å±‚)                       â”‚
â”‚  â”œâ”€ è§£æç”¨æˆ·æ„å›¾                                        â”‚
â”‚  â”œâ”€ é€‰æ‹©åˆé€‚çš„å·¥å…·                                      â”‚
â”‚  â””â”€ ç”Ÿæˆæœ€ç»ˆå›å¤                                        â”‚
â”‚                                                         â”‚
â”‚  Layer 2: DynamicStructuredTool (å·¥å…·å±‚)                â”‚
â”‚  â”œâ”€ å®šä¹‰å·¥å…·æ¥å£                                        â”‚
â”‚  â”œâ”€ å‚æ•°éªŒè¯ (Zod)                                     â”‚
â”‚  â””â”€ è°ƒç”¨æ‰§è¡Œå‡½æ•° (func)                                 â”‚
â”‚                                                         â”‚
â”‚  Layer 3: HttpHandler (æ‰§è¡Œå±‚) â­                       â”‚
â”‚  â”œâ”€ Pre-Handlers (èµ„æºå‡†å¤‡)                            â”‚
â”‚  â”œâ”€ API è°ƒç”¨ (HTTP Request)                            â”‚
â”‚  â”œâ”€ Response å¤„ç† (ä¿å­˜æ–‡ä»¶)                           â”‚
â”‚  â””â”€ Post-Handlers (èµ„æºä¸Šä¼ )                           â”‚
â”‚                                                         â”‚
â”‚  Layer 4: External API (ç¬¬ä¸‰æ–¹æœåŠ¡)                     â”‚
â”‚  â””â”€ Fish Audio / Replicate / OpenAI / etc.             â”‚
â”‚                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### HttpHandler çš„èŒè´£

| èŒè´£ | è¯´æ˜ | ä¸ºä»€ä¹ˆéœ€è¦ |
|------|------|-----------|
| **èµ„æºç®¡ç†** | Pre-Handler å¤„ç†è¾“å…¥èµ„æºå¼•ç”¨ | DynamicStructuredTool ä¸çŸ¥é“å¦‚ä½•å¤„ç† entityId |
| **API æŠ½è±¡** | ç»Ÿä¸€çš„ HTTP è°ƒç”¨æ¥å£ | ç®€åŒ–å·¥å…·å®šä¹‰ï¼Œé¿å…é‡å¤ä»£ç  |
| **å“åº”å¤„ç†** | è‡ªåŠ¨æ£€æµ‹å“åº”ç±»å‹å¹¶ä¿å­˜æ–‡ä»¶ | DynamicStructuredTool åªèƒ½è¿”å›å­—ç¬¦ä¸² |
| **èµ„æºä¸Šä¼ ** | Post-Handler è‡ªåŠ¨ä¸Šä¼ æ–‡ä»¶ | éœ€è¦å°†ç”Ÿæˆç»“æœæŒä¹…åŒ–åˆ°èµ„æºåº“ |
| **é”™è¯¯å¤„ç†** | ä¼˜é›…çš„é”™è¯¯å¤„ç†å’Œé™çº§ | æé«˜å·¥å…·çš„å¯é æ€§ |

### ä¸ºä»€ä¹ˆä¸èƒ½åªç”¨ DynamicStructuredToolï¼Ÿ

```typescript
// âŒ å¦‚æœåªç”¨ DynamicStructuredToolï¼Œä»£ç ä¼šéå¸¸å†—é•¿
const tool = new DynamicStructuredTool({
  name: 'fish_audio_tts',
  schema: z.object({
    text: z.string(),
    reference: z.object({ entityId: z.string() }).optional()
  }),
  func: async (args) => {
    // âŒ éœ€è¦æ‰‹åŠ¨å¤„ç†èµ„æºå¼•ç”¨
    let referenceFile;
    if (args.reference?.entityId) {
      const metadata = await prisma.staticFile.findFirst({
        where: { entityId: args.reference.entityId }
      });
      const buffer = await storage.download(metadata.storageKey);
      referenceFile = bufferToFile(buffer, 'reference.mp3');
    }

    // âŒ éœ€è¦æ‰‹åŠ¨è°ƒç”¨ API
    const formData = new FormData();
    formData.append('text', args.text);
    if (referenceFile) {
      formData.append('reference', referenceFile);
    }

    const response = await fetch('https://api.fish.audio/v1/tts', {
      method: 'POST',
      headers: { Authorization: `Bearer ${apiKey}` },
      body: formData
    });

    // âŒ éœ€è¦æ‰‹åŠ¨å¤„ç†å“åº”
    const arrayBuffer = await response.arrayBuffer();
    const localPath = `./output/audio_${Date.now()}.mp3`;
    await fs.writeFile(localPath, Buffer.from(arrayBuffer));

    // âŒ éœ€è¦æ‰‹åŠ¨ä¸Šä¼ æ–‡ä»¶
    const storageKey = `generated/fish-audio/${Date.now()}.mp3`;
    await storage.upload(Buffer.from(arrayBuffer), storageKey);

    const record = await prisma.staticFile.create({
      data: {
        entityId: `audio_${Date.now()}`,
        storageKey,
        type: 'audio'
      }
    });

    // âŒ éœ€è¦æ‰‹åŠ¨æ ¼å¼åŒ–è¾“å‡º
    return `éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼\nURL: https://cdn.example.com/${storageKey}`;
  }
});

// âœ… ä½¿ç”¨ HttpHandlerï¼Œä»£ç éå¸¸ç®€æ´
const tool = new DynamicStructuredTool({
  name: 'fish_audio_tts',
  schema: z.object({
    text: z.string(),
    reference: z.object({ entityId: z.string() }).optional()
  }),
  func: async (args) => {
    // âœ… HttpHandler è‡ªåŠ¨å¤„ç†æ‰€æœ‰å¤æ‚é€»è¾‘
    const response = await handler.handle({
      provider: 'fish-audio',
      method: 'text_to_speech',
      params: args
    });

    return `éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼\nURL: ${response.url}`;
  }
});
```

---

## å®Œæ•´é›†æˆå®ä¾‹

æœ¬èŠ‚æä¾›ä¸€ä¸ªä»é›¶å¼€å§‹çš„å®Œæ•´é›†æˆå®ä¾‹ï¼Œå±•ç¤ºå¦‚ä½•å°†é…ç½®é©±åŠ¨çš„å·¥å…·ç³»ç»Ÿä¸ LangChain é›†æˆã€‚

### å·¥å…·é…ç½®æŒä¹…åŒ– (Tool Inventory)

#### 1. æ•°æ®åº“è¡¨ç»“æ„

ä½¿ç”¨ç°æœ‰çš„ `toolsets` è¡¨å­˜å‚¨å·¥å…·é…ç½®ï¼š

```prisma
model Toolset {
  pk                   Int                   @id @default(autoincrement())
  toolsetId            String                @unique @map("toolset_id")
  isGlobal             Boolean               @default(false) @map("is_global")
  uid                  String?               @map("uid")
  name                 String                @map("name")
  key                  String                @map("key")
  authType             String?               @default("credentials") @map("auth_type")
  authData             String?               @map("auth_data")
  activeConfigVersion  Int?                  @default(1) @map("active_config_version")  // â­ å½“å‰æ¿€æ´»çš„é…ç½®ç‰ˆæœ¬
  enabled              Boolean               @default(true) @map("enabled")
  uninstalled          Boolean               @default(false) @map("uninstalled")
  createdAt            DateTime              @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt            DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  deletedAt            DateTime?             @map("deleted_at") @db.Timestamptz()

  // å…³è”é…ç½®ç‰ˆæœ¬å†å²
  configVersions       ToolsetConfigVersion[]

  @@index([uid, isGlobal, deletedAt])
  @@index([key, enabled])
  @@index([updatedAt])  // ç”¨äºçƒ­æ›´æ–°æ£€æµ‹
  @@map("toolsets")
}

model ToolsetConfigVersion {
  pk              Int       @id @default(autoincrement())
  toolsetId       String    @map("toolset_id")
  version         Int       @map("version")  // ç‰ˆæœ¬å·
  config          String    @map("config")   // â­ JSON é…ç½®å†…å®¹
  configHash      String?   @map("config_hash")  // é…ç½®å†…å®¹çš„ hashï¼Œç”¨äºå¿«é€Ÿå¯¹æ¯”
  description     String?   @map("description")  // ç‰ˆæœ¬æè¿°
  isActive        Boolean   @default(false) @map("is_active")  // æ˜¯å¦ä¸ºå½“å‰æ¿€æ´»ç‰ˆæœ¬
  createdBy       String?   @map("created_by")  // åˆ›å»ºè€… UID
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  deletedAt       DateTime? @map("deleted_at") @db.Timestamptz()

  // å…³è” Toolset
  toolset         Toolset   @relation(fields: [toolsetId], references: [toolsetId])

  @@unique([toolsetId, version])
  @@index([toolsetId, isActive, deletedAt])
  @@index([toolsetId, createdAt])
  @@index([configHash])  // ç”¨äºæŸ¥æ‰¾ç›¸åŒé…ç½®
  @@map("toolset_config_versions")
}


#### 2. é…ç½® JSON ç»“æ„

```typescript
interface ToolsetConfig {
  domain: string;  // ç”¨äº favicon æ˜¾ç¤º
  credentials?: {
    apiKey?: string;
    apiSecret?: string;
  };
  methods: ToolMethodConfig[];
}

interface ToolMethodConfig {
  name: string;
  description: string;
  endpoint: string;  // å®Œæ•´ URL
  schema: string;    // JSON å­—ç¬¦ä¸²
  responseSchema: string;  // JSON å­—ç¬¦ä¸²
}
```

#### 3. é…ç½®ç‰ˆæœ¬ç®¡ç†æœåŠ¡

```typescript
// toolset-config.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { createHash } from 'crypto';

@Injectable()
export class ToolsetConfigService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * åˆ›å»ºæ–°çš„é…ç½®ç‰ˆæœ¬
   */
  async createConfigVersion(params: {
    toolsetId: string;
    config: any;
    description?: string;
    createdBy?: string;
    setAsActive?: boolean;
  }) {
    const { toolsetId, config, description, createdBy, setAsActive = false } = params;

    // è®¡ç®—é…ç½®çš„ hash
    const configStr = JSON.stringify(config);
    const configHash = createHash('sha256').update(configStr).digest('hex');

    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç›¸åŒçš„é…ç½®
    const existingConfig = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, configHash, deletedAt: null },
    });

    if (existingConfig) {
      throw new Error(`Configuration already exists in version ${existingConfig.version}`);
    }

    // è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    const latestVersion = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, deletedAt: null },
      orderBy: { version: 'desc' },
    });
    const nextVersion = (latestVersion?.version ?? 0) + 1;

    // åœ¨äº‹åŠ¡ä¸­åˆ›å»ºæ–°ç‰ˆæœ¬
    return await this.prisma.$transaction(async (tx) => {
      // å¦‚æœè®¾ç½®ä¸ºæ¿€æ´»ï¼Œå…ˆå°†å…¶ä»–ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
      if (setAsActive) {
        await tx.toolsetConfigVersion.updateMany({
          where: { toolsetId, isActive: true },
          data: { isActive: false },
        });
      }

      // åˆ›å»ºæ–°ç‰ˆæœ¬
      const newVersion = await tx.toolsetConfigVersion.create({
        data: {
          toolsetId,
          version: nextVersion,
          config: configStr,
          configHash,
          description,
          createdBy,
          isActive: setAsActive,
        },
      });

      // å¦‚æœè®¾ç½®ä¸ºæ¿€æ´»ï¼Œæ›´æ–° Toolset çš„ activeConfigVersion
      if (setAsActive) {
        await tx.toolset.update({
          where: { toolsetId },
          data: { activeConfigVersion: nextVersion },
        });
      }

      return newVersion;
    });
  }

  /**
   * åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
   */
  async switchToVersion(toolsetId: string, version: number) {
    return await this.prisma.$transaction(async (tx) => {
      // éªŒè¯ç‰ˆæœ¬æ˜¯å¦å­˜åœ¨
      const targetVersion = await tx.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version } },
      });

      if (!targetVersion || targetVersion.deletedAt) {
        throw new Error(`Version ${version} not found for toolset ${toolsetId}`);
      }

      // å°†æ‰€æœ‰ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
      await tx.toolsetConfigVersion.updateMany({
        where: { toolsetId, isActive: true },
        data: { isActive: false },
      });

      // æ¿€æ´»ç›®æ ‡ç‰ˆæœ¬
      await tx.toolsetConfigVersion.update({
        where: { toolsetId_version: { toolsetId, version } },
        data: { isActive: true },
      });

      // æ›´æ–° Toolset çš„ activeConfigVersion
      await tx.toolset.update({
        where: { toolsetId },
        data: {
          activeConfigVersion: version,
          updatedAt: new Date(),  // è§¦å‘çƒ­æ›´æ–°
        },
      });

      return targetVersion;
    });
  }

  /**
   * è·å–å½“å‰æ¿€æ´»çš„é…ç½®
   */
  async getActiveConfig(toolsetId: string) {
    const activeVersion = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, isActive: true, deletedAt: null },
    });

    if (!activeVersion) {
      return null;
    }

    return {
      version: activeVersion.version,
      config: JSON.parse(activeVersion.config),
      description: activeVersion.description,
      createdAt: activeVersion.createdAt,
    };
  }

  /**
   * è·å–é…ç½®ç‰ˆæœ¬å†å²
   */
  async getVersionHistory(toolsetId: string) {
    const versions = await this.prisma.toolsetConfigVersion.findMany({
      where: { toolsetId, deletedAt: null },
      orderBy: { version: 'desc' },
    });

    return versions.map((v) => ({
      version: v.version,
      description: v.description,
      isActive: v.isActive,
      createdBy: v.createdBy,
      createdAt: v.createdAt,
    }));
  }

  /**
   * å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬çš„é…ç½®ï¼ˆåœ¨çº¿å¯¹æ¯”ï¼Œä¸å­˜å‚¨ï¼‰
   */
  async compareVersions(params: {
    toolsetId: string;
    fromVersion: number;
    toVersion: number;
  }) {
    const { toolsetId, fromVersion, toVersion } = params;

    // è·å–ä¸¤ä¸ªç‰ˆæœ¬çš„é…ç½®
    const [from, to] = await Promise.all([
      this.prisma.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version: fromVersion } },
      }),
      this.prisma.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version: toVersion } },
      }),
    ]);

    if (!from || !to) {
      throw new Error('Version not found');
    }

    // è®¡ç®—å·®å¼‚
    const fromConfig = JSON.parse(from.config);
    const toConfig = JSON.parse(to.config);
    const diffSummary = this.computeDiff(fromConfig, toConfig);

    return {
      fromVersion: {
        version: from.version,
        description: from.description,
        createdAt: from.createdAt,
        createdBy: from.createdBy,
      },
      toVersion: {
        version: to.version,
        description: to.description,
        createdAt: to.createdAt,
        createdBy: to.createdBy,
      },
      diff: diffSummary,
    };
  }

  /**
   * å›æ»šåˆ°ä¹‹å‰çš„ç‰ˆæœ¬
   */
  async rollback(toolsetId: string, targetVersion?: number) {
    // å¦‚æœæ²¡æœ‰æŒ‡å®šç‰ˆæœ¬ï¼Œå›æ»šåˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬
    if (!targetVersion) {
      const currentActive = await this.prisma.toolsetConfigVersion.findFirst({
        where: { toolsetId, isActive: true, deletedAt: null },
      });

      if (!currentActive) {
        throw new Error('No active version found');
      }

      const previousVersion = await this.prisma.toolsetConfigVersion.findFirst({
        where: {
          toolsetId,
          version: { lt: currentActive.version },
          deletedAt: null,
        },
        orderBy: { version: 'desc' },
      });

      if (!previousVersion) {
        throw new Error('No previous version to rollback to');
      }

      targetVersion = previousVersion.version;
    }

    return await this.switchToVersion(toolsetId, targetVersion);
  }

  /**
   * è®¡ç®—é…ç½®å·®å¼‚
   */
  private computeDiff(from: any, to: any): any {
    const changes: any = {
      added: {},
      removed: {},
      modified: {},
    };

    // ç®€åŒ–çš„å·®å¼‚è®¡ç®—ï¼ˆå®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨ deep-diff ç­‰åº“ï¼‰
    const allKeys = new Set([...Object.keys(from), ...Object.keys(to)]);

    for (const key of allKeys) {
      if (!(key in from)) {
        changes.added[key] = to[key];
      } else if (!(key in to)) {
        changes.removed[key] = from[key];
      } else if (JSON.stringify(from[key]) !== JSON.stringify(to[key])) {
        changes.modified[key] = { from: from[key], to: to[key] };
      }
    }

    return changes;
  }
}
```

#### 4. åˆå§‹åŒ–å·¥å…·é…ç½®ï¼ˆä½¿ç”¨ç‰ˆæœ¬ç®¡ç†ï¼‰

```typescript
// tool.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { ToolsetConfigService } from './toolset-config.service';

@Injectable()
export class ToolService {
  constructor(
    private readonly prisma: PrismaService,
    private readonly configService: ToolsetConfigService,
  ) {}

  /**
   * åˆå§‹åŒ– Fish Audio å·¥å…·é…ç½®
   */
  async initializeFishAudioToolset(uid?: string) {
    const config: ToolsetConfig = {
      domain: 'fish.audio',
      credentials: {
        apiKey: '${FISH_AUDIO_API_KEY}'  // ç¯å¢ƒå˜é‡å ä½ç¬¦
      },
      methods: [
        {
          name: 'text_to_speech',
          description: 'Convert text to speech using Fish Audio API.',
          endpoint: 'https://api.fish.audio/v1/tts',
          schema: JSON.stringify({
            type: 'object',
            properties: {
              text: { type: 'string', description: 'Text to convert' },
            },
            required: ['text']
          }),
          responseSchema: JSON.stringify({
            type: 'object',
            properties: {
              audio: { type: 'string', isResource: true, resourceType: 'audio' }
            }
          })
        }
      ]
    };

    // åˆ›å»ºæˆ–æ›´æ–° Toolset
    const toolset = await this.prisma.toolset.upsert({
      where: { key: 'fish-audio' },
      create: {
        toolsetId: 'global-fish-audio',
        key: 'fish-audio',
        name: 'Fish Audio',
        isGlobal: true,
        authType: 'credentials',
        enabled: true,
      },
      update: {
        name: 'Fish Audio',
      },
    });

    // åˆ›å»ºåˆå§‹é…ç½®ç‰ˆæœ¬
    await this.configService.createConfigVersion({
      toolsetId: toolset.toolsetId,
      config,
      description: 'Initial configuration for Fish Audio TTS',
      createdBy: uid,
      setAsActive: true,
    });

    return toolset;
  }

  /**
   * æ›´æ–°å·¥å…·é…ç½®ï¼ˆåˆ›å»ºæ–°ç‰ˆæœ¬ï¼‰
   */
  async updateToolsetConfig(params: {
    toolsetId: string;
    config: any;
    description?: string;
    uid?: string;
    setAsActive?: boolean;
  }) {
    return await this.configService.createConfigVersion(params);
  }

  /**
   * è·å–å·¥å…·é…ç½®åˆ—è¡¨
   */
  async listToolsetInventory() {
    const toolsets = await this.prisma.toolset.findMany({
      where: {
        isGlobal: true,
        enabled: true,
        deletedAt: null,
      },
      include: {
        configVersions: {
          where: { isActive: true, deletedAt: null },
          take: 1,
        },
      },
    });

    return toolsets.map((toolset) => {
      const activeConfig = toolset.configVersions[0];
      const config = activeConfig ? JSON.parse(activeConfig.config) : null;

      return {
        key: toolset.key,
        name: toolset.name,
        domain: config?.domain,
        activeVersion: toolset.activeConfigVersion,
        methodCount: config?.methods?.length ?? 0,
        methods: config?.methods?.map((m: any) => m.name) ?? [],
        updatedAt: toolset.updatedAt,
      };
    });
  }
}
```

---

### çƒ­æ›´æ–°æœºåˆ¶

#### 1. é…ç½®ç›‘å¬å™¨

```typescript
// tool-config-watcher.service.ts
import { Injectable, OnModuleInit } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { PrismaService } from '../prisma/prisma.service';
import * as crypto from 'crypto';

@Injectable()
export class ToolConfigWatcher implements OnModuleInit {
  private readonly CHECK_INTERVAL = 30000;  // 30 ç§’
  private intervalId: NodeJS.Timeout;

  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
    private readonly redis: RedisService
  ) {}

  async onModuleInit() {
    // å¯åŠ¨å®šæœŸæ£€æŸ¥
    this.startWatching();
  }

  private startWatching() {
    this.intervalId = setInterval(async () => {
      await this.checkConfigChanges();
    }, this.CHECK_INTERVAL);

    console.log(`[ToolConfigWatcher] Started (interval: ${this.CHECK_INTERVAL}ms)`);
  }

  /**
   * æ£€æŸ¥é…ç½®å˜åŒ–
   */
  private async checkConfigChanges() {
    try {
      const toolsets = await this.prisma.toolset.findMany({
        where: {
          enabled: true,
          deletedAt: null
        },
        select: {
          key: true,
          config: true,
          updatedAt: true
        }
      });

      for (const toolset of toolsets) {
        await this.checkToolsetChange(toolset);
      }
    } catch (error) {
      console.error('[ToolConfigWatcher] Error checking config changes:', error);
    }
  }

  /**
   * æ£€æŸ¥å•ä¸ªå·¥å…·é›†çš„å˜åŒ–
   */
  private async checkToolsetChange(toolset: { key: string; config: string; updatedAt: Date }) {
    // è®¡ç®—å½“å‰é…ç½®çš„ MD5
    const currentMd5 = crypto
      .createHash('md5')
      .update(toolset.config || '')
      .digest('hex');

    // ä» Redis è·å–ç¼“å­˜çš„ MD5
    const cachedMd5 = await this.redis.get(`toolset:md5:${toolset.key}`);

    if (currentMd5 !== cachedMd5) {
      console.log(`[ToolConfigWatcher] Config changed for toolset: ${toolset.key}`);

      // æ›´æ–° Redis
      await this.redis.set(`toolset:md5:${toolset.key}`, currentMd5, 'EX', 86400);

      // è§¦å‘é…ç½®å˜æ›´äº‹ä»¶
      this.eventEmitter.emit('tool.config.changed', {
        toolsetKey: toolset.key,
        md5: currentMd5,
        config: JSON.parse(toolset.config || '{}'),
        timestamp: new Date()
      });
    }
  }

  onModuleDestroy() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
    }
  }
}
```

#### 2. å·¥å…·ç¼“å­˜ç®¡ç†

```typescript
// tool-registry-cache.service.ts
import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { DynamicStructuredTool } from '@langchain/core/tools';

@Injectable()
export class ToolRegistryCache {
  private toolCache = new Map<string, DynamicStructuredTool[]>();
  private loadingPromises = new Map<string, Promise<DynamicStructuredTool[]>>();

  /**
   * è·å–å·¥å…·ï¼ˆå¸¦ SingleFlight æ¨¡å¼ï¼‰
   */
  async getTools(toolsetKey: string, user: User): Promise<DynamicStructuredTool[]> {
    // æ£€æŸ¥ç¼“å­˜
    if (this.toolCache.has(toolsetKey)) {
      return this.toolCache.get(toolsetKey)!;
    }

    // æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½ï¼ˆSingleFlightï¼‰
    if (this.loadingPromises.has(toolsetKey)) {
      console.log(`[ToolRegistryCache] Waiting for ongoing load: ${toolsetKey}`);
      return await this.loadingPromises.get(toolsetKey)!;
    }

    // å¼€å§‹åŠ è½½
    const promise = this.loadTools(toolsetKey, user);
    this.loadingPromises.set(toolsetKey, promise);

    try {
      const tools = await promise;
      this.toolCache.set(toolsetKey, tools);
      return tools;
    } finally {
      this.loadingPromises.delete(toolsetKey);
    }
  }

  /**
   * åŠ è½½å·¥å…·
   */
  private async loadTools(toolsetKey: string, user: User): Promise<DynamicStructuredTool[]> {
    console.log(`[ToolRegistryCache] Loading tools for: ${toolsetKey}`);

    // ä»æ•°æ®åº“åŠ è½½é…ç½®
    const toolset = await this.prisma.toolset.findFirst({
      where: {
        key: toolsetKey,
        enabled: true,
        deletedAt: null
      }
    });

    if (!toolset?.config) {
      return [];
    }

    const config = JSON.parse(toolset.config) as ToolsetConfig;

    // åˆ›å»º DynamicToolRegistry
    const registry = new DynamicToolRegistry(
      config,
      this.prismaService,
      this.miscService,
      user
    );

    // æ³¨å†Œæ‰€æœ‰å·¥å…·
    const tools = registry.registerTools();

    console.log(`[ToolRegistryCache] Loaded ${tools.length} tools for ${toolsetKey}`);
    return tools;
  }

  /**
   * ç›‘å¬é…ç½®å˜æ›´äº‹ä»¶
   */
  @OnEvent('tool.config.changed')
  async handleConfigChanged(event: { toolsetKey: string; md5: string }) {
    console.log(`[ToolRegistryCache] Reloading tools for: ${event.toolsetKey}`);

    // æ¸…é™¤ç¼“å­˜
    this.toolCache.delete(event.toolsetKey);

    // é¢„åŠ è½½ï¼ˆå¯é€‰ï¼‰
    // await this.getTools(event.toolsetKey, systemUser);
  }

  /**
   * å¼ºåˆ¶é‡æ–°åŠ è½½
   */
  async forceReload(toolsetKey: string, user: User) {
    console.log(`[ToolRegistryCache] Force reloading: ${toolsetKey}`);
    this.toolCache.delete(toolsetKey);
    return await this.getTools(toolsetKey, user);
  }
}
```

---

### Handler æ”¹é€ 

#### 1. åˆ›å»ºé…ç½®é©±åŠ¨çš„ HttpHandler å·¥å‚

```typescript
// http-handler-factory.ts
import { HttpHandler } from './http-handler';

export class HttpHandlerFactory {
  constructor(
    private readonly prismaService: any,
    private readonly miscService: any,
    private readonly user: User
  ) {}

  /**
   * æ ¹æ®é…ç½®åˆ›å»º HttpHandler
   */
  createHandler(methodConfig: ToolMethodConfig, credentials: any): HttpHandler {
    // è§£æ schemas
    const schema = JSON.parse(methodConfig.schema);
    const responseSchema = JSON.parse(methodConfig.responseSchema);

    return new HttpHandler({
      endpoint: methodConfig.endpoint,
      credentials: this.resolveCredentials(credentials),

      // è¾“å…¥èµ„æºé…ç½®
      resourceFields: this.extractResourceFields(schema),
      resourceResolver: {
        resolveFile: async (storageKey, visibility) => {
          return await this.miscService.downloadFile({ storageKey, visibility });
        },
        getFileMetadata: async (entityId) => {
          return await this.prismaService.staticFile.findFirst({
            where: { entityId, deletedAt: null }
          });
        }
      },

      // è¾“å‡ºèµ„æºé…ç½®
      responseSchema,
      resourceUploader: {
        uploadFile: async (localPath, metadata) => {
          const buffer = await fs.readFile(localPath);
          const extension = path.extname(localPath);
          const storageKey = `generated/${metadata.provider}/${metadata.method}/${Date.now()}${extension}`;

          // ä¸Šä¼ åˆ°å­˜å‚¨
          await this.miscService.uploadFile({ buffer, storageKey });

          // åˆ›å»ºæ•°æ®åº“è®°å½•
          const record = await this.prismaService.staticFile.create({
            data: {
              entityId: `${metadata.type}_${Date.now()}`,
              storageKey,
              type: metadata.type,
              mimeType: metadata.mimeType,
              visibility: 'public',
              size: buffer.length,
              userId: this.user.id
            }
          });

          return {
            fileId: record.id,
            entityId: record.entityId,
            storageKey: record.storageKey,
            url: `https://${process.env.CDN_DOMAIN}/${storageKey}`
          };
        }
      }
    });
  }

  /**
   * è§£æå‡­è¯ï¼ˆæ”¯æŒç¯å¢ƒå˜é‡å ä½ç¬¦ï¼‰
   */
  private resolveCredentials(credentials: any): any {
    const resolved = { ...credentials };

    for (const [key, value] of Object.entries(resolved)) {
      if (typeof value === 'string' && value.startsWith('${') && value.endsWith('}')) {
        const envVar = value.slice(2, -1);
        resolved[key] = process.env[envVar];
      }
    }

    return resolved;
  }

  /**
   * æå–èµ„æºå­—æ®µ
   */
  private extractResourceFields(schema: any): Array<{
    fieldPath: string;
    type: 'audio' | 'video' | 'image' | 'document';
    isArray: boolean;
  }> {
    const resourceFields: Array<{
      fieldPath: string;
      type: 'audio' | 'video' | 'image' | 'document';
      isArray: boolean;
    }> = [];

    const traverse = (schema: any, path = '', parentIsArray = false): void => {
      if (schema.isResource && schema.resourceType) {
        resourceFields.push({
          fieldPath: path,
          type: schema.resourceType,
          isArray: parentIsArray
        });
      }

      if (schema.type === 'object' && schema.properties) {
        for (const [key, subSchema] of Object.entries(schema.properties)) {
          const subPath = path ? `${path}.${key}` : key;
          traverse(subSchema, subPath, false);
        }
      }

      if (schema.type === 'array' && schema.items) {
        if (schema.items.isResource && schema.items.resourceType) {
          resourceFields.push({
            fieldPath: path,
            type: schema.items.resourceType,
            isArray: true
          });
        } else {
          traverse(schema.items, path, true);
        }
      }
    };

    if (schema.properties) {
      for (const [fieldName, fieldSchema] of Object.entries(schema.properties)) {
        traverse(fieldSchema, fieldName);
      }
    }

    return resourceFields;
  }
}
```

---

### LangChain é›†æˆ

#### 1. åŠ¨æ€å·¥å…·æ³¨å†Œå™¨

```typescript
// dynamic-tool-registry.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z, ZodSchema } from 'zod';

export class DynamicToolRegistry {
  private handlerFactory: HttpHandlerFactory;

  constructor(
    private readonly config: ToolsetConfig,
    prismaService: any,
    miscService: any,
    user: User
  ) {
    this.handlerFactory = new HttpHandlerFactory(prismaService, miscService, user);
  }

  /**
   * æ³¨å†Œæ‰€æœ‰å·¥å…·
   */
  registerTools(): DynamicStructuredTool[] {
    return this.config.methods.map(methodConfig =>
      this.createTool(methodConfig)
    );
  }

  /**
   * åˆ›å»ºå•ä¸ª DynamicStructuredTool
   */
  private createTool(methodConfig: ToolMethodConfig): DynamicStructuredTool {
    // åˆ›å»º HttpHandler
    const handler = this.handlerFactory.createHandler(
      methodConfig,
      this.config.credentials
    );

    // æ„å»º Zod Schema
    const zodSchema = this.buildZodSchema(JSON.parse(methodConfig.schema));

    // åˆ›å»º DynamicStructuredTool
    return new DynamicStructuredTool({
      name: `${this.config.domain.replace('.', '_')}__${methodConfig.name}`,
      description: methodConfig.description,
      schema: zodSchema,

      func: async (args) => {
        try {
          const response = await handler.handle({
            provider: this.config.domain,
            method: methodConfig.name,
            params: args
          });

          if (!response.success) {
            return `âŒ Error: ${response.error || 'Unknown error'}`;
          }

          return this.formatResponse(response, methodConfig);
        } catch (error) {
          console.error(`[DynamicTool] Error in ${methodConfig.name}:`, error);
          return `âŒ Error: ${error.message}`;
        }
      }
    });
  }

  /**
   * æ„å»º Zod Schema
   */
  private buildZodSchema(schemaConfig: any): ZodSchema {
    if (schemaConfig.type === 'object') {
      const fields: Record<string, any> = {};

      for (const [fieldName, fieldConfig] of Object.entries(schemaConfig.properties || {})) {
        fields[fieldName] = this.buildZodField(fieldConfig as any);
      }

      let zodObject = z.object(fields);

      // å¤„ç† required å­—æ®µ
      if (schemaConfig.required) {
        for (const fieldName of Object.keys(fields)) {
          if (!schemaConfig.required.includes(fieldName)) {
            fields[fieldName] = fields[fieldName].optional();
          }
        }
        zodObject = z.object(fields);
      }

      return zodObject;
    }

    return z.any();
  }

  /**
   * æ„å»º Zod å­—æ®µ
   */
  private buildZodField(fieldConfig: any): any {
    let zodField;

    switch (fieldConfig.type) {
      case 'string':
        zodField = z.string();
        if (fieldConfig.minLength) zodField = zodField.min(fieldConfig.minLength);
        if (fieldConfig.maxLength) zodField = zodField.max(fieldConfig.maxLength);
        if (fieldConfig.enum) zodField = z.enum(fieldConfig.enum);
        break;

      case 'number':
        zodField = z.number();
        if (fieldConfig.min !== undefined) zodField = zodField.min(fieldConfig.min);
        if (fieldConfig.max !== undefined) zodField = zodField.max(fieldConfig.max);
        break;

      case 'boolean':
        zodField = z.boolean();
        break;

      case 'object':
        zodField = this.buildZodSchema(fieldConfig);
        break;

      case 'array':
        const itemSchema = fieldConfig.items ? this.buildZodField(fieldConfig.items) : z.any();
        zodField = z.array(itemSchema);
        break;

      default:
        zodField = z.any();
    }

    if (fieldConfig.description) {
      zodField = zodField.describe(fieldConfig.description);
    }

    if (fieldConfig.optional) {
      zodField = zodField.optional();
    }

    if (fieldConfig.default !== undefined) {
      zodField = zodField.default(fieldConfig.default);
    }

    return zodField;
  }

  /**
   * æ ¼å¼åŒ–å“åº”
   */
  private formatResponse(response: any, methodConfig: ToolMethodConfig): string {
    // è§£æ responseSchema
    const responseSchema = JSON.parse(methodConfig.responseSchema);
    const resourceFields = this.handlerFactory['extractResourceFields'](responseSchema);

    if (resourceFields.length === 0) {
      // æ— èµ„æºå­—æ®µï¼Œè¿”å›çº¯æ•°æ®
      return JSON.stringify(response.data, null, 2);
    }

    // å•ä¸ªèµ„æº
    if (resourceFields.length === 1 && !resourceFields[0].isArray) {
      return `âœ… ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - å­˜å‚¨è·¯å¾„: ${response.storageKey}

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}

ğŸ’¾ æœ¬åœ°è·¯å¾„:
  ${response.localPath}`;
    }

    // å¤šä¸ªèµ„æº
    const uploadResults = response.uploadResults || [];
    return `âœ… æ‰¹é‡ç”ŸæˆæˆåŠŸï¼å…± ${uploadResults.length} ä¸ªæ–‡ä»¶

${uploadResults.map((r, i) => `${i + 1}. ${r.entityId}: ${r.url}`).join('\n')}`;
  }
}
```

---

### å“åº”æ ¼å¼åŒ–å¤„ç†

#### 1. å“åº”æ ¼å¼åŒ–å™¨

```typescript
// response-formatter.ts
export class ResponseFormatter {
  /**
   * æ ¼å¼åŒ–å·¥å…·å“åº”ï¼ˆæ ¹æ®èµ„æºç±»å‹ï¼‰
   */
  static formatToolResponse(response: any, resourceType?: string): string {
    if (!response.success) {
      return this.formatError(response.error);
    }

    if (!resourceType) {
      return this.formatGeneric(response);
    }

    switch (resourceType) {
      case 'audio':
        return this.formatAudio(response);
      case 'video':
        return this.formatVideo(response);
      case 'image':
        return this.formatImage(response);
      case 'document':
        return this.formatDocument(response);
      default:
        return this.formatGeneric(response);
    }
  }

  private static formatError(error: string): string {
    return `âŒ ç”Ÿæˆå¤±è´¥

é”™è¯¯ä¿¡æ¯: ${error}

è¯·æ£€æŸ¥è¾“å…¥å‚æ•°æˆ–ç¨åé‡è¯•ã€‚`;
  }

  private static formatAudio(response: any): string {
    return `ğŸµ éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - æ ¼å¼: ${response.data?.format || 'mp3'}
  - æ—¶é•¿: ${response.data?.duration || 'N/A'}ç§’
  - é‡‡æ ·ç‡: ${response.data?.sampleRate || 'N/A'}Hz

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}

ğŸ’¾ æœ¬åœ°è·¯å¾„:
  ${response.localPath}`;
  }

  private static formatVideo(response: any): string {
    return `ğŸ¬ è§†é¢‘ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - åˆ†è¾¨ç‡: ${response.data?.resolution || 'N/A'}
  - æ—¶é•¿: ${response.data?.duration || 'N/A'}ç§’
  - å¤§å°: ${this.formatFileSize(response.data?.size)}

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}

${response.data?.thumbnail_url ? `ğŸ–¼ï¸ ç¼©ç•¥å›¾:\n  ${response.data.thumbnail_url}` : ''}`;
  }

  private static formatImage(response: any): string {
    if (response.uploadResults) {
      return this.formatMultipleImages(response.uploadResults);
    }

    return `ğŸ–¼ï¸ å›¾ç‰‡ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - åˆ†è¾¨ç‡: ${response.data?.width}x${response.data?.height}
  - æ ¼å¼: ${response.data?.format || 'png'}

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}`;
  }

  private static formatMultipleImages(results: any[]): string {
    return `ğŸ–¼ï¸ æ‰¹é‡ç”ŸæˆæˆåŠŸï¼å…± ${results.length} å¼ å›¾ç‰‡

${results.map((r, i) => `${i + 1}. ${r.url}`).join('\n')}`;
  }

  private static formatDocument(response: any): string {
    return `ğŸ“„ æ–‡æ¡£ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - æ ¼å¼: ${response.data?.format || 'pdf'}
  - é¡µæ•°: ${response.data?.pageCount || 'N/A'}

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}`;
  }

  private static formatGeneric(response: any): string {
    return `âœ… æ“ä½œæˆåŠŸï¼

${JSON.stringify(response.data, null, 2)}`;
  }

  private static formatFileSize(bytes: number): string {
    if (!bytes) return 'N/A';
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(2)} KB`;
    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(2)} GB`;
  }
}
```

---

### è®¡è´¹å¤„ç†

å·¥å…·è°ƒç”¨éœ€è¦æ ¹æ®é…ç½®è¿›è¡Œè®¡è´¹ã€‚ç›®å‰æ”¯æŒä¸¤ç§è®¡è´¹æ¨¡å¼ï¼š**æŒ‰æ¬¡è®¡è´¹**å’Œ**æŒ‰é‡è®¡è´¹**ã€‚

#### 1. è®¡è´¹é…ç½®å®šä¹‰

```typescript
// billing-config.ts
export enum BillingType {
  PER_CALL = 'per_call',      // æŒ‰æ¬¡è®¡è´¹
  PER_QUANTITY = 'per_quantity' // æŒ‰é‡è®¡è´¹
}

export interface BillingConfig {
  enabled: boolean;           // æ˜¯å¦å¯ç”¨è®¡è´¹
  type: BillingType;         // è®¡è´¹ç±»å‹
  creditsPerCall?: number;   // æŒ‰æ¬¡è®¡è´¹ï¼šæ¯æ¬¡è°ƒç”¨æ¶ˆè€—çš„ç§¯åˆ†
  creditsPerUnit?: number;   // æŒ‰é‡è®¡è´¹ï¼šæ¯å•ä½æ¶ˆè€—çš„ç§¯åˆ†
  quantityField?: string;    // æŒ‰é‡è®¡è´¹ï¼šç”¨äºè®¡é‡çš„å­—æ®µå
  maxCredits?: number;       // å•æ¬¡è°ƒç”¨æœ€å¤§ç§¯åˆ†é™åˆ¶
}

// å·¥å…·å®šä¹‰ä¸­çš„è®¡è´¹é…ç½®
export interface ToolMethodDefinition {
  name: string;
  displayName: string;
  description: string;
  parameters: ParameterDefinition[];
  billing?: BillingConfig;   // â­ è®¡è´¹é…ç½®
}
```

#### 2. ç¤ºä¾‹ï¼šFish Audio TTS è®¡è´¹é…ç½®

```typescript
// fish-audio-definition.ts
export const fishAudioDefinition: ToolDefinition = {
  key: 'fish-audio',
  name: 'Fish Audio',
  methods: [
    {
      name: 'text_to_speech',
      displayName: 'æ–‡å­—è½¬è¯­éŸ³',
      description: 'å°†æ–‡æœ¬è½¬æ¢ä¸ºè‡ªç„¶æµç•…çš„è¯­éŸ³',
      parameters: [
        {
          name: 'text',
          type: 'string',
          required: true,
          description: 'è¦è½¬æ¢çš„æ–‡æœ¬å†…å®¹'
        },
        {
          name: 'reference',
          type: 'file',
          accepts: ['audio/*'],
          required: false,
          description: 'å‚è€ƒéŸ³é¢‘æ–‡ä»¶'
        }
      ],
      billing: {
        enabled: true,
        type: BillingType.PER_QUANTITY,  // æŒ‰é‡è®¡è´¹
        creditsPerUnit: 10,               // æ¯ 1000 å­—ç¬¦æ¶ˆè€— 10 ç§¯åˆ†
        quantityField: 'text',            // æ ¹æ® text å­—æ®µé•¿åº¦è®¡è´¹
        maxCredits: 1000                  // å•æ¬¡æœ€å¤šæ¶ˆè€— 1000 ç§¯åˆ†
      }
    }
  ]
};
```

#### 3. ç¤ºä¾‹ï¼šHeyGen è§†é¢‘ç”Ÿæˆè®¡è´¹é…ç½®

```typescript
// heygen-definition.ts
export const heygenDefinition: ToolDefinition = {
  key: 'heygen',
  name: 'HeyGen',
  methods: [
    {
      name: 'generate_video',
      displayName: 'ç”Ÿæˆè§†é¢‘',
      description: 'æ ¹æ®æ–‡æœ¬å’Œå½¢è±¡ç”Ÿæˆ AI è§†é¢‘',
      parameters: [
        {
          name: 'script',
          type: 'string',
          required: true,
          description: 'è§†é¢‘è„šæœ¬'
        },
        {
          name: 'avatar_id',
          type: 'string',
          required: true,
          description: 'è™šæ‹Ÿå½¢è±¡ ID'
        }
      ],
      billing: {
        enabled: true,
        type: BillingType.PER_CALL,      // æŒ‰æ¬¡è®¡è´¹
        creditsPerCall: 500,              // æ¯æ¬¡è°ƒç”¨æ¶ˆè€— 500 ç§¯åˆ†
        maxCredits: 500
      }
    }
  ]
};
```

#### 4. è®¡è´¹æœåŠ¡å®ç°

```typescript
// billing.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import type { BillingConfig } from './billing-config';

@Injectable()
export class BillingService {
  constructor(private prisma: PrismaService) {}

  /**
   * è®¡ç®—æœ¬æ¬¡è°ƒç”¨æ‰€éœ€ç§¯åˆ†
   */
  calculateCredits(
    config: BillingConfig,
    input: Record<string, any>
  ): number {
    if (!config.enabled) {
      return 0;
    }

    let credits = 0;

    switch (config.type) {
      case BillingType.PER_CALL:
        // æŒ‰æ¬¡è®¡è´¹ï¼šå›ºå®šç§¯åˆ†
        credits = config.creditsPerCall || 0;
        break;

      case BillingType.PER_QUANTITY:
        // æŒ‰é‡è®¡è´¹ï¼šæ ¹æ®å­—æ®µå€¼è®¡ç®—
        if (!config.quantityField || !config.creditsPerUnit) {
          throw new Error('æŒ‰é‡è®¡è´¹éœ€è¦é…ç½® quantityField å’Œ creditsPerUnit');
        }

        const value = input[config.quantityField];
        if (typeof value === 'string') {
          // æ–‡æœ¬ç±»ï¼šæŒ‰å­—ç¬¦æ•°è®¡è´¹ï¼ˆæ¯ 1000 å­—ç¬¦ä¸ºä¸€ä¸ªå•ä½ï¼‰
          const units = Math.ceil(value.length / 1000);
          credits = units * config.creditsPerUnit;
        } else if (typeof value === 'number') {
          // æ•°å€¼ç±»ï¼šç›´æ¥æŒ‰æ•°å€¼è®¡è´¹
          credits = value * config.creditsPerUnit;
        }
        break;

      default:
        throw new Error(`ä¸æ”¯æŒçš„è®¡è´¹ç±»å‹: ${config.type}`);
    }

    // åº”ç”¨æœ€å¤§ç§¯åˆ†é™åˆ¶
    if (config.maxCredits && credits > config.maxCredits) {
      credits = config.maxCredits;
    }

    return Math.ceil(credits);
  }

  /**
   * æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
   */
  async checkCredits(userId: string, requiredCredits: number): Promise<boolean> {
    const user = await this.prisma.user.findUnique({
      where: { uid: userId },
      select: { credits: true }
    });

    return (user?.credits || 0) >= requiredCredits;
  }

  /**
   * æ‰£é™¤ç”¨æˆ·ç§¯åˆ†
   */
  async deductCredits(userId: string, credits: number, metadata: {
    toolsetKey: string;
    methodName: string;
    actionStepPk?: number;
  }): Promise<void> {
    await this.prisma.$transaction(async (tx) => {
      // 1. æ‰£é™¤ç§¯åˆ†
      await tx.user.update({
        where: { uid: userId },
        data: {
          credits: {
            decrement: credits
          }
        }
      });

      // 2. è®°å½•ç§¯åˆ†æ¶ˆè´¹æ—¥å¿—
      await tx.creditLog.create({
        data: {
          uid: userId,
          amount: -credits,
          type: 'tool_usage',
          metadata: {
            toolsetKey: metadata.toolsetKey,
            methodName: metadata.methodName,
            actionStepPk: metadata.actionStepPk
          }
        }
      });
    });
  }
}
```

#### 5. åœ¨ DynamicStructuredTool ä¸­é›†æˆè®¡è´¹

```typescript
// langchain-integration.service.ts
async instantiateTool(
  user: User,
  configId: string,
  engine: SkillEngine
): Promise<DynamicStructuredTool | null> {
  const { config, authData, definition, methodDef } =
    await this.getConfigForExecution(user, configId);

  const billingConfig = methodDef.billing;

  return new DynamicStructuredTool({
    name: `${definition.key}_${methodDef.name}`,
    description: methodDef.description,
    schema: this.generateSchema(methodDef.parameters),
    func: async (input: Record<string, any>, runConfig) => {
      // â­ 1. è®¡ç®—æ‰€éœ€ç§¯åˆ†
      let requiredCredits = 0;
      if (billingConfig?.enabled) {
        requiredCredits = this.billingService.calculateCredits(
          billingConfig,
          input
        );
      }

      // â­ 2. æ£€æŸ¥ç§¯åˆ†æ˜¯å¦è¶³å¤Ÿ
      if (requiredCredits > 0) {
        const hasEnough = await this.billingService.checkCredits(
          user.uid,
          requiredCredits
        );

        if (!hasEnough) {
          throw new Error(
            `ç§¯åˆ†ä¸è¶³ï¼Œéœ€è¦ ${requiredCredits} ç§¯åˆ†ï¼Œ` +
            `è¯·å‰å¾€å……å€¼é¡µé¢è´­ä¹°ç§¯åˆ†`
          );
        }
      }

      try {
        // â­ 3. æ‰§è¡Œå·¥å…·è°ƒç”¨
        const executor = new registryEntry.implementation({
          ...config,
          ...authData,
          user,
          engine
        });

        const result = await executor.execute(input);

        // â­ 4. æ‰§è¡ŒæˆåŠŸåæ‰£é™¤ç§¯åˆ†
        if (requiredCredits > 0) {
          await this.billingService.deductCredits(
            user.uid,
            requiredCredits,
            {
              toolsetKey: definition.key,
              methodName: methodDef.name,
              actionStepPk: runConfig?.configurable?.actionStepPk
            }
          );
        }

        return result;
      } catch (error) {
        // â­ 5. æ‰§è¡Œå¤±è´¥ä¸æ‰£ç§¯åˆ†
        throw error;
      }
    },
    metadata: {
      type: 'configurable',
      toolsetKey: definition.key,
      methodName: methodDef.name,
      billing: billingConfig
    }
  });
}
```

#### 6. è®¡è´¹æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å·¥å…·è°ƒç”¨è®¡è´¹æµç¨‹                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  ç”¨æˆ·è°ƒç”¨å·¥å…·                                                â”‚
â”‚       â†“                                                     â”‚
â”‚  æ£€æŸ¥è®¡è´¹é…ç½® (billing.enabled?)                             â”‚
â”‚       â†“                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚ æŒ‰æ¬¡è®¡è´¹      â”‚      â”‚ æŒ‰é‡è®¡è´¹      â”‚                    â”‚
â”‚  â”‚ PER_CALL     â”‚      â”‚ PER_QUANTITY â”‚                    â”‚
â”‚  â”‚              â”‚      â”‚              â”‚                    â”‚
â”‚  â”‚ credits =    â”‚      â”‚ â€¢ è·å–é‡åŒ–å­—æ®µ â”‚                    â”‚
â”‚  â”‚ config.      â”‚      â”‚   (texté•¿åº¦)  â”‚                    â”‚
â”‚  â”‚ creditsPerCallâ”‚     â”‚ â€¢ è®¡ç®—å•ä½æ•°   â”‚                    â”‚
â”‚  â”‚              â”‚      â”‚   (length/1000)â”‚                   â”‚
â”‚  â”‚              â”‚      â”‚ â€¢ credits =    â”‚                   â”‚
â”‚  â”‚              â”‚      â”‚   units *      â”‚                   â”‚
â”‚  â”‚              â”‚      â”‚   creditsPerUnitâ”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                    â†“                                        â”‚
â”‚         åº”ç”¨ maxCredits é™åˆ¶                                 â”‚
â”‚                    â†“                                        â”‚
â”‚         æ£€æŸ¥ç”¨æˆ·ç§¯åˆ†ä½™é¢                                      â”‚
â”‚                    â†“                                        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚         â”‚ ä½™é¢ >= required? â”‚                               â”‚
â”‚         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                â”‚
â”‚              â”‚ æ˜¯     â”‚ å¦                                  â”‚
â”‚              â†“        â†“                                     â”‚
â”‚         æ‰§è¡Œå·¥å…·   æŠ›å‡ºå¼‚å¸¸                                   â”‚
â”‚              â†“     "ç§¯åˆ†ä¸è¶³"                                â”‚
â”‚         â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                                         â”‚
â”‚         â”‚ æˆåŠŸ?   â”‚                                         â”‚
â”‚         â””â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”˜                                         â”‚
â”‚           â”‚æ˜¯  â”‚å¦                                          â”‚
â”‚           â†“    â†“                                            â”‚
â”‚        æ‰£ç§¯åˆ†  ä¸æ‰£è´¹                                         â”‚
â”‚           â†“                                                 â”‚
â”‚        è®°å½•æ—¥å¿—                                              â”‚
â”‚           â†“                                                 â”‚
â”‚        è¿”å›ç»“æœ                                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### 7. å®é™…ä½¿ç”¨ç¤ºä¾‹

**ç¤ºä¾‹ 1: Fish Audio TTS (æŒ‰é‡è®¡è´¹)**

```typescript
// ç”¨æˆ·è¾“å…¥æ–‡æœ¬é•¿åº¦ä¸º 2500 å­—ç¬¦
const input = {
  text: 'è¿™æ˜¯ä¸€æ®µå¾ˆé•¿çš„æ–‡æœ¬...(å…±2500å­—)',
  reference: { entityId: 'ref_audio_123' }
};

// è®¡è´¹è®¡ç®—
// units = Math.ceil(2500 / 1000) = 3
// credits = 3 * 10 = 30 ç§¯åˆ†

// æ‰§è¡Œæµç¨‹
// 1. æ£€æŸ¥ç”¨æˆ·ç§¯åˆ† >= 30
// 2. æ‰§è¡Œ TTS ç”Ÿæˆ
// 3. æˆåŠŸåæ‰£é™¤ 30 ç§¯åˆ†
// 4. è®°å½•æ—¥å¿—åˆ° credit_log è¡¨
```

**ç¤ºä¾‹ 2: HeyGen è§†é¢‘ç”Ÿæˆ (æŒ‰æ¬¡è®¡è´¹)**

```typescript
// ç”Ÿæˆè§†é¢‘ï¼Œå›ºå®šæ¶ˆè€— 500 ç§¯åˆ†
const input = {
  script: 'æ¬¢è¿æ¥åˆ°æˆ‘ä»¬çš„äº§å“ä»‹ç»...',
  avatar_id: 'avatar_456'
};

// è®¡è´¹è®¡ç®—
// credits = 500 (å›ºå®šå€¼)

// æ‰§è¡Œæµç¨‹
// 1. æ£€æŸ¥ç”¨æˆ·ç§¯åˆ† >= 500
// 2. æ‰§è¡Œè§†é¢‘ç”Ÿæˆ
// 3. æˆåŠŸåæ‰£é™¤ 500 ç§¯åˆ†
// 4. è®°å½•æ—¥å¿—
```

#### 8. è®¡è´¹é…ç½®æœ€ä½³å®è·µ

**æŒ‰æ¬¡è®¡è´¹é€‚ç”¨åœºæ™¯**:
- æˆæœ¬ç›¸å¯¹å›ºå®šçš„æ“ä½œï¼ˆå¦‚è§†é¢‘ç”Ÿæˆã€å›¾ç‰‡ç”Ÿæˆï¼‰
- æ‰§è¡Œæ—¶é—´è¾ƒé•¿çš„ä»»åŠ¡
- ä¸ä¾èµ–è¾“å…¥å¤§å°çš„æ“ä½œ

**æŒ‰é‡è®¡è´¹é€‚ç”¨åœºæ™¯**:
- æˆæœ¬ä¸è¾“å…¥å¤§å°æˆæ­£æ¯”çš„æ“ä½œï¼ˆå¦‚æ–‡æœ¬è½¬è¯­éŸ³ã€ç¿»è¯‘ï¼‰
- å¤„ç†å¤§æ•°æ®é‡çš„ä»»åŠ¡
- éœ€è¦ç²¾ç»†åŒ–è®¡è´¹çš„åœºæ™¯

**è®¡è´¹é…ç½®å»ºè®®**:
```typescript
{
  enabled: true,
  type: BillingType.PER_QUANTITY,
  creditsPerUnit: 10,
  quantityField: 'text',
  maxCredits: 1000  // â­ åŠ¡å¿…è®¾ç½®ä¸Šé™ï¼Œé˜²æ­¢æ¶æ„è°ƒç”¨
}
```

---

### å¼‚å¸¸å¤„ç†

#### 1. å¼‚å¸¸å¤„ç†å™¨

```typescript
// error-handler.ts
export class ToolErrorHandler {
  /**
   * å¤„ç†å·¥å…·æ‰§è¡Œé”™è¯¯
   */
  static handleToolError(error: any, context: {
    toolsetKey: string;
    methodName: string;
    args: any;
  }): string {
    // è®°å½•è¯¦ç»†é”™è¯¯
    console.error('[ToolError]', {
      toolset: context.toolsetKey,
      method: context.methodName,
      args: context.args,
      error: {
        message: error.message,
        stack: error.stack,
        status: error.status,
        code: error.code
      },
      timestamp: new Date()
    });

    // æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ç”¨æˆ·å‹å¥½çš„æ¶ˆæ¯
    if (error.status === 401 || error.status === 403) {
      return this.formatAuthError(context.toolsetKey);
    }

    if (error.status === 402) {
      return this.formatQuotaError(context.toolsetKey);
    }

    if (error.status === 429) {
      return this.formatRateLimitError();
    }

    if (error.code === 'ECONNREFUSED' || error.code === 'ETIMEDOUT') {
      return this.formatNetworkError(context.toolsetKey);
    }

    if (error.message?.includes('Invalid schema')) {
      return this.formatValidationError(error.message);
    }

    // é€šç”¨é”™è¯¯
    return this.formatGenericError(error.message);
  }

  private static formatAuthError(toolsetKey: string): string {
    return `âŒ è®¤è¯å¤±è´¥

å·¥å…· "${toolsetKey}" çš„ API å¯†é’¥æ— æ•ˆæˆ–å·²è¿‡æœŸã€‚

è¯·æ£€æŸ¥é…ç½®æˆ–è”ç³»ç®¡ç†å‘˜ã€‚`;
  }

  private static formatQuotaError(toolsetKey: string): string {
    return `âŒ é…é¢ä¸è¶³

å·¥å…· "${toolsetKey}" çš„ä½¿ç”¨é…é¢å·²ç”¨å°½ã€‚

è¯·å‡çº§è®¡åˆ’æˆ–è”ç³»ç®¡ç†å‘˜ã€‚`;
  }

  private static formatRateLimitError(): string {
    return `âŒ è¯·æ±‚è¿‡äºé¢‘ç¹

API è°ƒç”¨é€Ÿç‡é™åˆ¶å·²è§¦å‘ã€‚

è¯·ç¨åé‡è¯•ï¼ˆå»ºè®®ç­‰å¾… 1-2 åˆ†é’Ÿï¼‰ã€‚`;
  }

  private static formatNetworkError(toolsetKey: string): string {
    return `âŒ ç½‘ç»œè¿æ¥å¤±è´¥

æ— æ³•è¿æ¥åˆ° "${toolsetKey}" æœåŠ¡ã€‚

å¯èƒ½åŸå› ï¼š
  - æœåŠ¡æš‚æ—¶ä¸å¯ç”¨
  - ç½‘ç»œè¿æ¥é—®é¢˜
  - é˜²ç«å¢™é˜»æ­¢

è¯·ç¨åé‡è¯•ã€‚`;
  }

  private static formatValidationError(message: string): string {
    return `âŒ å‚æ•°éªŒè¯å¤±è´¥

${message}

è¯·æ£€æŸ¥è¾“å…¥å‚æ•°æ˜¯å¦ç¬¦åˆè¦æ±‚ã€‚`;
  }

  private static formatGenericError(message: string): string {
    return `âŒ æ“ä½œå¤±è´¥

é”™è¯¯ä¿¡æ¯: ${message}

å¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒã€‚`;
  }

  /**
   * é‡è¯•ç­–ç•¥
   */
  static async withRetry<T>(
    fn: () => Promise<T>,
    options: {
      maxRetries?: number;
      retryDelay?: number;
      retryableErrors?: number[];
    } = {}
  ): Promise<T> {
    const {
      maxRetries = 3,
      retryDelay = 1000,
      retryableErrors = [429, 500, 502, 503, 504]
    } = options;

    let lastError: any;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;

        // æ£€æŸ¥æ˜¯å¦å¯é‡è¯•
        const isRetryable = error.status && retryableErrors.includes(error.status);

        if (!isRetryable || attempt === maxRetries) {
          throw error;
        }

        // ç­‰å¾…åé‡è¯•
        console.log(`[Retry] Attempt ${attempt}/${maxRetries} failed, retrying in ${retryDelay}ms...`);
        await this.sleep(retryDelay * attempt);  // æŒ‡æ•°é€€é¿
      }
    }

    throw lastError;
  }

  private static sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

#### 2. åœ¨ DynamicToolRegistry ä¸­é›†æˆå¼‚å¸¸å¤„ç†

```typescript
// dynamic-tool-registry.ts (updated)
private createTool(methodConfig: ToolMethodConfig): DynamicStructuredTool {
  const handler = this.handlerFactory.createHandler(
    methodConfig,
    this.config.credentials
  );

  const zodSchema = this.buildZodSchema(JSON.parse(methodConfig.schema));

  return new DynamicStructuredTool({
    name: `${this.config.domain.replace('.', '_')}__${methodConfig.name}`,
    description: methodConfig.description,
    schema: zodSchema,

    func: async (args) => {
      try {
        // ä½¿ç”¨é‡è¯•ç­–ç•¥
        const response = await ToolErrorHandler.withRetry(
          () => handler.handle({
            provider: this.config.domain,
            method: methodConfig.name,
            params: args
          }),
          {
            maxRetries: 3,
            retryDelay: 1000,
            retryableErrors: [429, 500, 502, 503, 504]
          }
        );

        if (!response.success) {
          return ToolErrorHandler.handleToolError(
            new Error(response.error),
            {
              toolsetKey: this.config.domain,
              methodName: methodConfig.name,
              args
            }
          );
        }

        // ä½¿ç”¨å“åº”æ ¼å¼åŒ–å™¨
        const resourceType = this.getResourceType(methodConfig);
        return ResponseFormatter.formatToolResponse(response, resourceType);

      } catch (error) {
        return ToolErrorHandler.handleToolError(error, {
          toolsetKey: this.config.domain,
          methodName: methodConfig.name,
          args
        });
      }
    }
  });
}

private getResourceType(methodConfig: ToolMethodConfig): string | undefined {
  const responseSchema = JSON.parse(methodConfig.responseSchema);
  const resourceFields = this.handlerFactory['extractResourceFields'](responseSchema);

  if (resourceFields.length > 0) {
    return resourceFields[0].type;
  }

  return undefined;
}
```

---

## å®Œæ•´é›†æˆç¤ºä¾‹

### ç¤ºä¾‹ 1: å•ä¸ªå·¥å…·æ³¨å†Œ

```typescript
// fish-audio-tool.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z } from 'zod';
import { FishAudioHandlerV2 } from './handler/fish-audio-handler-v2';

export function createFishAudioTool(
  prismaService: any,
  miscService: any,
  user: User
): DynamicStructuredTool {
  // 1. åˆ›å»º Handler
  const handler = new FishAudioHandlerV2({
    endpoint: 'https://api.fish.audio/v1/tts',
    credentials: { apiKey: process.env.FISH_AUDIO_API_KEY },
    outputDir: './output',
    prismaService,
    miscService,
    user,
    enableResourceUpload: true  // å¯ç”¨è‡ªåŠ¨ä¸Šä¼ 
  });

  // 2. åˆ›å»º Tool
  return new DynamicStructuredTool({
    name: 'fish_audio__text_to_speech',

    description: `Convert text to speech using Fish Audio API.
Supports voice cloning with reference audio.
Returns audio file URL that can be accessed directly.`,

    schema: z.object({
      text: z.string()
        .min(1)
        .max(1000)
        .describe('The text to convert to speech (1-1000 characters)'),

      reference: z.object({
        entityId: z.string().describe('Reference audio file entity ID for voice cloning'),
        text: z.string().optional().describe('Transcript of reference audio (auto-generated if not provided)')
      }).optional().describe('Optional reference audio for voice cloning')
    }),

    func: async (args) => {
      try {
        // 3. è°ƒç”¨ Handler
        const response = await handler.handle({
          tooksetKey: 'fish-audio',
          method: 'text_to_speech',
          params: args
        });

        // 4. æ£€æŸ¥ç»“æœ
        if (!response.success) {
          return `ç”Ÿæˆå¤±è´¥: ${response.error || 'æœªçŸ¥é”™è¯¯'}`;
        }

        // 5. æ ¼å¼åŒ–è¾“å‡ºï¼ˆLLM å¯ç†è§£ï¼‰
        return `âœ… éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - æ–‡ä»¶ID: ${response.entityId}
  - å­˜å‚¨è·¯å¾„: ${response.storageKey}

ğŸ”— è®¿é—®é“¾æ¥:
  ${response.url}

ğŸ’¾ æœ¬åœ°è·¯å¾„:
  ${response.localPath}

ğŸµ éŸ³é¢‘ä¿¡æ¯:
  - æ—¶é•¿: ${response.data?.duration || 'N/A'}ç§’
  - é‡‡æ ·ç‡: ${response.data?.sampleRate || 'N/A'}Hz`;

      } catch (error) {
        console.error('Fish Audio TTS Error:', error);
        return `âŒ ç”Ÿæˆå¤±è´¥: ${error.message}`;
      }
    }
  });
}
```

### ç¤ºä¾‹ 2: æ‰¹é‡å·¥å…·æ³¨å†Œï¼ˆé…ç½®é©±åŠ¨ï¼‰

```typescript
// dynamic-tool-registry.ts
import { DynamicStructuredTool } from '@langchain/core/tools';
import { z, ZodSchema } from 'zod';
import { HttpHandler } from './handler/http';

export interface ToolConfig {
  toolsetKey: string;
  baseUrl: string;
  credentials: {
    apiKey?: string;
    apiSecret?: string;
  };
  methods: ToolMethodConfig[];
}

export interface ToolMethodConfig {
  name: string;
  description: string;
  endpoint: string;
  schema: Record<string, {
    type: string;
    description?: string;
    optional?: boolean;
  }>;
  outputResource?: {
    type: 'audio' | 'video' | 'image' | 'document';
    cardinality: 'single' | 'multiple';
  };
}

export class DynamicToolRegistry {
  private config: ToolConfig;
  private prismaService: any;
  private miscService: any;
  private user: User;

  constructor(
    configPath: string,
    prismaService: any,
    miscService: any,
    user: User
  ) {
    this.config = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
    this.prismaService = prismaService;
    this.miscService = miscService;
    this.user = user;
  }

  /**
   * æ³¨å†Œæ‰€æœ‰å·¥å…·
   */
  public registerTools(): DynamicStructuredTool[] {
    return this.config.methods.map(methodConfig =>
      this.createTool(methodConfig)
    );
  }

  /**
   * åˆ›å»º HttpHandler
   */
  private createHandler(methodConfig: ToolMethodConfig): HttpHandler {
    return new HttpHandler({
      endpoint: `${this.config.baseUrl}${methodConfig.endpoint}`,
      credentials: this.config.credentials,
      outputDir: './output',

      // è¾“å…¥èµ„æºé…ç½®
      resourceFields: this.extractResourceFields(methodConfig.schema),
      resourceResolver: {
        resolveFile: async (storageKey, visibility) => {
          return await this.miscService.downloadFile({ storageKey, visibility });
        },
        getFileMetadata: async (entityId) => {
          return await this.prismaService.staticFile.findFirst({
            where: { entityId, deletedAt: null }
          });
        }
      },

      // è¾“å‡ºèµ„æºé…ç½®
      outputResource: methodConfig.outputResource,
      resourceUploader: {
        uploadFile: async (localPath, metadata) => {
          const buffer = await fs.readFile(localPath);
          const extension = localPath.split('.').pop();
          const storageKey = `generated/${metadata.provider}/${metadata.method}/${Date.now()}.${extension}`;

          // ä¸Šä¼ åˆ°å­˜å‚¨
          await this.miscService.uploadFile({ buffer, storageKey });

          // åˆ›å»ºæ•°æ®åº“è®°å½•
          const record = await this.prismaService.staticFile.create({
            data: {
              entityId: `${metadata.type}_${Date.now()}`,
              storageKey,
              type: metadata.type,
              mimeType: metadata.mimeType,
              visibility: 'public',
              size: buffer.length,
              userId: this.user.id
            }
          });

          return {
            fileId: record.id,
            entityId: record.entityId,
            storageKey: record.storageKey,
            url: `https://${process.env.CDN_DOMAIN}/${storageKey}`
          };
        }
      }
    });
  }

  /**
   * æ„å»º Zod Schema
   */
  private buildZodSchema(schemaConfig: Record<string, any>): ZodSchema {
    const fields: Record<string, any> = {};

    for (const [fieldName, fieldConfig] of Object.entries(schemaConfig)) {
      let zodField;

      switch (fieldConfig.type) {
        case 'string':
          zodField = z.string();
          break;
        case 'number':
          zodField = z.number();
          break;
        case 'boolean':
          zodField = z.boolean();
          break;
        case 'object':
          zodField = z.object(fieldConfig.properties || {});
          break;
        default:
          zodField = z.any();
      }

      if (fieldConfig.description) {
        zodField = zodField.describe(fieldConfig.description);
      }

      if (fieldConfig.optional) {
        zodField = zodField.optional();
      }

      fields[fieldName] = zodField;
    }

    return z.object(fields);
  }

  /**
   * æå–èµ„æºå­—æ®µï¼ˆé€’å½’éå†æ”¯æŒåµŒå¥—ç»“æ„ï¼‰
   */
  private extractResourceFields(responseSchema: ResponseSchema): Array<{
    fieldPath: string;
    type: 'audio' | 'video' | 'image' | 'document';
    isArray: boolean;
  }> {
    const resourceFields: Array<{
      fieldPath: string;
      type: 'audio' | 'video' | 'image' | 'document';
      isArray: boolean;
    }> = [];

    const traverse = (schema: any, path = '', parentIsArray = false): void => {
      // æ£€æŸ¥å½“å‰å­—æ®µæ˜¯å¦æ˜¯èµ„æº
      if (schema.isResource && schema.resourceType) {
        resourceFields.push({
          fieldPath: path,
          type: schema.resourceType,
          isArray: parentIsArray,
        });
      }

      // éå†åµŒå¥—å¯¹è±¡
      if (schema.type === 'object' && schema.properties) {
        for (const [key, subSchema] of Object.entries(schema.properties)) {
          const subPath = path ? `${path}.${key}` : key;
          traverse(subSchema, subPath, false);
        }
      }

      // éå†æ•°ç»„ - æ£€æŸ¥ items æ˜¯å¦æ˜¯èµ„æº
      if (schema.type === 'array' && schema.items) {
        if (schema.items.isResource && schema.items.resourceType) {
          resourceFields.push({
            fieldPath: path,
            type: schema.items.resourceType,
            isArray: true,
          });
        } else {
          // ç»§ç»­éå†æ•°ç»„ items çš„åµŒå¥—ç»“æ„
          traverse(schema.items, path, true);
        }
      }
    };

    // ä»æ ¹å±æ€§å¼€å§‹éå†
    if (responseSchema.properties) {
      for (const [fieldName, fieldSchema] of Object.entries(responseSchema.properties)) {
        traverse(fieldSchema, fieldName);
      }
    }

    return resourceFields;
  }

  /**
   * æ ¼å¼åŒ–å•ä¸ªç»“æœ
   */
  private formatSingleResult(response: any): string {
    return `âœ… ç”ŸæˆæˆåŠŸï¼
æ–‡ä»¶ID: ${response.entityId}
è®¿é—®é“¾æ¥: ${response.url}`;
  }

  /**
   * æ ¼å¼åŒ–å¤šä¸ªç»“æœ
   */
  private formatMultipleResults(response: any): string {
    const results = response.uploadResults || [];
    return `âœ… æ‰¹é‡ç”ŸæˆæˆåŠŸï¼å…± ${results.length} ä¸ªæ–‡ä»¶

${results.map((r, i) => `${i + 1}. ${r.url}`).join('\n')}`;
  }
}

// ä½¿ç”¨
const registry = new DynamicToolRegistry(
  './config/fish-audio-config.json',
  prismaService,
  miscService,
  user
);

const tools = registry.registerTools();
```

### ç¤ºä¾‹ 3: é…ç½®æ–‡ä»¶

```json
// config/fish-audio-config.json
{
  "toolsetKey": "fish-audio",
  "baseUrl": "https://api.fish.audio",
  "credentials": {
    "apiKey": "${FISH_AUDIO_API_KEY}"
  },
  "methods": [
    {
      "name": "text_to_speech",
      "description": "Convert text to speech using Fish Audio API",
      "endpoint": "/v1/tts",
      "schema": {
        "text": {
          "type": "string",
          "description": "The text to convert to speech",
          "optional": false
        },
        "reference": {
          "type": "object",
          "description": "Optional reference audio for voice cloning",
          "optional": true,
          "isResource": true,
          "resourceType": "audio",
          "properties": {
            "entityId": {
              "type": "string",
              "description": "Reference audio file entity ID"
            },
            "text": {
              "type": "string",
              "description": "Transcript of reference audio",
              "optional": true
            }
          }
        }
      },
      "responseSchema": {
        "type": "object",
        "properties": {
          "audio": {
            "type": "string",
            "description": "Audio data in binary format or base64",
            "isResource": true,
            "resourceType": "audio"
          },
          "duration": {
            "type": "number",
            "description": "Duration of the generated audio in seconds",
            "optional": true
          }
        }
      }
    }
  ]
}
```

---

## å“åº” Schema é…ç½®

### ResponseSchema è®¾è®¡

**responseSchema** æä¾›ç»Ÿä¸€ã€ç±»å‹å®‰å…¨çš„å“åº”å¤„ç†æ–¹å¼ï¼Œä½¿ç”¨ Zod è¿›è¡Œè¿è¡Œæ—¶éªŒè¯ã€‚

**æ ¸å¿ƒä¼˜åŠ¿ï¼š**
- âœ… **å•ä¸€æ•°æ®æº** - schema å®šä¹‰æ‰€æœ‰å“åº”ç»“æ„
- âœ… **ç±»å‹å®‰å…¨** - Zod éªŒè¯ç¡®ä¿å“åº”ç¬¦åˆé¢„æœŸ
- âœ… **æ¸…æ™°è¯­ä¹‰** - `type: 'array'` æ˜ç¡®è¡¨ç¤ºå¤šèµ„æº
- âœ… **ç»Ÿä¸€è®¾è®¡** - ä¸è¾“å…¥ schema ä¿æŒä¸€è‡´

### åŸºæœ¬ç”¨æ³•

#### å•ä¸ªèµ„æºï¼ˆFish Audio TTSï¼‰

```json
{
  "method": "text_to_speech",
  "responseSchema": {
    "type": "object",
    "properties": {
      "audio": {
        "type": "string",
        "description": "Audio data in binary format or base64",
        "isResource": true,
        "resourceType": "audio"
      },
      "duration": {
        "type": "number",
        "description": "Duration of the generated audio in seconds",
        "optional": true
      },
      "format": {
        "type": "string",
        "optional": true,
        "enum": ["wav", "pcm", "mp3", "opus"]
      }
    }
  }
}
```

**å·¥ä½œåŸç†ï¼š**
1. Handler æ¥æ”¶å“åº”åï¼Œä½¿ç”¨ Zod éªŒè¯æ•°æ®ç»“æ„
2. è‡ªåŠ¨è¯†åˆ« `audio` å­—æ®µä¸ºèµ„æºï¼ˆ`isResource: true`ï¼‰
3. ä¸‹è½½/ä¸Šä¼ è¯¥èµ„æº
4. è¿”å›å¢å¼ºçš„å“åº”ï¼ŒåŒ…å« `fileId`ã€`url` ç­‰

#### å¤šä¸ªèµ„æºï¼ˆå›¾ç‰‡ç”Ÿæˆï¼‰

```json
{
  "method": "generate_images",
  "responseSchema": {
    "type": "object",
    "properties": {
      "images": {
        "type": "array",
        "description": "Array of generated images",
        "items": {
          "type": "string",
          "isResource": true,
          "resourceType": "image"
        }
      },
      "model": {
        "type": "string",
        "optional": true
      }
    }
  }
}
```

**å…³é”®ç‚¹ï¼š**
- ä½¿ç”¨ `type: 'array'` è¡¨ç¤ºå¤šä¸ªèµ„æº
- åœ¨ `items` ä¸­æ ‡è®° `isResource: true`

#### åµŒå¥—èµ„æºï¼ˆHeyGen è§†é¢‘ç”Ÿæˆï¼‰

```json
{
  "method": "create_video",
  "responseSchema": {
    "type": "object",
    "properties": {
      "data": {
        "type": "object",
        "properties": {
          "video_url": {
            "type": "string",
            "isResource": true,
            "resourceType": "video"
          },
          "thumbnail_url": {
            "type": "string",
            "isResource": true,
            "resourceType": "image"
          },
          "gif_url": {
            "type": "string",
            "optional": true,
            "isResource": true,
            "resourceType": "image"
          }
        }
      }
    }
  }
}
```

**è‡ªåŠ¨å¤„ç†ï¼š**
- Handler è‡ªåŠ¨éå†åµŒå¥—ç»“æ„
- æå–æ‰€æœ‰ `isResource: true` çš„å­—æ®µ
- å­—æ®µè·¯å¾„ï¼š`data.video_url`, `data.thumbnail_url`, `data.gif_url`

### é›†æˆåˆ° LangChain Tool

```typescript
import { DynamicStructuredTool } from '@langchain/core/tools';
import { ImprovedHttpHandler } from './handler/http';

// åˆ›å»º Handler
const handler = new ImprovedHttpHandler({
  endpoint: 'https://api.fish.audio/v1/tts',
  credentials: { apiKey: process.env.FISH_AUDIO_API_KEY },

  // å“åº” Schema é…ç½®
  responseSchema: {
    type: 'object',
    properties: {
      audio: {
        type: 'string',
        isResource: true,
        resourceType: 'audio'
      },
      duration: {
        type: 'number',
        optional: true
      }
    }
  },

  resourceUploader: {
    uploadFile: async (localPath, metadata) => {
      return { fileId, entityId, storageKey, url };
    }
  }
});

// åˆ›å»º Tool
const tool = new DynamicStructuredTool({
  name: 'fish_audio__text_to_speech',
  description: 'Convert text to speech using Fish Audio API',

  schema: z.object({
    text: z.string().describe('Text to convert'),
  }),

  func: async (args) => {
    const response = await handler.handle({
      provider: 'fish-audio',
      method: 'text_to_speech',
      params: args
    });

    if (!response.success) {
      return `Error: ${response.error}`;
    }

    return `éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼
æ–‡ä»¶ID: ${response.entityId}
è®¿é—®é“¾æ¥: ${response.url}`;
  }
});
```

### é…ç½®é©±åŠ¨çš„å·¥å…·æ³¨å†Œ

```typescript
export class DynamicToolRegistry {
  /**
   * ä»é…ç½®åˆ›å»º Tool
   */
  private createTool(methodConfig: ToolMethodConfig): DynamicStructuredTool {
    // åˆ›å»º Handlerï¼ˆæ”¯æŒ responseSchemaï¼‰
    const handler = new ImprovedHttpHandler({
      endpoint: `${this.config.baseUrl}${methodConfig.endpoint}`,
      credentials: this.config.credentials,
      responseSchema: methodConfig.responseSchema,
      resourceUploader: this.createResourceUploader()
    });

    // æ„å»ºè¾“å…¥ Zod Schema
    const zodSchema = this.buildZodSchema(methodConfig.schema);

    // åˆ›å»º DynamicStructuredTool
    return new DynamicStructuredTool({
      name: `${this.config.toolsetKey}__${methodConfig.name}`,
      description: methodConfig.description,
      schema: zodSchema,

      func: async (args) => {
        const response = await handler.handle({
          provider: this.config.toolsetKey,
          method: methodConfig.name,
          params: args
        });

        return this.formatResponse(response, methodConfig);
      }
    });
  }

  /**
   * æ ¼å¼åŒ–å“åº”ï¼ˆæ ¹æ® schema è‡ªåŠ¨åˆ¤æ–­ï¼‰
   */
  private formatResponse(response: any, methodConfig: ToolMethodConfig): string {
    if (!response.success) {
      return `Error: ${response.error}`;
    }

    // æ ¹æ® responseSchema æå–èµ„æºå­—æ®µ
    const resourceFields = this.extractResourceFields(methodConfig.responseSchema);

    if (resourceFields.length === 0) {
      return JSON.stringify(response.data);
    }

    // å•ä¸ªèµ„æº
    if (resourceFields.length === 1 && !resourceFields[0].isArray) {
      return `âœ… ç”ŸæˆæˆåŠŸï¼
æ–‡ä»¶ID: ${response.entityId}
è®¿é—®é“¾æ¥: ${response.url}`;
    }

    // å¤šä¸ªèµ„æº
    const uploadResults = response.uploadResults || [];
    return `âœ… æ‰¹é‡ç”ŸæˆæˆåŠŸï¼å…± ${uploadResults.length} ä¸ªæ–‡ä»¶

${uploadResults.map((r, i) => `${i + 1}. ${r.url}`).join('\n')}`;
  }
}
```

### å®Œæ•´é…ç½®ç¤ºä¾‹

```json
// config/fish-audio-config.json
{
  "toolsetKey": "fish-audio",
  "baseUrl": "https://api.fish.audio",
  "credentials": {
    "apiKey": "${FISH_AUDIO_API_KEY}"
  },
  "methods": [
    {
      "name": "text_to_speech",
      "description": "Convert text to speech using Fish Audio API",
      "endpoint": "/v1/tts",

      "schema": {
        "text": {
          "type": "string",
          "description": "Text to convert to speech"
        },
        "references": {
          "type": "array",
          "description": "Multiple reference audios for voice cloning",
          "optional": true,
          "items": {
            "type": "object",
            "isResource": true,
            "resourceType": "audio",
            "properties": {
              "entityId": {
                "type": "string",
                "description": "Reference audio file entity ID"
              },
              "weight": {
                "type": "number",
                "description": "Weight for this reference (0.0-1.0)",
                "optional": true,
                "default": 1.0
              },
              "text": {
                "type": "string",
                "description": "Transcript of reference audio",
                "optional": true
              }
            }
          }
        },
        "temperature": {
          "type": "number",
          "optional": true,
          "default": 0.9,
          "min": 0,
          "max": 1
        }
      },

      "responseSchema": {
        "type": "object",
        "properties": {
          "audio": {
            "type": "string",
            "isResource": true,
            "resourceType": "audio"
          },
          "duration": {
            "type": "number",
            "optional": true
          },
          "format": {
            "type": "string",
            "optional": true,
            "enum": ["wav", "pcm", "mp3", "opus"]
          }
        }
      }
    }
  ]
}
```

### èµ„æºå¤„ç†çš„é€šç”¨æ¨¡å¼

ä¸Šé¢çš„é…ç½®ç¤ºä¾‹å±•ç¤ºäº†è¾“å…¥å’Œè¾“å‡ºèµ„æºå¤„ç†çš„é€šç”¨æ¨¡å¼ï¼š

#### è¾“å…¥èµ„æºå¤„ç†ï¼ˆPre-Handlerï¼‰

åœ¨ `schema` ä¸­ä½¿ç”¨ `isResource: true` æ ‡è®°èµ„æºå­—æ®µï¼š

```json
{
  "references": {
    "type": "array",
    "items": {
      "type": "object",
      "isResource": true,        // ğŸ‘ˆ æ ‡è®°ä¸ºèµ„æº
      "resourceType": "audio",
      "properties": {
        "entityId": { "type": "string" },
        "weight": { "type": "number" }
      }
    }
  }
}
```

**å¤„ç†æµç¨‹ï¼š**

1. ç”¨æˆ·æä¾›ï¼š`{ references: [{ entityId: "audio_123", weight: 0.7 }] }`
2. Pre-Handler æ£€æµ‹åˆ° `items.isResource: true`
3. éå†æ•°ç»„ä¸­çš„æ¯ä¸ªé¡¹ç›®
4. æ ¹æ® `entityId` è§£æèµ„æºï¼ˆä¸‹è½½æ–‡ä»¶ â†’ Bufferï¼‰
5. ä¿ç•™å…¶ä»–å­—æ®µï¼ˆå¦‚ `weight`ï¼‰
6. è¾“å‡ºï¼š`{ references: [{ audio: Buffer(...), weight: 0.7 }] }`

**å…³é”®ç‚¹ï¼š**
- âœ… `entityId` å­—æ®µè¢«ç§»é™¤
- âœ… æ·»åŠ  `audio` å­—æ®µï¼ˆBuffer ç±»å‹ï¼‰
- âœ… å…¶ä»–å­—æ®µï¼ˆ`weight`, `text` ç­‰ï¼‰è¢«ä¿ç•™

#### è¾“å‡ºèµ„æºå¤„ç†ï¼ˆPost-Handlerï¼‰

åœ¨ `responseSchema` ä¸­ä½¿ç”¨ `isResource: true` æ ‡è®°èµ„æºå­—æ®µï¼š

```json
{
  "responseSchema": {
    "type": "object",
    "properties": {
      "audio": {
        "type": "string",
        "isResource": true,
        "resourceType": "audio"
      }
    }
  }
}
```

**å¤„ç†æµç¨‹ï¼š**

1. API è¿”å›ï¼š`{ audio: "./output/generated_audio.mp3" }` ï¼ˆæœ¬åœ°è·¯å¾„ï¼‰
2. Post-Handler æ£€æµ‹åˆ° `isResource: true`
3. ä¸Šä¼ æ–‡ä»¶åˆ°å­˜å‚¨æœåŠ¡
4. è¿”å›ï¼š`{ fileId: "...", entityId: "...", url: "https://..." }`

**æ•°ç»„èµ„æºåŒæ ·é€‚ç”¨ï¼š**

```json
{
  "output": {
    "type": "array",
    "items": {
      "type": "string",
      "isResource": true,
      "resourceType": "image"
    }
  }
}
```

å¤„ç†æ–¹å¼ä¸è¾“å…¥èµ„æºæ•°ç»„ç›¸åŒï¼šéå†æ•°ç»„ï¼Œä¸Šä¼ æ¯ä¸ªæ–‡ä»¶ï¼Œè¿”å›ç»“æœæ•°ç»„ã€‚

è¯¦ç»†çš„å“åº” Schema é…ç½®æŒ‡å—ï¼Œè¯·å‚è€ƒï¼š
- [RESPONSE_SCHEMA_GUIDE.md](../RESPONSE_SCHEMA_GUIDE.md) - å®Œæ•´ä½¿ç”¨æŒ‡å—
- [universal-resource-handling-demo.ts](../test/universal-resource-handling-demo.ts) - å®Œæ•´æ¼”ç¤ºä»£ç 

---

## Agent è°ƒç”¨æµç¨‹

### åˆ›å»º Agent å¹¶ä½¿ç”¨å·¥å…·

```typescript
// agent.ts
import { ChatOpenAI } from '@langchain/openai';
import { AgentExecutor, createStructuredChatAgent } from 'langchain/agents';
import { pull } from 'langchain/hub';
import { createFishAudioTool } from './tools/fish-audio-tool';

export async function createMediaAgent(
  prismaService: any,
  miscService: any,
  user: User
) {
  // 1. åˆ›å»º LLM
  const llm = new ChatOpenAI({
    modelName: 'gpt-4',
    temperature: 0
  });

  // 2. åˆ›å»ºå·¥å…·åˆ—è¡¨
  const tools = [
    createFishAudioTool(prismaService, miscService, user),
    // å¯ä»¥æ·»åŠ æ›´å¤šå·¥å…·...
  ];

  // 3. åŠ è½½ Prompt Template
  const prompt = await pull('hwchase17/structured-chat-agent');

  // 4. åˆ›å»º Agent
  const agent = await createStructuredChatAgent({
    llm,
    tools,
    prompt
  });

  // 5. åˆ›å»º Agent Executor
  const executor = new AgentExecutor({
    agent,
    tools,
    verbose: true,  // æ‰“å°è¯¦ç»†æ—¥å¿—
    maxIterations: 3
  });

  return executor;
}

// ä½¿ç”¨ Agent
const executor = await createMediaAgent(prisma, misc, user);

const result = await executor.invoke({
  input: 'å¸®æˆ‘ç”Ÿæˆä¸€æ®µè¯­éŸ³ï¼šä½ å¥½ï¼Œæ¬¢è¿ä½¿ç”¨ AI åŠ©æ‰‹'
});

console.log(result.output);
// è¾“å‡º: "æˆ‘å·²ç»ä¸ºä½ ç”Ÿæˆäº†è¯­éŸ³ï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®ï¼š
//       https://cdn.example.com/audio_123.mp3"
```

### å®Œæ•´çš„å¯¹è¯æµç¨‹

```typescript
// 1. ç”¨æˆ·è¾“å…¥
const userInput = 'å¸®æˆ‘ç”¨å‚è€ƒéŸ³é¢‘ audio-voice-123.mp3 ç”Ÿæˆä¸€æ®µè¯­éŸ³ï¼šHello World';

// 2. Agent Executor è°ƒç”¨
const result = await executor.invoke({ input: userInput });

// å†…éƒ¨æµç¨‹:
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Step 1: LLM åˆ†æç”¨æˆ·æ„å›¾                                 â”‚
// â”‚   - è¯†åˆ«éœ€è¦ä½¿ç”¨ fish_audio__text_to_speech å·¥å…·         â”‚
// â”‚   - æå–å‚æ•°: { text: 'Hello World',                    â”‚
// â”‚               reference: { entityId: 'audio-voice-123.mp3' } } â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//                          â†“
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Step 2: è°ƒç”¨ DynamicStructuredTool                       â”‚
// â”‚   - Zod éªŒè¯å‚æ•°                                         â”‚
// â”‚   - è°ƒç”¨ func (HttpHandler)                              â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//                          â†“
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Step 3: HttpHandler æ‰§è¡Œ                                â”‚
// â”‚   - Pre-Handler: è§£æ reference.entityId â†’ File         â”‚
// â”‚   - API Call: è°ƒç”¨ Fish Audio API                        â”‚
// â”‚   - Post-Handler: ä¸Šä¼ ç”Ÿæˆçš„éŸ³é¢‘                         â”‚
// â”‚   - è¿”å›: { success: true, url: '...', ... }            â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//                          â†“
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Step 4: Tool è¿”å›ç»“æœ                                    â”‚
// â”‚   è¿”å›å­—ç¬¦ä¸²: "âœ… éŸ³é¢‘ç”ŸæˆæˆåŠŸï¼\nè®¿é—®é“¾æ¥: ..."          â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//                          â†“
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ Step 5: LLM ç”Ÿæˆæœ€ç»ˆå›å¤                                 â”‚
// â”‚   æ•´åˆå·¥å…·è¾“å‡ºï¼Œç”Ÿæˆç”¨æˆ·å‹å¥½çš„å›å¤                         â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

// 3. æœ€ç»ˆè¾“å‡º
console.log(result.output);
// "æˆ‘å·²ç»ä½¿ç”¨å‚è€ƒéŸ³é¢‘ç”Ÿæˆäº†è¯­éŸ³ï¼Œä½ å¯ä»¥é€šè¿‡ä»¥ä¸‹é“¾æ¥è®¿é—®ï¼š
//  https://cdn.example.com/audio_123.mp3"
```

---

## æœ€ä½³å®è·µæ¡ˆä¾‹

æœ¬èŠ‚æä¾›ä¸€ä¸ªå®Œæ•´çš„æœ€ä½³å®è·µæ¡ˆä¾‹ï¼Œå±•ç¤ºå¦‚ä½•ä»é›¶å¼€å§‹é›†æˆä¸€ä¸ªæ–°çš„ AI å·¥å…·ï¼ˆä»¥ HeyGen è§†é¢‘ç”Ÿæˆä¸ºä¾‹ï¼‰ã€‚

### æ¡ˆä¾‹åœºæ™¯

**éœ€æ±‚**ï¼šé›†æˆ HeyGen è§†é¢‘ç”Ÿæˆ APIï¼Œæ”¯æŒæ–‡æœ¬è½¬è§†é¢‘ã€æ•°å­—äººé…éŸ³ç­‰åŠŸèƒ½ã€‚

**æŒ‘æˆ˜**ï¼š
1. HeyGen API é‡‡ç”¨å¼‚æ­¥ä»»åŠ¡æ¨¡å¼ï¼ˆæäº¤ä»»åŠ¡ â†’ è½®è¯¢çŠ¶æ€ â†’ è·å–ç»“æœï¼‰
2. éœ€è¦å¤„ç†å¤šç§èµ„æºç±»å‹ï¼ˆè§†é¢‘ã€ç¼©ç•¥å›¾ã€GIFï¼‰
3. éœ€è¦æ”¯æŒè‡ªå®šä¹‰æ•°å­—äººå½¢è±¡ï¼ˆä¸Šä¼ ç…§ç‰‡ï¼‰
4. éœ€è¦å¤„ç†é•¿æ—¶é—´ä»»åŠ¡ï¼ˆè§†é¢‘ç”Ÿæˆå¯èƒ½éœ€è¦å‡ åˆ†é’Ÿï¼‰

### æ­¥éª¤ 1: æ•°æ®åº“é…ç½®åˆå§‹åŒ–

```typescript
// apps/api/src/modules/tool/scripts/init-heygen-toolset.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function initHeyGenToolset() {
  const config: ToolsetConfig = {
    domain: 'heygen.com',
    credentials: {
      apiKey: '${HEYGEN_API_KEY}'
    },
    methods: [
      {
        name: 'create_video',
        description: 'Create AI video with digital avatar. Supports text-to-speech and custom backgrounds. Best for: marketing videos, educational content, product demos.',
        endpoint: 'https://api.heygen.com/v2/video/generate',
        schema: JSON.stringify({
          type: 'object',
          properties: {
            script: {
              type: 'string',
              description: 'Video script text (will be spoken by the avatar)',
              minLength: 1,
              maxLength: 5000
            },
            avatar: {
              type: 'object',
              description: 'Avatar configuration',
              properties: {
                avatarId: {
                  type: 'string',
                  description: 'Pre-defined avatar ID (e.g., "anna_professional")'
                },
                customImage: {
                  type: 'object',
                  description: 'Custom avatar from uploaded image',
                  properties: {
                    entityId: {
                      type: 'string',
                      description: 'Entity ID of uploaded portrait photo'
                    }
                  },
                  isResource: true,
                  resourceType: 'image'
                }
              }
            },
            voice: {
              type: 'object',
              description: 'Voice settings',
              optional: true,
              properties: {
                voiceId: {
                  type: 'string',
                  description: 'Voice ID (e.g., "en-US-JennyNeural")'
                },
                speed: {
                  type: 'number',
                  description: 'Voice speed (0.5-2.0)',
                  optional: true,
                  default: 1.0,
                  min: 0.5,
                  max: 2.0
                }
              }
            }
          },
          required: ['script', 'avatar']
        }),
        responseSchema: JSON.stringify({
          type: 'object',
          properties: {
            data: {
              type: 'object',
              properties: {
                video_url: {
                  type: 'string',
                  description: 'Generated video URL',
                  isResource: true,
                  resourceType: 'video'
                },
                thumbnail_url: {
                  type: 'string',
                  description: 'Video thumbnail URL',
                  isResource: true,
                  resourceType: 'image'
                },
                gif_url: {
                  type: 'string',
                  description: 'Preview GIF URL',
                  optional: true,
                  isResource: true,
                  resourceType: 'image'
                },
                duration: {
                  type: 'number',
                  description: 'Video duration in seconds',
                  optional: true
                },
                resolution: {
                  type: 'string',
                  description: 'Video resolution',
                  optional: true
                }
              }
            }
          }
        })
      }
    ]
  };

  const toolset = await prisma.toolset.upsert({
    where: { key: 'heygen' },
    create: {
      toolsetId: 'global-heygen',
      key: 'heygen',
      name: 'HeyGen',
      isGlobal: true,
      authType: 'credentials',
      enabled: true,
      config: JSON.stringify(config)
    },
    update: {
      config: JSON.stringify(config)
    }
  });

  console.log('âœ… HeyGen toolset initialized:', toolset.key);
}

initHeyGenToolset()
  .catch(console.error)
  .finally(() => prisma.$disconnect());
```

### æ­¥éª¤ 2: åˆ›å»ºè‡ªå®šä¹‰ Handlerï¼ˆå¤„ç†å¼‚æ­¥ä»»åŠ¡ï¼‰

```typescript
// apps/api/src/modules/tool/handlers/heygen-handler.ts
import { BaseHttpHandler } from './base-http-handler';

export class HeyGenHandler extends BaseHttpHandler {
  private readonly POLL_INTERVAL = 3000;  // 3 ç§’
  private readonly MAX_POLL_ATTEMPTS = 60;  // æœ€å¤šè½®è¯¢ 3 åˆ†é’Ÿ

  constructor(options: any) {
    super({
      endpoint: options.endpoint,
      credentials: options.credentials,
      ...options
    });
  }

  /**
   * é‡å†™ handle æ–¹æ³•ï¼Œæ”¯æŒå¼‚æ­¥ä»»åŠ¡è½®è¯¢
   */
  async handle(request: any): Promise<any> {
    // 1. æäº¤ä»»åŠ¡
    const submitResponse = await super.handle(request);

    if (!submitResponse.success) {
      return submitResponse;
    }

    const taskId = submitResponse.data?.video_id;
    if (!taskId) {
      return {
        success: false,
        error: 'No task ID returned from HeyGen API'
      };
    }

    console.log(`[HeyGen] Task submitted: ${taskId}`);

    // 2. è½®è¯¢ä»»åŠ¡çŠ¶æ€
    const result = await this.pollTaskStatus(taskId);

    if (!result.success) {
      return result;
    }

    // 3. å¤„ç†èµ„æºï¼ˆè§†é¢‘ã€ç¼©ç•¥å›¾ç­‰ï¼‰
    return await this.processResources(result.data);
  }

  /**
   * è½®è¯¢ä»»åŠ¡çŠ¶æ€
   */
  private async pollTaskStatus(taskId: string): Promise<any> {
    for (let attempt = 1; attempt <= this.MAX_POLL_ATTEMPTS; attempt++) {
      console.log(`[HeyGen] Polling attempt ${attempt}/${this.MAX_POLL_ATTEMPTS}`);

      try {
        const statusResponse = await fetch(
          `https://api.heygen.com/v1/video_status.get?video_id=${taskId}`,
          {
            headers: {
              'X-Api-Key': this.credentials.apiKey
            }
          }
        );

        const status = await statusResponse.json();

        if (status.data?.status === 'completed') {
          console.log(`[HeyGen] Task completed: ${taskId}`);
          return { success: true, data: status.data };
        }

        if (status.data?.status === 'failed') {
          return {
            success: false,
            error: status.data?.error || 'Video generation failed'
          };
        }

        // ç»§ç»­è½®è¯¢
        await this.sleep(this.POLL_INTERVAL);

      } catch (error) {
        console.error(`[HeyGen] Poll error:`, error);
        if (attempt === this.MAX_POLL_ATTEMPTS) {
          return {
            success: false,
            error: `Polling timeout after ${this.MAX_POLL_ATTEMPTS} attempts`
          };
        }
      }
    }

    return {
      success: false,
      error: 'Task timeout'
    };
  }

  /**
   * å¤„ç†å¤šèµ„æºå“åº”
   */
  private async processResources(data: any): Promise<any> {
    const uploadResults: any[] = [];

    // å¤„ç†è§†é¢‘
    if (data.video_url) {
      const videoResult = await this.uploadResource(data.video_url, {
        type: 'video',
        provider: 'heygen',
        method: 'create_video'
      });
      uploadResults.push({ ...videoResult, resourceType: 'video' });
    }

    // å¤„ç†ç¼©ç•¥å›¾
    if (data.thumbnail_url) {
      const thumbnailResult = await this.uploadResource(data.thumbnail_url, {
        type: 'image',
        provider: 'heygen',
        method: 'create_video'
      });
      uploadResults.push({ ...thumbnailResult, resourceType: 'thumbnail' });
    }

    // å¤„ç† GIF
    if (data.gif_url) {
      const gifResult = await this.uploadResource(data.gif_url, {
        type: 'image',
        provider: 'heygen',
        method: 'create_video'
      });
      uploadResults.push({ ...gifResult, resourceType: 'gif' });
    }

    return {
      success: true,
      uploadResults,
      data: {
        duration: data.duration,
        resolution: data.resolution
      }
    };
  }

  /**
   * ä¸Šä¼ å•ä¸ªèµ„æº
   */
  private async uploadResource(url: string, metadata: any): Promise<any> {
    // ä¸‹è½½æ–‡ä»¶
    const response = await fetch(url);
    const buffer = Buffer.from(await response.arrayBuffer());

    // ä¿å­˜åˆ°æœ¬åœ°
    const extension = url.split('.').pop()?.split('?')[0] || 'mp4';
    const localPath = `./output/${metadata.provider}_${Date.now()}.${extension}`;
    await fs.writeFile(localPath, buffer);

    // ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡
    const uploadResult = await this.resourceUploader.uploadFile(localPath, {
      ...metadata,
      mimeType: response.headers.get('content-type') || 'video/mp4'
    });

    return {
      ...uploadResult,
      localPath
    };
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### æ­¥éª¤ 3: é›†æˆåˆ° Tool Registry

```typescript
// apps/api/src/modules/tool/tool-registry.factory.ts
import { HeyGenHandler } from './handlers/heygen-handler';

export class ToolRegistryFactory {
  /**
   * æ ¹æ® toolsetKey åˆ›å»ºåˆé€‚çš„ Handler
   */
  createHandler(toolsetKey: string, methodConfig: ToolMethodConfig, credentials: any): any {
    // æ ¹æ®ä¸åŒçš„å·¥å…·é›†ä½¿ç”¨ä¸åŒçš„ Handler
    switch (toolsetKey) {
      case 'heygen':
        return new HeyGenHandler({
          endpoint: methodConfig.endpoint,
          credentials: this.resolveCredentials(credentials),
          prismaService: this.prismaService,
          miscService: this.miscService,
          user: this.user
        });

      case 'fish-audio':
        return new FishAudioHandler({
          endpoint: methodConfig.endpoint,
          credentials: this.resolveCredentials(credentials),
          prismaService: this.prismaService,
          miscService: this.miscService,
          user: this.user
        });

      default:
        // é»˜è®¤ä½¿ç”¨é€šç”¨ HttpHandler
        return new HttpHandler({
          endpoint: methodConfig.endpoint,
          credentials: this.resolveCredentials(credentials),
          resourceFields: this.extractResourceFields(JSON.parse(methodConfig.schema)),
          responseSchema: JSON.parse(methodConfig.responseSchema),
          resourceResolver: this.createResourceResolver(),
          resourceUploader: this.createResourceUploader()
        });
    }
  }
}
```

### æ­¥éª¤ 4: å“åº”æ ¼å¼åŒ–

```typescript
// apps/api/src/modules/tool/formatters/heygen-formatter.ts
export class HeyGenResponseFormatter {
  static format(response: any): string {
    if (!response.success) {
      return `âŒ è§†é¢‘ç”Ÿæˆå¤±è´¥

é”™è¯¯ä¿¡æ¯: ${response.error}

è¯·æ£€æŸ¥è¾“å…¥å‚æ•°æˆ–ç¨åé‡è¯•ã€‚`;
    }

    const uploadResults = response.uploadResults || [];
    const videoResult = uploadResults.find((r: any) => r.resourceType === 'video');
    const thumbnailResult = uploadResults.find((r: any) => r.resourceType === 'thumbnail');
    const gifResult = uploadResults.find((r: any) => r.resourceType === 'gif');

    return `ğŸ¬ AI è§†é¢‘ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - è§†é¢‘ID: ${videoResult?.entityId || 'N/A'}
  - æ—¶é•¿: ${response.data?.duration || 'N/A'}ç§’
  - åˆ†è¾¨ç‡: ${response.data?.resolution || 'N/A'}

ğŸ¥ è§†é¢‘é“¾æ¥:
  ${videoResult?.url || 'N/A'}

${thumbnailResult ? `ğŸ–¼ï¸ ç¼©ç•¥å›¾:\n  ${thumbnailResult.url}\n` : ''}
${gifResult ? `ğŸï¸ é¢„è§ˆ GIF:\n  ${gifResult.url}\n` : ''}

ğŸ’¡ æç¤º: è§†é¢‘å·²ä¸Šä¼ åˆ°èµ„æºåº“ï¼Œå¯ç›´æ¥åœ¨é¡¹ç›®ä¸­ä½¿ç”¨ã€‚`;
  }
}
```

### æ­¥éª¤ 5: Agent é›†æˆ

```typescript
// apps/api/src/modules/agent/media-agent.service.ts
import { Injectable } from '@nestjs/common';
import { ToolRegistryCache } from '../tool/tool-registry-cache.service';

@Injectable()
export class MediaAgentService {
  constructor(
    private readonly toolRegistryCache: ToolRegistryCache
  ) {}

  async createAgent(user: User) {
    // è·å–æ‰€æœ‰å¯ç”¨å·¥å…·ï¼ˆåŒ…æ‹¬ HeyGenï¼‰
    const tools = await this.toolRegistryCache.getAllTools(user);

    console.log(`[MediaAgent] Loaded ${tools.length} tools:`, tools.map(t => t.name));

    const llm = new ChatOpenAI({
      modelName: 'gpt-4',
      temperature: 0
    });

    const agent = await createStructuredChatAgent({
      llm,
      tools,
      prompt: await pull('hwchase17/structured-chat-agent')
    });

    return new AgentExecutor({
      agent,
      tools,
      verbose: true,
      maxIterations: 5
    });
  }
}
```

### æ­¥éª¤ 6: æµ‹è¯•

```typescript
// apps/api/src/modules/agent/__tests__/heygen-integration.test.ts
describe('HeyGen Integration', () => {
  it('should generate video with text script', async () => {
    const agent = await createMediaAgent(testUser);

    const result = await agent.invoke({
      input: 'å¸®æˆ‘ç”Ÿæˆä¸€ä¸ªè¥é”€è§†é¢‘ï¼Œå†…å®¹æ˜¯ï¼š"æ¬¢è¿æ¥åˆ° Refly AIï¼Œæ‚¨çš„æ™ºèƒ½åˆ›ä½œåŠ©æ‰‹ã€‚æˆ‘ä»¬æä¾›æœ€å…ˆè¿›çš„ AI å·¥å…·ï¼ŒåŠ©åŠ›æ‚¨çš„åˆ›ä½œä¹‹æ—…ã€‚"ä½¿ç”¨ä¸“ä¸šçš„å¥³æ€§å½¢è±¡ã€‚'
    });

    expect(result.output).toContain('è§†é¢‘ç”ŸæˆæˆåŠŸ');
    expect(result.output).toContain('è§†é¢‘é“¾æ¥');
  });

  it('should handle custom avatar upload', async () => {
    // å…ˆä¸Šä¼ æµ‹è¯•ç…§ç‰‡
    const uploadResult = await uploadTestImage('portrait.jpg');

    const agent = await createMediaAgent(testUser);

    const result = await agent.invoke({
      input: `ä½¿ç”¨å®ä½“ ID ${uploadResult.entityId} çš„ç…§ç‰‡åˆ›å»ºæ•°å­—äººï¼Œæœ—è¯»ï¼š"å¤§å®¶å¥½ï¼Œæˆ‘æ˜¯ Refly AI çš„åˆ›å§‹äººã€‚"`
    });

    expect(result.output).toContain('è§†é¢‘ç”ŸæˆæˆåŠŸ');
  });

  it('should handle errors gracefully', async () => {
    const agent = await createMediaAgent(testUser);

    const result = await agent.invoke({
      input: 'ç”Ÿæˆä¸€ä¸ª 10 å°æ—¶çš„è§†é¢‘'  // è¶…è¿‡é™åˆ¶
    });

    expect(result.output).toContain('å¤±è´¥');
    expect(result.output).toContain('å‚æ•°');
  });
});
```

### æ­¥éª¤ 7: çƒ­æ›´æ–°æµ‹è¯•

```typescript
// åŠ¨æ€è°ƒæ•´é…ç½®ï¼ˆæ— éœ€é‡å¯æœåŠ¡ï¼‰
await prisma.toolset.update({
  where: { key: 'heygen' },
  data: {
    config: JSON.stringify({
      ...config,
      methods: [
        ...config.methods,
        {
          name: 'create_video_batch',
          description: 'Batch create multiple videos',
          endpoint: 'https://api.heygen.com/v2/video/generate/batch',
          // ... schema
        }
      ]
    })
  }
});

// 30 ç§’å†…è‡ªåŠ¨ç”Ÿæ•ˆ
// ä¸‹æ¬¡åˆ›å»º Agent æ—¶ä¼šåŒ…å«æ–°å·¥å…· heygen_com__create_video_batch
```

### å…³é”®è¦ç‚¹æ€»ç»“

#### âœ… æœ€ä½³å®è·µ

1. **è‡ªå®šä¹‰ Handler**
   - ç»§æ‰¿ `BaseHttpHandler`
   - é‡å†™ç‰¹å®šæ–¹æ³•ï¼ˆå¦‚ `handle()` ç”¨äºè½®è¯¢ï¼‰
   - ä¿æŒæ¥å£ä¸€è‡´æ€§

2. **å“åº”æ ¼å¼åŒ–**
   - åˆ›å»ºä¸“é—¨çš„ Formatter ç±»
   - æ ¹æ®èµ„æºç±»å‹å®šåˆ¶è¾“å‡º
   - æä¾›ç”¨æˆ·å‹å¥½çš„ä¿¡æ¯

3. **é”™è¯¯å¤„ç†**
   - ä½¿ç”¨ `ToolErrorHandler.withRetry()`
   - æä¾›è¯¦ç»†çš„é”™è¯¯ä¸Šä¸‹æ–‡
   - åŒºåˆ†ä¸åŒé”™è¯¯ç±»å‹

4. **èµ„æºç®¡ç†**
   - æ”¯æŒå¤šèµ„æºå“åº”
   - è‡ªåŠ¨ä¸Šä¼ åˆ°å­˜å‚¨æœåŠ¡
   - åˆ›å»ºæ•°æ®åº“è®°å½•

5. **çƒ­æ›´æ–°**
   - é…ç½®å­˜å‚¨åœ¨æ•°æ®åº“
   - MD5 æ£€æµ‹å˜æ›´
   - è‡ªåŠ¨é‡è½½å·¥å…·

#### ğŸ¯ å®é™…æ•ˆæœ

ç”¨æˆ·å¯ä»¥ç›´æ¥é€šè¿‡è‡ªç„¶è¯­è¨€è°ƒç”¨ï¼š

```
User: "å¸®æˆ‘åˆ¶ä½œä¸€ä¸ªäº§å“ä»‹ç»è§†é¢‘ï¼Œå†…å®¹æ˜¯ï¼š'è¿™æ˜¯æˆ‘ä»¬çš„æ–°äº§å“ï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œæ“ä½œç®€å•ã€‚'ä½¿ç”¨ä¸“ä¸šçš„ç”·æ€§å½¢è±¡ï¼Œè¯­é€Ÿç¨å¿«ã€‚"

Agent: ğŸ¬ AI è§†é¢‘ç”ŸæˆæˆåŠŸï¼

ğŸ“ æ–‡ä»¶ä¿¡æ¯:
  - è§†é¢‘ID: video_1234567890
  - æ—¶é•¿: 8ç§’
  - åˆ†è¾¨ç‡: 1080p

ğŸ¥ è§†é¢‘é“¾æ¥:
  https://cdn.example.com/generated/heygen/1234567890.mp4

ğŸ–¼ï¸ ç¼©ç•¥å›¾:
  https://cdn.example.com/generated/heygen/1234567890_thumb.jpg

ğŸ’¡ æç¤º: è§†é¢‘å·²ä¸Šä¼ åˆ°èµ„æºåº“ï¼Œå¯ç›´æ¥åœ¨é¡¹ç›®ä¸­ä½¿ç”¨ã€‚
```

è¿™ä¸ªæ¡ˆä¾‹å±•ç¤ºäº†å®Œæ•´çš„é›†æˆæµç¨‹ï¼ŒåŒ…æ‹¬é…ç½®æŒä¹…åŒ–ã€è‡ªå®šä¹‰ Handlerã€å“åº”æ ¼å¼åŒ–ã€å¼‚å¸¸å¤„ç†å’Œçƒ­æ›´æ–°ç­‰æ‰€æœ‰å…³é”®ç¯èŠ‚ã€‚

---

## æ€»ç»“

### å®Œæ•´çš„æŠ€æœ¯æ ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  User Input                                            â”‚
â”‚  "å¸®æˆ‘ç”Ÿæˆä¸€æ®µè¯­éŸ³"                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LangChain Agent Executor                              â”‚
â”‚  - LLM ç†è§£æ„å›¾                                         â”‚
â”‚  - é€‰æ‹©å·¥å…·                                             â”‚
â”‚  - æå–å‚æ•°                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DynamicStructuredTool                                 â”‚
â”‚  - å®šä¹‰å·¥å…·æ¥å£                                         â”‚
â”‚  - Zod Schema éªŒè¯                                     â”‚
â”‚  - è°ƒç”¨ func (æ¡¥æ¥åˆ° HttpHandler)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  HttpHandler (æœ¬æ–‡æ¡£é‡ç‚¹)                               â”‚
â”‚  - Pre-Handlers (èµ„æºè§£æ)                             â”‚
â”‚  - API è°ƒç”¨ (HTTP Request)                             â”‚
â”‚  - Response å¤„ç† (ä¿å­˜æ–‡ä»¶)                            â”‚
â”‚  - Post-Handlers (èµ„æºä¸Šä¼ )                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  External API                                          â”‚
â”‚  Fish Audio / Replicate / OpenAI / etc.                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Result                                                â”‚
â”‚  æ ¼å¼åŒ–è¾“å‡º â†’ LLM â†’ ç”¨æˆ·å‹å¥½çš„å›å¤                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å…³é”®è¦ç‚¹

1. **HttpHandler ä¸æ˜¯ç‹¬ç«‹ç³»ç»Ÿ** - å®ƒæ˜¯ LangChain å·¥å…·ç³»ç»Ÿçš„æ‰§è¡Œå±‚
2. **DynamicStructuredTool æ˜¯æ¡¥æ¢** - è¿æ¥ LangChain å’Œ HttpHandler
3. **é…ç½®é©±åŠ¨** - é€šè¿‡ JSON é…ç½®æ‰¹é‡æ³¨å†Œå·¥å…·
4. **ç±»å‹å®‰å…¨** - Zod + TypeScript å®Œæ•´ç±»å‹æ”¯æŒ
5. **é”™è¯¯å®¹é”™** - å¤šå±‚é”™è¯¯å¤„ç†ï¼Œä¼˜é›…é™çº§

---

## å·¥å…·çƒ­æ›´æ–°æœºåˆ¶

### ä¸ºä»€ä¹ˆéœ€è¦çƒ­æ›´æ–°ï¼Ÿ

åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œå·¥å…·é…ç½®å¯èƒ½éœ€è¦é¢‘ç¹è°ƒæ•´ï¼š

- âœ… **æ·»åŠ æ–°å·¥å…·** - æ— éœ€é‡å¯æœåŠ¡
- âœ… **ä¿®æ”¹å·¥å…·å‚æ•°** - API Keyã€Endpoint ç­‰é…ç½®å˜æ›´
- âœ… **è°ƒæ•´å·¥å…·è¡Œä¸º** - Schemaã€Description ä¼˜åŒ–
- âœ… **ç¦ç”¨é—®é¢˜å·¥å…·** - å¿«é€Ÿä¸‹çº¿æœ‰é—®é¢˜çš„å·¥å…·

**ä¼ ç»Ÿæ–¹å¼**ï¼šä¿®æ”¹ä»£ç  â†’ é‡æ–°éƒ¨ç½² â†’ æœåŠ¡é‡å¯ï¼ˆâŒ åœæœºæ—¶é—´é•¿ï¼‰

**çƒ­æ›´æ–°æ–¹å¼**ï¼šä¿®æ”¹æ•°æ®åº“é…ç½® â†’ è‡ªåŠ¨æ£€æµ‹ â†’ åŠ¨æ€é‡è½½ï¼ˆâœ… é›¶åœæœºï¼‰

### æ ¸å¿ƒæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Tool Hot Reload Architecture                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  æ•°æ®åº“ (PostgreSQL)                                       â”‚
â”‚  â”œâ”€ toolsets è¡¨å­˜å‚¨å·¥å…·é…ç½®                                â”‚
â”‚  â””â”€ ç®¡ç†å‘˜æ›´æ–°é…ç½® â†’ updatedAt å˜åŒ–                         â”‚
â”‚                        â†“                                  â”‚
â”‚  ToolConfigWatcher (é…ç½®ç›‘å¬å™¨)                            â”‚
â”‚  â”œâ”€ æ¯ 30 ç§’æ£€æŸ¥ä¸€æ¬¡æ•°æ®åº“                                  â”‚
â”‚  â”œâ”€ è®¡ç®—é…ç½® MD5 å“ˆå¸Œ                                       â”‚
â”‚  â”œâ”€ ä¸ Redis ç¼“å­˜çš„ MD5 å¯¹æ¯”                                â”‚
â”‚  â””â”€ æ£€æµ‹åˆ°å˜åŒ– â†’ è§¦å‘ config-changed äº‹ä»¶                   â”‚
â”‚                        â†“                                  â”‚
â”‚  ToolRegistryCache (å·¥å…·ç¼“å­˜)                              â”‚
â”‚  â”œâ”€ æ¸…é™¤æ—§å·¥å…·ç¼“å­˜                                          â”‚
â”‚  â”œâ”€ é‡æ–°åˆ›å»º DynamicToolRegistry                           â”‚
â”‚  â”œâ”€ ç”Ÿæˆæ–°çš„ DynamicStructuredTool[]                       â”‚
â”‚  â””â”€ ç¼“å­˜æ–°å·¥å…·å®ä¾‹ (SingleFlight æ¨¡å¼)                      â”‚
â”‚                        â†“                                  â”‚
â”‚  Agent ä½¿ç”¨æœ€æ–°å·¥å…·                                         â”‚
â”‚  â””â”€ getAllTools(user) è¿”å›çƒ­æ›´æ–°åçš„å·¥å…·                    â”‚
â”‚                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®ç°ç¤ºä¾‹

#### 1. å¯ç”¨çƒ­æ›´æ–°æœåŠ¡

```typescript
// tool.module.ts
import { Module } from '@nestjs/common';
import { ToolHotReloadService } from './tool-hot-reload.service';

@Module({
  providers: [ToolHotReloadService],
  exports: [ToolHotReloadService]
})
export class ToolModule {}
```

#### 2. åœ¨ Agent Service ä¸­ä½¿ç”¨

```typescript
// media-agent.service.ts
import { Injectable } from '@nestjs/common';
import { ToolHotReloadService } from './tool-hot-reload.service';

@Injectable()
export class MediaAgentService {
  constructor(
    private readonly toolHotReloadService: ToolHotReloadService
  ) {}

  async createAgent(user: User) {
    // è·å–å·¥å…·ï¼ˆè‡ªåŠ¨ä½¿ç”¨æœ€æ–°é…ç½®ï¼‰
    const tools = await this.toolHotReloadService.getAllTools(user);

    // tools æ•°ç»„å·²ç»æ˜¯æœ€æ–°çš„é…ç½®ç”Ÿæˆçš„
    console.log(`Loaded ${tools.length} tools (auto-updated)`);

    const llm = new ChatOpenAI({ modelName: 'gpt-4' });

    const agent = await createStructuredChatAgent({
      llm,
      tools,  // âœ… ä½¿ç”¨çƒ­æ›´æ–°åçš„å·¥å…·
      prompt: await pull('hwchase17/structured-chat-agent')
    });

    return new AgentExecutor({ agent, tools });
  }
}
```

#### 3. é…ç½®æ›´æ–°æµç¨‹

```typescript
// ç®¡ç†å‘˜æ›´æ–°é…ç½®ï¼ˆé€šè¿‡ Admin API æˆ–ç›´æ¥æ“ä½œæ•°æ®åº“ï¼‰
await prisma.toolset.update({
  where: { key: 'fish-audio' },
  data: {
    configJson: JSON.stringify({
      toolsetKey: 'fish-audio',
      methods: [
        {
          name: 'text_to_speech',
          description: 'æ–°çš„æè¿°...',  // â† ä¿®æ”¹æè¿°
          schema: { /* æ–°çš„ schema */ }  // â† ä¿®æ”¹å‚æ•°
        }
      ]
    })
  }
});

// 30 ç§’å†…è‡ªåŠ¨æ£€æµ‹å¹¶é‡è½½
// â†“
// [ToolConfigWatcher] Config changed for toolset: fish-audio
// [ToolRegistryCache] Reloading tools for fish-audio
// [ToolRegistryCache] Loaded 3 tools for fish-audio
// âœ… ä¸‹æ¬¡åˆ›å»º Agent æ—¶è‡ªåŠ¨ä½¿ç”¨æ–°å·¥å…·
```

### å˜æ›´æ£€æµ‹æœºåˆ¶

#### MD5 å“ˆå¸Œå¯¹æ¯”

```typescript
// 1. è®¡ç®—å½“å‰é…ç½®çš„ MD5
const currentMd5 = crypto
  .createHash('md5')
  .update(toolset.configJson)
  .digest('hex');

// 2. ä» Redis è·å–ç¼“å­˜çš„ MD5
const cachedMd5 = await redis.get(`toolset:md5:${toolset.key}`);

// 3. å¯¹æ¯”
if (currentMd5 !== cachedMd5) {
  console.log('Config changed!');

  // æ›´æ–° Redis
  await redis.set(`toolset:md5:${toolset.key}`, currentMd5);

  // è§¦å‘é‡è½½
  this.emit('config-changed', { toolsetKey: toolset.key });
}
```

### SingleFlight æ¨¡å¼

é˜²æ­¢å¹¶å‘è¯·æ±‚é‡å¤åŠ è½½å·¥å…·ï¼š

```typescript
class ToolRegistryCache {
  private loadingPromises = new Map<string, Promise<Tool[]>>();

  async getTools(toolsetKey: string) {
    // 1. æ£€æŸ¥æ˜¯å¦æ­£åœ¨åŠ è½½
    if (this.loadingPromises.has(toolsetKey)) {
      console.log('Waiting for ongoing load...');
      return this.loadingPromises.get(toolsetKey);
    }

    // 2. å¼€å§‹åŠ è½½
    const promise = this.loadTools(toolsetKey);
    this.loadingPromises.set(toolsetKey, promise);

    try {
      return await promise;
    } finally {
      // 3. æ¸…é™¤ loading çŠ¶æ€
      this.loadingPromises.delete(toolsetKey);
    }
  }
}
```

**å¥½å¤„ï¼š**
- âœ… å¤šä¸ªè¯·æ±‚åŒæ—¶åˆ°è¾¾ï¼ŒåªåŠ è½½ä¸€æ¬¡
- âœ… é¿å…é‡å¤çš„æ•°æ®åº“æŸ¥è¯¢
- âœ… å‡å°‘ Redis å‹åŠ›

### ç®¡ç†æ¥å£

```typescript
// tool-admin.controller.ts
@Controller('api/admin/tools')
export class ToolAdminController {
  /**
   * å¼ºåˆ¶é‡æ–°åŠ è½½å·¥å…·
   */
  @Post(':toolsetKey/reload')
  async reloadToolset(@Param('toolsetKey') toolsetKey: string) {
    await this.toolHotReloadService.forceReload(toolsetKey);
    return { message: `${toolsetKey} reloaded` };
  }

  /**
   * è·å–ç¼“å­˜ä¿¡æ¯
   */
  @Get(':toolsetKey/cache-info')
  getCacheInfo(@Param('toolsetKey') toolsetKey: string) {
    const info = this.toolHotReloadService.getCacheInfo(toolsetKey);
    return {
      toolsetKey,
      md5: info?.md5,
      loadedAt: info?.loadedAt,
      toolCount: info?.tools.length
    };
  }

  /**
   * æŸ¥çœ‹æ‰€æœ‰å·²åŠ è½½çš„å·¥å…·é›†
   */
  @Get('loaded')
  getLoadedToolsets() {
    return {
      toolsets: this.toolHotReloadService.getLoadedToolsets()
    };
  }
}
```

### ä½¿ç”¨åœºæ™¯

#### åœºæ™¯ 1: æ·»åŠ æ–°å·¥å…·æ–¹æ³•

```sql
-- åœ¨æ•°æ®åº“ä¸­æ·»åŠ æ–°æ–¹æ³•
UPDATE toolsets
SET configJson = jsonb_set(
  configJson::jsonb,
  '{methods}',
  configJson::jsonb->'methods' || '[{
    "name": "voice_cloning_v2",
    "description": "New voice cloning method",
    ...
  }]'::jsonb
)
WHERE key = 'fish-audio';

-- âœ… 30 ç§’å†…è‡ªåŠ¨ç”Ÿæ•ˆ
-- ä¸‹æ¬¡ Agent åˆ›å»ºæ—¶ä¼šåŒ…å«æ–°å·¥å…· fish_audio__voice_cloning_v2
```

#### åœºæ™¯ 2: ä¿®æ”¹ API Key

```sql
UPDATE toolsets
SET configJson = jsonb_set(
  configJson::jsonb,
  '{credentials,apiKey}',
  '"new_api_key_here"'::jsonb
)
WHERE key = 'fish-audio';

-- âœ… è‡ªåŠ¨é‡è½½ï¼Œæ–°å·¥å…·ä½¿ç”¨æ–° API Key
```

#### åœºæ™¯ 3: ç¦ç”¨å·¥å…·é›†

```sql
UPDATE toolsets
SET enabled = false
WHERE key = 'problematic-tool';

-- âœ… ä¸‹æ¬¡è·å–å·¥å…·æ—¶è‡ªåŠ¨æ’é™¤
```

### æ€§èƒ½ä¼˜åŒ–

#### 1. æ‰¹é‡æ£€æŸ¥ï¼ˆå‡å°‘æ•°æ®åº“æŸ¥è¯¢ï¼‰

```typescript
// âœ… ä¸€æ¬¡æŸ¥è¯¢æ‰€æœ‰å·¥å…·é›†
const toolsets = await prisma.toolset.findMany({
  where: { enabled: true }
});

// å¹¶è¡Œæ£€æŸ¥
await Promise.all(toolsets.map(t => checkToolsetChange(t)));
```

#### 2. Redis Pipelineï¼ˆæ‰¹é‡è·å– MD5ï¼‰

```typescript
// âœ… ä½¿ç”¨ Pipeline æ‰¹é‡è·å–
const pipeline = redis.pipeline();
toolsets.forEach(t => pipeline.get(`toolset:md5:${t.key}`));
const md5s = await pipeline.exec();
```

#### 3. å»¶è¿ŸåŠ è½½

```typescript
// âœ… åªåœ¨éœ€è¦æ—¶åŠ è½½å·¥å…·
async getTools(toolsetKey: string) {
  // ä¸åœ¨å¯åŠ¨æ—¶å…¨éƒ¨åŠ è½½ï¼Œè€Œæ˜¯æŒ‰éœ€åŠ è½½
  return this.cache.getTools(toolsetKey);
}
```

### ç›‘æ§æŒ‡æ ‡

```typescript
// GET /api/admin/tools/metrics
{
  "loadedToolsets": 5,           // å·²åŠ è½½çš„å·¥å…·é›†æ•°é‡
  "totalTools": 23,              // æ€»å·¥å…·æ•°
  "lastCheckTime": "2025-01-14T10:30:00Z",
  "cacheHitRate": 0.95,          // ç¼“å­˜å‘½ä¸­ç‡
  "toolsets": [
    {
      "key": "fish-audio",
      "md5": "abc123...",
      "loadedAt": "2025-01-14T10:00:00Z",
      "toolCount": 3
    }
  ]
}
```

### é”™è¯¯å¤„ç†

```typescript
// é‡è½½å¤±è´¥æ—¶ä¿æŒæ—§ç‰ˆæœ¬å¯ç”¨
this.watcher.on('config-changed', async (event) => {
  try {
    await this.cache.reloadTools(event.toolsetKey);
    console.log(`âœ… Reloaded: ${event.toolsetKey}`);
  } catch (error) {
    console.error(`âŒ Failed to reload: ${event.toolsetKey}`, error);

    // âœ… ä¸æ¸…é™¤æ—§ç¼“å­˜ï¼Œç»§ç»­ä½¿ç”¨æ—§å·¥å…·
    // âœ… å‘é€å‘Šè­¦é€šçŸ¥ç®¡ç†å‘˜
    await this.sendAlert({
      type: 'tool-reload-failed',
      toolsetKey: event.toolsetKey,
      error: error.message
    });
  }
});
```

### å®Œæ•´æµç¨‹å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Tool Hot Reload Flow                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1ï¸âƒ£  ç®¡ç†å‘˜æ›´æ–°é…ç½®                                          â”‚
â”‚     UPDATE toolsets SET configJson = '...'                  â”‚
â”‚                        â†“                                    â”‚
â”‚  2ï¸âƒ£  ToolConfigWatcher å®šæœŸæ£€æŸ¥ (30s)                        â”‚
â”‚     - ä»æ•°æ®åº“åŠ è½½é…ç½®                                       â”‚
â”‚     - è®¡ç®— MD5: abc123                                      â”‚
â”‚     - Redis è·å–ç¼“å­˜ MD5: xyz789                             â”‚
â”‚     - å¯¹æ¯”: abc123 â‰  xyz789 â†’ é…ç½®å˜æ›´ï¼                     â”‚
â”‚                        â†“                                    â”‚
â”‚  3ï¸âƒ£  è§¦å‘ config-changed äº‹ä»¶                                â”‚
â”‚     emit('config-changed', { toolsetKey, config, md5 })     â”‚
â”‚                        â†“                                    â”‚
â”‚  4ï¸âƒ£  ToolRegistryCache é‡è½½                                  â”‚
â”‚     - cache.delete(toolsetKey)  // æ¸…é™¤æ—§ç¼“å­˜                â”‚
â”‚     - registry = new DynamicToolRegistry(config)            â”‚
â”‚     - tools = registry.registerTools()                      â”‚
â”‚     - cache.set(toolsetKey, tools)  // ç¼“å­˜æ–°å·¥å…·            â”‚
â”‚                        â†“                                    â”‚
â”‚  5ï¸âƒ£  æ›´æ–° Redis MD5                                          â”‚
â”‚     SET toolset:md5:fish-audio "abc123"                     â”‚
â”‚                        â†“                                    â”‚
â”‚  6ï¸âƒ£  Agent ä½¿ç”¨æ–°å·¥å…·                                         â”‚
â”‚     const tools = await getAllTools(user);                  â”‚
â”‚     // è¿”å›çƒ­æ›´æ–°åçš„å·¥å…·                                     â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æœ€ä½³å®è·µ

1. **è®¾ç½®åˆç†çš„æ£€æŸ¥é—´éš”**
   ```typescript
   // âœ… 30 ç§’æ˜¯ä¸€ä¸ªå¹³è¡¡ç‚¹
   checkIntervalMs: 30000  // ä¸è¦å¤ªé¢‘ç¹ï¼Œé¿å…æ•°æ®åº“å‹åŠ›
   ```

2. **ä½¿ç”¨ Redis ç¼“å­˜**
   ```typescript
   // âœ… ç¼“å­˜ MD5ï¼Œå‡å°‘è®¡ç®—å¼€é”€
   await redis.set(`toolset:md5:${key}`, md5, 'EX', 86400);
   ```

3. **ç›‘æ§é‡è½½äº‹ä»¶**
   ```typescript
   // âœ… è®°å½•æ¯æ¬¡é‡è½½
   console.log('[HotReload]', {
     timestamp: new Date(),
     toolsetKey,
     toolCount,
     duration: Date.now() - startTime
   });
   ```

4. **æä¾›æ‰‹åŠ¨é‡è½½æ¥å£**
   ```typescript
   // âœ… è®©ç®¡ç†å‘˜å¯ä»¥ç«‹å³è§¦å‘é‡è½½
   @Post('tools/:key/reload')
   async forceReload(@Param('key') key: string) {
     await this.toolHotReloadService.forceReload(key);
   }
   ```

---

## å·¥å…·é…ç½®æŒä¹…åŒ–è¡¨è®¾è®¡

### æ•°æ®åº“è¡¨ç»“æ„

é‡‡ç”¨**åŒè¡¨è®¾è®¡**ï¼Œå°†å·¥å…·é›†å…ƒæ•°æ®å’Œæ–¹æ³•é…ç½®åˆ†ç¦»ï¼Œæ”¯æŒç‰ˆæœ¬æ§åˆ¶å’Œrollbackã€‚

#### è¡¨ 1: Toolsets (å·¥å…·é›†å…ƒæ•°æ®)

```prisma
model Toolset {
  /// Primary key
  pk            Int       @id @default(autoincrement())
  /// Toolset ID (UUID)
  toolsetId     String    @unique @map("toolset_id")
  /// Whether the toolset is global (available in tool store)
  isGlobal      Boolean   @default(false) @map("is_global")
  /// User ID (null for global toolsets)
  uid           String?   @map("uid")
  /// Toolset name
  name          String    @map("name")
  /// Toolset key (unique identifier, e.g., "fish-audio")
  key           String    @map("key")
  /// Toolset domain (e.g., "fish.audio")
  domain        String?   @map("domain")
  /// Auth type: credentials, oauth
  authType      String?   @default("credentials") @map("auth_type")
  /// Auth data (encrypted credentials)
  authData      String?   @map("auth_data")
  /// Whether the toolset is enabled
  enabled       Boolean   @default(true) @map("enabled")
  /// Whether the toolset is uninstalled by user
  uninstalled   Boolean   @default(false) @map("uninstalled")
  /// Credit billing configuration (JSON)
  creditBilling String?   @map("credit_billing")
  /// Current active version ID
  activeVersionId String? @map("active_version_id")
  /// Create timestamp
  createdAt     DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  /// Update timestamp (used for hot reload detection)
  updatedAt     DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  /// Deletion timestamp (soft delete)
  deletedAt     DateTime? @map("deleted_at") @db.Timestamptz()

  // Relations
  methods       ToolMethod[]
  versions      ToolsetVersion[]

  @@index([uid, isGlobal, deletedAt])
  @@index([key, enabled])
  @@index([activeVersionId])
  @@map("toolsets")
}
```

#### è¡¨ 2: Tool Methods (æ–¹æ³•é…ç½®)

```prisma
model ToolMethod {
  /// Primary key
  pk              Int       @id @default(autoincrement())
  /// Method ID (UUID)
  methodId        String    @unique @map("method_id")
  /// Toolset ID (foreign key)
  toolsetId       String    @map("toolset_id")
  /// Version ID (for version control)
  versionId       String    @map("version_id")
  /// Method name (unique within toolset version)
  name            String    @map("name")
  /// Method description (for LLM understanding)
  description     String    @map("description")
  /// API endpoint full URL
  endpoint        String    @map("endpoint")
  /// HTTP method (GET, POST, PUT, DELETE, PATCH)
  httpMethod      String    @default("POST") @map("http_method")
  /// Request schema (JSON string)
  requestSchema   String    @map("request_schema") @db.Text
  /// Response schema (JSON string)
  responseSchema  String    @map("response_schema") @db.Text
  /// Adapter type (http, sdk)
  adapterType     String    @default("http") @map("adapter_type")
  /// Adapter config (JSON string, optional SDK-specific config)
  adapterConfig   String?   @map("adapter_config") @db.Text
  /// Whether the method is enabled
  enabled         Boolean   @default(true) @map("enabled")
  /// Method order (for display sorting)
  order           Int       @default(0) @map("order")
  /// Create timestamp
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  /// Update timestamp
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  /// Deletion timestamp (soft delete)
  deletedAt       DateTime? @map("deleted_at") @db.Timestamptz()

  // Relations
  toolset         Toolset   @relation(fields: [toolsetId], references: [toolsetId], onDelete: Cascade)

  @@unique([toolsetId, versionId, name])
  @@index([toolsetId, versionId, enabled])
  @@index([versionId])
  @@map("tool_methods")
}
```

#### è¡¨ 3: Toolset Versions (ç‰ˆæœ¬ç®¡ç†)

```prisma
model ToolsetVersion {
  /// Primary key
  pk          Int       @id @default(autoincrement())
  /// Version ID (UUID)
  versionId   String    @unique @map("version_id")
  /// Toolset ID (foreign key)
  toolsetId   String    @map("toolset_id")
  /// Version number (semantic versioning, e.g., "1.0.0")
  version     String    @map("version")
  /// Version description/changelog
  description String?   @map("description")
  /// Whether this version is active
  isActive    Boolean   @default(false) @map("is_active")
  /// Created by user ID
  createdBy   String?   @map("created_by")
  /// Create timestamp
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  /// Deletion timestamp (soft delete)
  deletedAt   DateTime? @map("deleted_at") @db.Timestamptz()

  // Relations
  toolset     Toolset   @relation(fields: [toolsetId], references: [toolsetId], onDelete: Cascade)

  @@unique([toolsetId, version])
  @@index([toolsetId, isActive])
  @@map("toolset_versions")
}
```

**å…³é”®å­—æ®µè¯´æ˜ï¼š**

| è¡¨ | å­—æ®µ | ç±»å‹ | è¯´æ˜ |
|------|------|------|------|
| **Toolset** | `key` | String | å·¥å…·é›†æ ‡è¯†ç¬¦ï¼ˆå¦‚ "fish-audio"ï¼‰ |
| | `name` | String | å·¥å…·é›†åç§°ï¼ˆå•è¯­è¨€ï¼‰ |
| | `domain` | String? | å·¥å…·é›†åŸŸåï¼ˆç”¨äº faviconï¼‰ |
| | `isGlobal` | Boolean | æ˜¯å¦ä¸ºå…¨å±€å·¥å…·ï¼ˆå·¥å…·å•†åº—å¯è§ï¼‰ |
| | `authType` | String | è®¤è¯ç±»å‹ï¼šcredentials æˆ– oauth |
| | `authData` | String? | åŠ å¯†çš„è®¤è¯æ•°æ® |
| | **`activeVersionId`** | **String?** | **å½“å‰æ¿€æ´»çš„ç‰ˆæœ¬ ID** |
| | `enabled` | Boolean | æ˜¯å¦å¯ç”¨ |
| | `updatedAt` | DateTime | æ›´æ–°æ—¶é—´ï¼ˆçƒ­æ›´æ–°ç›‘å¬ï¼‰ |
| **ToolMethod** | `methodId` | String | æ–¹æ³• ID (UUID) |
| | `toolsetId` | String | å·¥å…·é›† ID (å¤–é”®) |
| | **`versionId`** | **String** | **ç‰ˆæœ¬ ID (ç”¨äºç‰ˆæœ¬æ§åˆ¶)** |
| | `name` | String | æ–¹æ³•åç§° |
| | `description` | String | æ–¹æ³•æè¿° (LLM ä½¿ç”¨) |
| | `endpoint` | String | API ç«¯ç‚¹å®Œæ•´ URL |
| | `httpMethod` | String | HTTP æ–¹æ³• (GET/POSTç­‰) |
| | **`requestSchema`** | **String** | **è¯·æ±‚å‚æ•° Schema (JSON)** |
| | **`responseSchema`** | **String** | **å“åº” Schema (JSON)** |
| | `adapterType` | String | é€‚é…å™¨ç±»å‹ (http/sdk) |
| | `enabled` | Boolean | æ˜¯å¦å¯ç”¨ |
| | `order` | Int | æ˜¾ç¤ºé¡ºåº |
| **ToolsetVersion** | `versionId` | String | ç‰ˆæœ¬ ID (UUID) |
| | `toolsetId` | String | å·¥å…·é›† ID (å¤–é”®) |
| | `version` | String | ç‰ˆæœ¬å· (å¦‚ "1.0.0") |
| | `description` | String? | ç‰ˆæœ¬æè¿°/æ›´æ–°æ—¥å¿— |
| | `isActive` | Boolean | æ˜¯å¦ä¸ºæ¿€æ´»ç‰ˆæœ¬ |
| | `createdBy` | String? | åˆ›å»ºè€… UID |

---

### TypeScript æ¥å£å®šä¹‰

```typescript
/**
 * å·¥å…·é›†é…ç½®
 */
export interface ToolsetConfig {
  /** å·¥å…·é›† ID */
  toolsetId: string;
  /** å·¥å…·é›† key */
  key: string;
  /** å·¥å…·é›†åç§° */
  name: string;
  /** å·¥å…·é›†åŸŸåï¼ˆç”¨äºæ˜¾ç¤º faviconï¼‰ */
  domain?: string;
  /** æ˜¯å¦ä¸ºå…¨å±€å·¥å…· */
  isGlobal: boolean;
  /** è®¤è¯ç±»å‹ */
  authType?: 'credentials' | 'oauth';
  /** å½“å‰æ¿€æ´»ç‰ˆæœ¬ ID */
  activeVersionId?: string;
  /** æ˜¯å¦å¯ç”¨ */
  enabled: boolean;
}

/**
 * å·¥å…·æ–¹æ³•é…ç½®
 */
export interface ToolMethodConfig {
  /** æ–¹æ³• ID */
  methodId: string;
  /** å·¥å…·é›† ID */
  toolsetId: string;
  /** ç‰ˆæœ¬ ID */
  versionId: string;
  /** æ–¹æ³•åç§° */
  name: string;
  /** æ–¹æ³•æè¿° (LLM ç”¨äºç†è§£å·¥å…·ç”¨é€”) */
  description: string;
  /** API ç«¯ç‚¹å®Œæ•´ URL */
  endpoint: string;
  /** HTTP æ–¹æ³• */
  httpMethod: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  /** è¯·æ±‚å‚æ•° Schema (è§£æåçš„å¯¹è±¡) */
  requestSchema: JSONSchema;
  /** å“åº” Schema (è§£æåçš„å¯¹è±¡) */
  responseSchema: JSONSchema;
  /** é€‚é…å™¨ç±»å‹ */
  adapterType: 'http' | 'sdk';
  /** é€‚é…å™¨é…ç½® (å¯é€‰) */
  adapterConfig?: Record<string, unknown>;
  /** æ˜¯å¦å¯ç”¨ */
  enabled: boolean;
  /** æ˜¾ç¤ºé¡ºåº */
  order: number;
}

/**
 * å·¥å…·é›†ç‰ˆæœ¬
 */
export interface ToolsetVersionConfig {
  /** ç‰ˆæœ¬ ID */
  versionId: string;
  /** å·¥å…·é›† ID */
  toolsetId: string;
  /** ç‰ˆæœ¬å· */
  version: string;
  /** ç‰ˆæœ¬æè¿° */
  description?: string;
  /** æ˜¯å¦ä¸ºæ¿€æ´»ç‰ˆæœ¬ */
  isActive: boolean;
  /** åˆ›å»ºè€… UID */
  createdBy?: string;
}

/**
 * JSON Schema ç±»å‹
 */
export interface JSONSchema {
  type: string;
  properties?: Record<string, JSONSchema>;
  required?: string[];
  items?: JSONSchema;
  description?: string;
  // èµ„æºæ ‡è®° (è‡ªå®šä¹‰æ‰©å±•)
  isResource?: boolean;
  resourceType?: 'audio' | 'video' | 'image' | 'document';
  [key: string]: unknown;
}
```

**è®¾è®¡ä¼˜åŠ¿ï¼š**
- âœ… **æ¸…æ™°åˆ†ç¦»**: å·¥å…·é›†å…ƒæ•°æ®ä¸æ–¹æ³•é…ç½®åˆ†ç¦»
- âœ… **ç‰ˆæœ¬æ§åˆ¶**: é€šè¿‡ `versionId` å®ç°å®Œæ•´çš„ç‰ˆæœ¬å†å²
- âœ… **æ˜“äºå›æ»š**: æ›´æ”¹ `activeVersionId` å³å¯åˆ‡æ¢ç‰ˆæœ¬
- âœ… **çµæ´»æ‰©å±•**: æ¯ä¸ªæ–¹æ³•ç‹¬ç«‹é…ç½®ï¼Œæ˜“äºæ·»åŠ /åˆ é™¤
- âœ… **æ€§èƒ½ä¼˜åŒ–**: æ›´å¥½çš„ç´¢å¼•å’ŒæŸ¥è¯¢æ€§èƒ½

---

### Schema æ ¼å¼ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ `requestSchema` å’Œ `responseSchema` çš„ JSON æ ¼å¼ç¤ºä¾‹ï¼š

```json
// requestSchema ç¤ºä¾‹
{
  "type": "object",
  "properties": {
    "text": {
      "type": "string",
      "description": "Text to convert to speech",
      "minLength": 1,
      "maxLength": 1000
    },
    "reference": {
      "type": "object",
      "description": "Optional reference audio for voice cloning",
      "properties": {
        "entityId": {
          "type": "string",
          "description": "Reference audio file entity ID"
        }
      },
      "isResource": true,
      "resourceType": "audio"
    }
  },
  "required": ["text"]
}

// responseSchema ç¤ºä¾‹
{
  "type": "object",
  "properties": {
    "audio": {
      "type": "string",
      "isResource": true,
      "resourceType": "audio"
    },
    "duration": {
      "type": "number"
    }
  }
}
```

---

### æ•°æ®åº“æ“ä½œç¤ºä¾‹

#### 1. åˆ›å»ºå·¥å…·é›†åŠåˆå§‹ç‰ˆæœ¬

```typescript
import { v4 as uuidv4 } from 'uuid';

// Step 1: åˆ›å»º Toolset
const toolsetId = uuidv4();
const versionId = uuidv4();

const toolset = await prisma.toolset.create({
  data: {
    toolsetId,
    key: 'fish-audio',
    name: 'Fish Audio',
    domain: 'fish.audio',
    isGlobal: true,
    authType: 'credentials',
    enabled: true,
    activeVersionId: versionId,
  },
});

// Step 2: åˆ›å»ºåˆå§‹ç‰ˆæœ¬
const version = await prisma.toolsetVersion.create({
  data: {
    versionId,
    toolsetId,
    version: '1.0.0',
    description: 'Initial release',
    isActive: true,
    createdBy: 'admin',
  },
});

// Step 3: åˆ›å»ºæ–¹æ³•
const method = await prisma.toolMethod.create({
  data: {
    methodId: uuidv4(),
    toolsetId,
    versionId,
    name: 'text_to_speech',
    description: 'Convert text to speech using Fish Audio API',
    endpoint: 'https://api.fish.audio/v1/tts',
    httpMethod: 'POST',
    requestSchema: JSON.stringify({
      type: 'object',
      properties: {
        text: {
          type: 'string',
          description: 'Text to convert to speech',
          minLength: 1,
          maxLength: 1000,
        },
        reference: {
          type: 'object',
          description: 'Optional reference audio for voice cloning',
          properties: {
            entityId: {
              type: 'string',
              description: 'Reference audio file entity ID',
            },
          },
          isResource: true,
          resourceType: 'audio',
        },
      },
      required: ['text'],
    }),
    responseSchema: JSON.stringify({
      type: 'object',
      properties: {
        audio: {
          type: 'string',
          isResource: true,
          resourceType: 'audio',
        },
        duration: {
          type: 'number',
        },
      },
    }),
    adapterType: 'http',
    enabled: true,
    order: 0,
  },
});
```

#### 2. æŸ¥è¯¢æ¿€æ´»ç‰ˆæœ¬çš„æ–¹æ³•

```typescript
// æŸ¥è¯¢å·¥å…·é›†åŠå…¶æ¿€æ´»ç‰ˆæœ¬çš„æ–¹æ³•
const toolset = await prisma.toolset.findFirst({
  where: {
    key: 'fish-audio',
    enabled: true,
    deletedAt: null,
  },
  include: {
    methods: {
      where: {
        versionId: toolset.activeVersionId,
        enabled: true,
        deletedAt: null,
      },
      orderBy: {
        order: 'asc',
      },
    },
  },
});

// è§£æ schemas
const methods = toolset.methods.map((method) => ({
  ...method,
  requestSchema: JSON.parse(method.requestSchema),
  responseSchema: JSON.parse(method.responseSchema),
}));

console.log(`Toolset: ${toolset.name}`);
console.log(`Domain: ${toolset.domain}`);
console.log(`Active Version: ${toolset.activeVersionId}`);
console.log(`Methods: ${methods.length}`);
```

#### 3. åˆ›å»ºæ–°ç‰ˆæœ¬ï¼ˆæ·»åŠ æ–°æ–¹æ³•ï¼‰

```typescript
// Step 1: åˆ›å»ºæ–°ç‰ˆæœ¬
const newVersionId = uuidv4();
const newVersion = await prisma.toolsetVersion.create({
  data: {
    versionId: newVersionId,
    toolsetId: 'existing-toolset-id',
    version: '1.1.0',
    description: 'Added voice_cloning method',
    isActive: false, // æš‚ä¸æ¿€æ´»
    createdBy: 'admin',
  },
});

// Step 2: å¤åˆ¶ç°æœ‰æ–¹æ³•åˆ°æ–°ç‰ˆæœ¬
const existingMethods = await prisma.toolMethod.findMany({
  where: {
    toolsetId: 'existing-toolset-id',
    versionId: 'old-version-id',
    deletedAt: null,
  },
});

await Promise.all(
  existingMethods.map((method) =>
    prisma.toolMethod.create({
      data: {
        methodId: uuidv4(),
        toolsetId: method.toolsetId,
        versionId: newVersionId,
        name: method.name,
        description: method.description,
        endpoint: method.endpoint,
        httpMethod: method.httpMethod,
        requestSchema: method.requestSchema,
        responseSchema: method.responseSchema,
        adapterType: method.adapterType,
        adapterConfig: method.adapterConfig,
        enabled: method.enabled,
        order: method.order,
      },
    })
  )
);

// Step 3: æ·»åŠ æ–°æ–¹æ³•
await prisma.toolMethod.create({
  data: {
    methodId: uuidv4(),
    toolsetId: 'existing-toolset-id',
    versionId: newVersionId,
    name: 'voice_cloning',
    description: 'Clone voice from reference audio',
    endpoint: 'https://api.fish.audio/v1/clone',
    httpMethod: 'POST',
    requestSchema: JSON.stringify({
      type: 'object',
      properties: {
        reference: {
          type: 'object',
          properties: {
            entityId: { type: 'string' },
          },
          isResource: true,
          resourceType: 'audio',
        },
      },
      required: ['reference'],
    }),
    responseSchema: JSON.stringify({
      type: 'object',
      properties: {
        voiceId: { type: 'string' },
      },
    }),
    adapterType: 'http',
    enabled: true,
    order: 1,
  },
});
```

#### 4. æ¿€æ´»æ–°ç‰ˆæœ¬ (ç‰ˆæœ¬å‘å¸ƒ)

```typescript
await prisma.$transaction(async (tx) => {
  // å°†æ‰€æœ‰ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
  await tx.toolsetVersion.updateMany({
    where: {
      toolsetId: 'existing-toolset-id',
      isActive: true,
    },
    data: {
      isActive: false,
    },
  });

  // æ¿€æ´»æ–°ç‰ˆæœ¬
  await tx.toolsetVersion.update({
    where: {
      versionId: 'new-version-id',
    },
    data: {
      isActive: true,
    },
  });

  // æ›´æ–° Toolset çš„ activeVersionId
  await tx.toolset.update({
    where: {
      toolsetId: 'existing-toolset-id',
    },
    data: {
      activeVersionId: 'new-version-id',
    },
  });
});
```

#### 5. å›æ»šåˆ°ä¹‹å‰çš„ç‰ˆæœ¬

```typescript
await prisma.$transaction(async (tx) => {
  // è·å–ä¸Šä¸€ä¸ªç‰ˆæœ¬
  const previousVersion = await tx.toolsetVersion.findFirst({
    where: {
      toolsetId: 'existing-toolset-id',
      versionId: 'previous-version-id',
      deletedAt: null,
    },
  });

  if (!previousVersion) {
    throw new Error('Previous version not found');
  }

  // å°†æ‰€æœ‰ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
  await tx.toolsetVersion.updateMany({
    where: {
      toolsetId: 'existing-toolset-id',
      isActive: true,
    },
    data: {
      isActive: false,
    },
  });

  // æ¿€æ´»ä¹‹å‰çš„ç‰ˆæœ¬
  await tx.toolsetVersion.update({
    where: {
      versionId: previousVersion.versionId,
    },
    data: {
      isActive: true,
    },
  });

  // æ›´æ–° Toolset çš„ activeVersionId
  await tx.toolset.update({
    where: {
      toolsetId: 'existing-toolset-id',
    },
    data: {
      activeVersionId: previousVersion.versionId,
      updatedAt: new Date(), // è§¦å‘çƒ­æ›´æ–°
    },
  });
});
```

#### 6. æŸ¥è¯¢ç‰ˆæœ¬å†å²

```typescript
const versions = await prisma.toolsetVersion.findMany({
  where: {
    toolsetId: 'existing-toolset-id',
    deletedAt: null,
  },
  orderBy: {
    createdAt: 'desc',
  },
  include: {
    _count: {
      select: {
        toolset: {
          select: {
            methods: {
              where: {
                versionId: true,
              },
            },
          },
        },
      },
    },
  },
});

console.log('Version History:');
versions.forEach((v) => {
  console.log(`- v${v.version} ${v.isActive ? '(Active)' : ''}`);
  console.log(`  Created: ${v.createdAt}`);
  console.log(`  By: ${v.createdBy}`);
  console.log(`  Description: ${v.description}`);
});
```

---

### çƒ­æ›´æ–°æµç¨‹ (æ”¯æŒç‰ˆæœ¬æ§åˆ¶)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Tool Configuration Hot Reload Flow                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚  1. ç®¡ç†å‘˜åˆ›å»ºæ–°ç‰ˆæœ¬                                         â”‚
â”‚     - åˆ›å»º ToolsetVersion (isActive: false)                 â”‚
â”‚     - å¤åˆ¶ç°æœ‰æ–¹æ³•åˆ°æ–°ç‰ˆæœ¬                                   â”‚
â”‚     - æ·»åŠ /ä¿®æ”¹/åˆ é™¤æ–¹æ³•                                     â”‚
â”‚     â†“                                                       â”‚
â”‚  2. æ¿€æ´»æ–°ç‰ˆæœ¬                                              â”‚
â”‚     - è®¾ç½® isActive: true ç»™æ–°ç‰ˆæœ¬                          â”‚
â”‚     - è®¾ç½® isActive: false ç»™æ—§ç‰ˆæœ¬                         â”‚
â”‚     - æ›´æ–° Toolset.activeVersionId                         â”‚
â”‚     - æ›´æ–° Toolset.updatedAt (è§¦å‘çƒ­æ›´æ–°)                   â”‚
â”‚     â†“                                                       â”‚
â”‚  3. ToolConfigWatcher æ£€æµ‹å˜åŒ–                              â”‚
â”‚     - ç›‘å¬ Toolset.updatedAt                                â”‚
â”‚     - æ£€æµ‹ activeVersionId å˜æ›´                             â”‚
â”‚     â†“                                                       â”‚
â”‚  4. é‡æ–°åŠ è½½å·¥å…·æ–¹æ³•                                         â”‚
â”‚     - æŸ¥è¯¢ WHERE versionId = activeVersionId                â”‚
â”‚     - è§£æ requestSchema å’Œ responseSchema                  â”‚
â”‚     â†“                                                       â”‚
â”‚  5. ç”Ÿæˆ DynamicStructuredTool[]                            â”‚
â”‚     - buildZodSchema(requestSchema)                         â”‚
â”‚     - createAdapter(adapterType, adapterConfig)             â”‚
â”‚     â†“                                                       â”‚
â”‚  6. Agent ä½¿ç”¨æ›´æ–°åçš„å·¥å…·                                   â”‚
â”‚                                                             â”‚
â”‚  å›æ»š:                                                       â”‚
â”‚  - æ›´æ”¹ activeVersionId å›åˆ°ä¹‹å‰çš„ç‰ˆæœ¬                       â”‚
â”‚  - Watcher æ£€æµ‹åˆ°å˜åŒ–å¹¶é‡æ–°åŠ è½½                              â”‚
â”‚                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### å·¥å…·å•†åº—å±•ç¤º

ä½¿ç”¨æ–°çš„åŒè¡¨ç»“æ„æŸ¥è¯¢å·¥å…·å•†åº—æ•°æ®ï¼š

```typescript
// å·¥å…·å•†åº—æŸ¥è¯¢
const toolsets = await prisma.toolset.findMany({
  where: {
    isGlobal: true,
    enabled: true,
    deletedAt: null,
  },
  select: {
    key: true,
    name: true,
    domain: true,
    activeVersionId: true,
  },
});

// æŸ¥è¯¢æ¯ä¸ªå·¥å…·é›†çš„æ–¹æ³•æ•°é‡
const storeItems = await Promise.all(
  toolsets.map(async (toolset) => {
    const methodCount = await prisma.toolMethod.count({
      where: {
        toolsetId: toolset.key,
        versionId: toolset.activeVersionId,
        enabled: true,
        deletedAt: null,
      },
    });

    return {
      key: toolset.key,
      name: toolset.name,
      domain: toolset.domain,
      methodCount,
    };
  })
);
```

**å·¥å…·å•†åº— UI å±•ç¤ºï¼š**
```tsx
<ToolItem>
  <Favicon url={tool.domain} />
  <div>
    <h3>{tool.name}</h3>  {/* ä½¿ç”¨ toolset.name */}
    <p>{tool.methodCount} methods</p>
  </div>
</ToolItem>
```

---

### ç´¢å¼•ä¼˜åŒ–

```sql
-- Toolset è¡¨ç´¢å¼•
CREATE INDEX idx_toolsets_store ON toolsets(is_global, enabled, deleted_at, active_version_id);
CREATE INDEX idx_toolsets_hot_reload ON toolsets(enabled, deleted_at, updated_at);
CREATE INDEX idx_toolsets_user ON toolsets(uid, is_global, deleted_at, uninstalled);
CREATE INDEX idx_toolsets_key ON toolsets(key, enabled);

-- ToolMethod è¡¨ç´¢å¼•
CREATE INDEX idx_methods_toolset_version ON tool_methods(toolset_id, version_id, enabled, deleted_at);
CREATE INDEX idx_methods_version ON tool_methods(version_id, enabled);
CREATE INDEX idx_methods_order ON tool_methods(toolset_id, version_id, order);

-- ToolsetVersion è¡¨ç´¢å¼•
CREATE INDEX idx_versions_active ON toolset_versions(toolset_id, is_active, deleted_at);
CREATE INDEX idx_versions_created ON toolset_versions(toolset_id, created_at DESC);
```

---
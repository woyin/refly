# å·¥å…·é…ç½®ç‰ˆæœ¬ç®¡ç†å®æˆ˜æŒ‡å—

æœ¬æ–‡æ¡£å±•ç¤ºå¦‚ä½•ä½¿ç”¨é…ç½®ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿæ¥å®‰å…¨åœ°æ›´æ–°ã€æµ‹è¯•å’Œå›æ»šå·¥å…·é…ç½®ã€‚

## ç›®å½•

- [æ•°æ®åº“è¡¨ç»“æ„](#æ•°æ®åº“è¡¨ç»“æ„)
- [æ ¸å¿ƒæœåŠ¡å®ç°](#æ ¸å¿ƒæœåŠ¡å®ç°)
- [å®æˆ˜ç¤ºä¾‹](#å®æˆ˜ç¤ºä¾‹)
- [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)

---

## æ•°æ®åº“è¡¨ç»“æ„

### 1. ä¿®æ”¹åçš„ Toolset è¡¨

```prisma
model Toolset {
  pk                   Int                   @id @default(autoincrement())
  toolsetId            String                @unique @map("toolset_id")
  isGlobal             Boolean               @default(false) @map("is_global")
  uid                  String?               @map("uid")
  name                 String                @map("name")
  key                  String                @map("key")
  authType             String?               @default("credentials") @map("auth_type")
  authData             String?               @map("auth_data")
  activeConfigVersion  Int?                  @default(1) @map("active_config_version")  // â­ å½“å‰æ¿€æ´»çš„é…ç½®ç‰ˆæœ¬
  enabled              Boolean               @default(true) @map("enabled")
  uninstalled          Boolean               @default(false) @map("uninstalled")
  creditBilling        String?               @map("credit_billing")
  createdAt            DateTime              @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt            DateTime              @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  deletedAt            DateTime?             @map("deleted_at") @db.Timestamptz()

  // å…³è”é…ç½®ç‰ˆæœ¬å†å²
  configVersions       ToolsetConfigVersion[]

  @@index([uid, isGlobal, deletedAt])
  @@index([key, enabled])
  @@index([updatedAt])  // ç”¨äºçƒ­æ›´æ–°æ£€æµ‹
  @@map("toolsets")
}
```

### 2. é…ç½®ç‰ˆæœ¬è¡¨

```prisma
model ToolsetConfigVersion {
  pk              Int       @id @default(autoincrement())
  toolsetId       String    @map("toolset_id")
  version         Int       @map("version")  // ç‰ˆæœ¬å·ï¼ˆè‡ªå¢ï¼‰
  config          String    @map("config")   // â­ JSON é…ç½®å†…å®¹
  configHash      String?   @map("config_hash")  // é…ç½®å†…å®¹çš„ SHA256 hash
  description     String?   @map("description")  // ç‰ˆæœ¬æè¿°
  isActive        Boolean   @default(false) @map("is_active")  // æ˜¯å¦ä¸ºå½“å‰æ¿€æ´»ç‰ˆæœ¬
  createdBy       String?   @map("created_by")  // åˆ›å»ºè€… UID
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz()
  updatedAt       DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz()
  deletedAt       DateTime? @map("deleted_at") @db.Timestamptz()

  // å…³è” Toolset
  toolset         Toolset   @relation(fields: [toolsetId], references: [toolsetId])

  @@unique([toolsetId, version])
  @@index([toolsetId, isActive, deletedAt])
  @@index([toolsetId, createdAt])
  @@index([configHash])  // ç”¨äºæŸ¥æ‰¾ç›¸åŒé…ç½®ï¼Œé¿å…é‡å¤
  @@map("toolset_config_versions")
}
```


---

## æ ¸å¿ƒæœåŠ¡å®ç°

### ToolsetConfigService

```typescript
// toolset-config.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { createHash } from 'crypto';

@Injectable()
export class ToolsetConfigService {
  constructor(private readonly prisma: PrismaService) {}

  /**
   * åˆ›å»ºæ–°çš„é…ç½®ç‰ˆæœ¬
   */
  async createConfigVersion(params: {
    toolsetId: string;
    config: any;
    description?: string;
    createdBy?: string;
    setAsActive?: boolean;
  }) {
    const { toolsetId, config, description, createdBy, setAsActive = false } = params;

    // è®¡ç®—é…ç½®çš„ hash
    const configStr = JSON.stringify(config);
    const configHash = createHash('sha256').update(configStr).digest('hex');

    // æ£€æŸ¥æ˜¯å¦å­˜åœ¨ç›¸åŒçš„é…ç½®
    const existingConfig = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, configHash, deletedAt: null },
    });

    if (existingConfig) {
      throw new Error(`Configuration already exists in version ${existingConfig.version}`);
    }

    // è·å–ä¸‹ä¸€ä¸ªç‰ˆæœ¬å·
    const latestVersion = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, deletedAt: null },
      orderBy: { version: 'desc' },
    });
    const nextVersion = (latestVersion?.version ?? 0) + 1;

    // åœ¨äº‹åŠ¡ä¸­åˆ›å»ºæ–°ç‰ˆæœ¬
    return await this.prisma.$transaction(async (tx) => {
      // å¦‚æœè®¾ç½®ä¸ºæ¿€æ´»ï¼Œå…ˆå°†å…¶ä»–ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
      if (setAsActive) {
        await tx.toolsetConfigVersion.updateMany({
          where: { toolsetId, isActive: true },
          data: { isActive: false },
        });
      }

      // åˆ›å»ºæ–°ç‰ˆæœ¬
      const newVersion = await tx.toolsetConfigVersion.create({
        data: {
          toolsetId,
          version: nextVersion,
          config: configStr,
          configHash,
          description,
          createdBy,
          isActive: setAsActive,
        },
      });

      // å¦‚æœè®¾ç½®ä¸ºæ¿€æ´»ï¼Œæ›´æ–° Toolset çš„ activeConfigVersion
      if (setAsActive) {
        await tx.toolset.update({
          where: { toolsetId },
          data: { activeConfigVersion: nextVersion },
        });
      }

      return newVersion;
    });
  }

  /**
   * åˆ‡æ¢åˆ°æŒ‡å®šç‰ˆæœ¬
   */
  async switchToVersion(toolsetId: string, version: number) {
    return await this.prisma.$transaction(async (tx) => {
      // éªŒè¯ç‰ˆæœ¬æ˜¯å¦å­˜åœ¨
      const targetVersion = await tx.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version } },
      });

      if (!targetVersion || targetVersion.deletedAt) {
        throw new Error(`Version ${version} not found for toolset ${toolsetId}`);
      }

      // å°†æ‰€æœ‰ç‰ˆæœ¬è®¾ä¸ºéæ¿€æ´»
      await tx.toolsetConfigVersion.updateMany({
        where: { toolsetId, isActive: true },
        data: { isActive: false },
      });

      // æ¿€æ´»ç›®æ ‡ç‰ˆæœ¬
      await tx.toolsetConfigVersion.update({
        where: { toolsetId_version: { toolsetId, version } },
        data: { isActive: true },
      });

      // æ›´æ–° Toolset çš„ activeConfigVersion å’Œ updatedAt
      await tx.toolset.update({
        where: { toolsetId },
        data: {
          activeConfigVersion: version,
          updatedAt: new Date(),  // è§¦å‘çƒ­æ›´æ–°
        },
      });

      return targetVersion;
    });
  }

  /**
   * è·å–å½“å‰æ¿€æ´»çš„é…ç½®
   */
  async getActiveConfig(toolsetId: string) {
    const activeVersion = await this.prisma.toolsetConfigVersion.findFirst({
      where: { toolsetId, isActive: true, deletedAt: null },
    });

    if (!activeVersion) {
      return null;
    }

    return {
      version: activeVersion.version,
      config: JSON.parse(activeVersion.config),
      description: activeVersion.description,
      createdAt: activeVersion.createdAt,
    };
  }

  /**
   * è·å–é…ç½®ç‰ˆæœ¬å†å²
   */
  async getVersionHistory(toolsetId: string) {
    const versions = await this.prisma.toolsetConfigVersion.findMany({
      where: { toolsetId, deletedAt: null },
      orderBy: { version: 'desc' },
    });

    return versions.map((v) => ({
      version: v.version,
      description: v.description,
      isActive: v.isActive,
      createdBy: v.createdBy,
      createdAt: v.createdAt,
    }));
  }

  /**
   * å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬çš„é…ç½®ï¼ˆåœ¨çº¿å¯¹æ¯”ï¼Œä¸å­˜å‚¨ï¼‰
   */
  async compareVersions(params: {
    toolsetId: string;
    fromVersion: number;
    toVersion: number;
  }) {
    const { toolsetId, fromVersion, toVersion } = params;

    // è·å–ä¸¤ä¸ªç‰ˆæœ¬çš„é…ç½®
    const [from, to] = await Promise.all([
      this.prisma.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version: fromVersion } },
      }),
      this.prisma.toolsetConfigVersion.findUnique({
        where: { toolsetId_version: { toolsetId, version: toVersion } },
      }),
    ]);

    if (!from || !to) {
      throw new Error('Version not found');
    }

    // è®¡ç®—å·®å¼‚
    const fromConfig = JSON.parse(from.config);
    const toConfig = JSON.parse(to.config);
    const diffSummary = this.computeDiff(fromConfig, toConfig);

    return {
      fromVersion: {
        version: from.version,
        description: from.description,
        createdAt: from.createdAt,
        createdBy: from.createdBy,
      },
      toVersion: {
        version: to.version,
        description: to.description,
        createdAt: to.createdAt,
        createdBy: to.createdBy,
      },
      diff: diffSummary,
    };
  }

  /**
   * å›æ»šåˆ°ä¹‹å‰çš„ç‰ˆæœ¬
   */
  async rollback(toolsetId: string, targetVersion?: number) {
    // å¦‚æœæ²¡æœ‰æŒ‡å®šç‰ˆæœ¬ï¼Œå›æ»šåˆ°ä¸Šä¸€ä¸ªç‰ˆæœ¬
    if (!targetVersion) {
      const currentActive = await this.prisma.toolsetConfigVersion.findFirst({
        where: { toolsetId, isActive: true, deletedAt: null },
      });

      if (!currentActive) {
        throw new Error('No active version found');
      }

      const previousVersion = await this.prisma.toolsetConfigVersion.findFirst({
        where: {
          toolsetId,
          version: { lt: currentActive.version },
          deletedAt: null,
        },
        orderBy: { version: 'desc' },
      });

      if (!previousVersion) {
        throw new Error('No previous version to rollback to');
      }

      targetVersion = previousVersion.version;
    }

    return await this.switchToVersion(toolsetId, targetVersion);
  }

  /**
   * è®¡ç®—é…ç½®å·®å¼‚ï¼ˆç®€åŒ–ç‰ˆï¼‰
   */
  private computeDiff(from: any, to: any): any {
    const changes: any = {
      added: {},
      removed: {},
      modified: {},
    };

    const allKeys = new Set([...Object.keys(from), ...Object.keys(to)]);

    for (const key of allKeys) {
      if (!(key in from)) {
        changes.added[key] = to[key];
      } else if (!(key in to)) {
        changes.removed[key] = from[key];
      } else if (JSON.stringify(from[key]) !== JSON.stringify(to[key])) {
        changes.modified[key] = { from: from[key], to: to[key] };
      }
    }

    return changes;
  }
}
```

---

## å®æˆ˜ç¤ºä¾‹

### ç¤ºä¾‹ 1: åˆ›å»ºæ–°é…ç½®ç‰ˆæœ¬

```typescript
async function createNewVersion() {
  const configService = new ToolsetConfigService(prisma);

  // æ–°é…ç½®ï¼šæ·»åŠ æ–°å‚æ•°
  const newConfig = {
    domain: 'fish.audio',
    credentials: {
      apiKey: '${FISH_AUDIO_API_KEY}'
    },
    methods: [
      {
        name: 'text_to_speech',
        description: 'Convert text to speech using Fish Audio API.',
        endpoint: 'https://api.fish.audio/v1/tts',
        schema: JSON.stringify({
          type: 'object',
          properties: {
            text: { type: 'string', description: 'Text to convert' },
            voice: { type: 'string', description: 'Voice ID', optional: true },  // æ–°å¢
            speed: { type: 'number', description: 'Speech speed (0.5-2.0)', optional: true }  // æ–°å¢
          },
          required: ['text']
        }),
        responseSchema: JSON.stringify({
          type: 'object',
          properties: {
            audio: { type: 'string', isResource: true, resourceType: 'audio' },
            duration: { type: 'number', optional: true }  // æ–°å¢
          }
        })
      }
    ]
  };

  // åˆ›å»ºæ–°ç‰ˆæœ¬ï¼ˆä¸ç«‹å³æ¿€æ´»ï¼‰
  const newVersion = await configService.createConfigVersion({
    toolsetId: 'global-fish-audio',
    config: newConfig,
    description: 'Add voice selection and speed control',
    createdBy: 'admin-uid',
    setAsActive: false,  // å…ˆä¸æ¿€æ´»ï¼Œç”¨äºæµ‹è¯•
  });

  console.log(`âœ… Created version ${newVersion.version}`);
}
```

### ç¤ºä¾‹ 2: A/B æµ‹è¯•ä¸åŒç‰ˆæœ¬

```typescript
async function runABTest() {
  const configService = new ToolsetConfigService(prisma);

  // æµ‹è¯•ç‰ˆæœ¬ 1ï¼ˆå½“å‰ç‰ˆæœ¬ï¼‰
  console.log('ğŸ“Š Testing Version 1...');
  const v1Config = await configService.getActiveConfig('global-fish-audio');
  const v1Results = await runPerformanceTest(v1Config.config, 100);

  // åˆ‡æ¢åˆ°ç‰ˆæœ¬ 2
  await configService.switchToVersion('global-fish-audio', 2);
  console.log('ğŸ“Š Testing Version 2...');
  const v2Config = await configService.getActiveConfig('global-fish-audio');
  const v2Results = await runPerformanceTest(v2Config.config, 100);

  // å¯¹æ¯”ç»“æœ
  const improvement = ((v1Results.avgLatency - v2Results.avgLatency) / v1Results.avgLatency) * 100;

  // è·å–é…ç½®å·®å¼‚ï¼ˆåœ¨çº¿å¯¹æ¯”ï¼‰
  const comparison = await configService.compareVersions({
    toolsetId: 'global-fish-audio',
    fromVersion: 1,
    toVersion: 2,
  });

  console.log('ğŸ“Š Configuration Differences:', comparison.diff);
  console.log(`âœ… Test completed. V2 is ${improvement > 0 ? 'faster' : 'slower'} by ${Math.abs(improvement).toFixed(2)}%`);

  // ä½ å¯ä»¥é€‰æ‹©å°†æµ‹è¯•ç»“æœå­˜å‚¨åˆ° Redis æˆ–æ—¥å¿—ç³»ç»Ÿ
  await redis.setex(
    `perf-test:global-fish-audio:v1-v2:${Date.now()}`,
    86400,  // 24 hours
    JSON.stringify({
      v1: v1Results,
      v2: v2Results,
      improvement: `${improvement.toFixed(2)}%`,
      configDiff: comparison.diff,
      timestamp: new Date().toISOString(),
    })
  );

  // å¦‚æœ v2 è¡¨ç°æ›´å¥½ï¼Œä¿æŒæ¿€æ´»ï¼›å¦åˆ™å›æ»š
  if (improvement < 0) {
    await configService.rollback('global-fish-audio');
    console.log('âš ï¸ Rolled back to v1 due to worse performance');
  }
}

// æ€§èƒ½æµ‹è¯•è¾…åŠ©å‡½æ•°
async function runPerformanceTest(config: any, iterations: number) {
  const results = {
    avgLatency: 0,
    successRate: 0,
    errorRate: 0,
  };

  let totalLatency = 0;
  let successCount = 0;

  for (let i = 0; i < iterations; i++) {
    const start = Date.now();
    try {
      await makeToolCall(config);
      successCount++;
    } catch (error) {
      console.error(`Request ${i} failed:`, error.message);
    }
    totalLatency += Date.now() - start;
  }

  results.avgLatency = totalLatency / iterations;
  results.successRate = (successCount / iterations) * 100;
  results.errorRate = ((iterations - successCount) / iterations) * 100;

  return results;
}
```

### ç¤ºä¾‹ 3: è‡ªåŠ¨å›æ»šæœºåˆ¶

```typescript
async function deployWithAutoRollback() {
  const configService = new ToolsetConfigService(prisma);
  const toolsetId = 'global-fish-audio';
  const newVersion = 3;

  console.log(`ğŸš€ Deploying version ${newVersion}...`);

  // è®°å½•å½“å‰ç‰ˆæœ¬
  const currentVersion = await configService.getActiveConfig(toolsetId);
  const previousVersion = currentVersion.version;

  try {
    // æ¿€æ´»æ–°ç‰ˆæœ¬
    await configService.switchToVersion(toolsetId, newVersion);
    console.log(`âœ… Switched to version ${newVersion}`);

    // ç›‘æ§ä¸€æ®µæ—¶é—´
    console.log('ğŸ“Š Monitoring performance for 60 seconds...');
    const monitoring = await monitorPerformance(toolsetId, 60000);

    // æ£€æŸ¥å¥åº·æŒ‡æ ‡
    if (monitoring.errorRate > 5) {
      throw new Error(`Error rate too high: ${monitoring.errorRate}%`);
    }

    if (monitoring.avgLatency > 2000) {
      throw new Error(`Latency too high: ${monitoring.avgLatency}ms`);
    }

    console.log('âœ… Version deployed successfully!');

  } catch (error) {
    console.error('âŒ Deployment failed:', error.message);

    // è‡ªåŠ¨å›æ»š
    console.log(`ğŸ”„ Rolling back to version ${previousVersion}...`);
    await configService.switchToVersion(toolsetId, previousVersion);

    // è®°å½•é—®é¢˜
    await logDeploymentFailure({
      toolsetId,
      attemptedVersion: newVersion,
      rolledBackTo: previousVersion,
      error: error.message,
      timestamp: new Date(),
    });

    console.log(`âœ… Rolled back to version ${previousVersion}`);
  }
}

// æ€§èƒ½ç›‘æ§å‡½æ•°
async function monitorPerformance(toolsetId: string, duration: number) {
  const startTime = Date.now();
  const metrics = {
    totalCalls: 0,
    errors: 0,
    totalLatency: 0,
  };

  // æ¨¡æ‹Ÿç›‘æ§
  while (Date.now() - startTime < duration) {
    try {
      const start = Date.now();
      await makeToolCall(toolsetId);
      metrics.totalLatency += Date.now() - start;
      metrics.totalCalls++;
    } catch (error) {
      metrics.errors++;
      metrics.totalCalls++;
    }
    await sleep(1000);
  }

  return {
    errorRate: (metrics.errors / metrics.totalCalls) * 100,
    avgLatency: metrics.totalLatency / metrics.totalCalls,
    totalCalls: metrics.totalCalls,
  };
}
```

### ç¤ºä¾‹ 4: æŸ¥çœ‹å’Œç®¡ç†ç‰ˆæœ¬å†å²

```typescript
async function manageVersionHistory() {
  const configService = new ToolsetConfigService(prisma);
  const toolsetId = 'global-fish-audio';

  // æŸ¥çœ‹æ‰€æœ‰ç‰ˆæœ¬
  const history = await configService.getVersionHistory(toolsetId);

  console.log('\nğŸ“‹ Configuration Version History:');
  console.table(history.map(v => ({
    Version: v.version,
    Active: v.isActive ? 'âœ“' : '',
    Description: v.description || 'N/A',
    Created: new Date(v.createdAt).toLocaleDateString(),
    Author: v.createdBy || 'System',
  })));

  // æŸ¥çœ‹ç‰¹å®šç‰ˆæœ¬çš„é…ç½®
  const v2 = await prisma.toolsetConfigVersion.findUnique({
    where: { toolsetId_version: { toolsetId, version: 2 } },
  });

  if (v2) {
    console.log('\nğŸ“„ Version 2 Configuration:');
    console.log(JSON.stringify(JSON.parse(v2.config), null, 2));
  }

  // å¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬
  console.log('\nğŸ” Comparing Version 1 vs Version 2:');
  const comparison = await configService.compareVersions({
    toolsetId,
    fromVersion: 1,
    toVersion: 2,
  });

  console.log('Changes:');
  if (Object.keys(comparison.diff.added).length > 0) {
    console.log('  âœ¨ Added:', comparison.diff.added);
  }
  if (Object.keys(comparison.diff.removed).length > 0) {
    console.log('  ğŸ—‘ï¸  Removed:', comparison.diff.removed);
  }
  if (Object.keys(comparison.diff.modified).length > 0) {
    console.log('  ğŸ“ Modified:', comparison.diff.modified);
  }
}
```

### ç¤ºä¾‹ 5: é›†æˆåˆ°çƒ­æ›´æ–°ç³»ç»Ÿ

```typescript
// ä¿®æ”¹ ToolConfigWatcher ä»¥æ”¯æŒç‰ˆæœ¬ç®¡ç†
@Injectable()
export class ToolConfigWatcher implements OnModuleInit {
  constructor(
    private readonly prisma: PrismaService,
    private readonly eventEmitter: EventEmitter2,
    private readonly redis: RedisService,
  ) {}

  private async checkConfigChanges() {
    try {
      // è·å–æ‰€æœ‰å¯ç”¨çš„å·¥å…·é›†åŠå…¶æ¿€æ´»é…ç½®
      const toolsets = await this.prisma.toolset.findMany({
        where: {
          enabled: true,
          deletedAt: null,
        },
        include: {
          configVersions: {
            where: { isActive: true, deletedAt: null },
            take: 1,
          },
        },
      });

      for (const toolset of toolsets) {
        const activeConfig = toolset.configVersions[0];
        if (!activeConfig) continue;

        // ä½¿ç”¨ configHash æ£€æµ‹å˜åŒ–
        const currentHash = activeConfig.configHash;
        const cachedHash = await this.redis.get(`toolset:hash:${toolset.key}`);

        if (currentHash !== cachedHash) {
          console.log(`[ToolConfigWatcher] Version changed for ${toolset.key}: v${activeConfig.version}`);

          // æ›´æ–°ç¼“å­˜
          await this.redis.set(
            `toolset:hash:${toolset.key}`,
            currentHash,
            'EX',
            86400  // 24 hours
          );

          // è§¦å‘é…ç½®å˜æ›´äº‹ä»¶
          this.eventEmitter.emit('tool.config.changed', {
            toolsetKey: toolset.key,
            version: activeConfig.version,
            configHash: currentHash,
            config: JSON.parse(activeConfig.config),
            timestamp: new Date(),
          });
        }
      }
    } catch (error) {
      console.error('[ToolConfigWatcher] Error checking config changes:', error);
    }
  }
}
```

---

## æœ€ä½³å®è·µ

### 1. ç‰ˆæœ¬æè¿°è§„èŒƒ

æ¯æ¬¡åˆ›å»ºæ–°ç‰ˆæœ¬æ—¶ï¼Œæä¾›æ¸…æ™°çš„æè¿°ï¼š

```typescript
// âœ… å¥½çš„æè¿°
description: 'Add voice selection and speed control for better TTS customization'

// âŒ ä¸å¥½çš„æè¿°
description: 'update config'
```

### 2. æ¸è¿›å¼éƒ¨ç½²

ä¸è¦ç›´æ¥æ¿€æ´»æ–°ç‰ˆæœ¬ï¼Œä½¿ç”¨ä»¥ä¸‹æµç¨‹ï¼š

```typescript
// æ­¥éª¤ 1: åˆ›å»ºæ–°ç‰ˆæœ¬ï¼ˆä¸æ¿€æ´»ï¼‰
await configService.createConfigVersion({
  toolsetId: 'global-fish-audio',
  config: newConfig,
  description: 'Add new features',
  setAsActive: false,  // ä¸æ¿€æ´»
});

// æ­¥éª¤ 2: åœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯
await runIntegrationTests(newVersion);

// æ­¥éª¤ 3: æ¿€æ´»å¹¶ç›‘æ§
await configService.switchToVersion(toolsetId, newVersion);
await monitorPerformance(60000);  // ç›‘æ§ 1 åˆ†é’Ÿ

// æ­¥éª¤ 4: æ ¹æ®ç»“æœå†³å®šä¿ç•™æˆ–å›æ»š
if (performanceDegraded) {
  await configService.rollback(toolsetId);
}
```

### 3. ä½¿ç”¨ Hash é¿å…é‡å¤é…ç½®

ç³»ç»Ÿä¼šè‡ªåŠ¨æ£€æµ‹ç›¸åŒçš„é…ç½®å¹¶æ‹’ç»åˆ›å»ºé‡å¤ç‰ˆæœ¬ï¼š

```typescript
// è¿™ä¼šæŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºé…ç½®ç›¸åŒ
try {
  await configService.createConfigVersion({
    toolsetId: 'global-fish-audio',
    config: sameConfig,  // ä¸å·²æœ‰ç‰ˆæœ¬ç›¸åŒ
    description: 'Duplicate config',
  });
} catch (error) {
  console.log(error.message);  // "Configuration already exists in version 2"
}
```

### 4. ä¿ç•™æ€§èƒ½æµ‹è¯•æ•°æ®ï¼ˆä½¿ç”¨ Redis æˆ–æ—¥å¿—ç³»ç»Ÿï¼‰

å¯¹æ¯”ç‰ˆæœ¬æ—¶ï¼Œå¯ä»¥å°†æ€§èƒ½æ•°æ®ä¸´æ—¶å­˜å‚¨åˆ° Redis æˆ–æ—¥å¿—ç³»ç»Ÿï¼š

```typescript
// è·å–é…ç½®å·®å¼‚
const comparison = await configService.compareVersions({
  toolsetId: 'global-fish-audio',
  fromVersion: 1,
  toVersion: 2,
});

// å°†æ€§èƒ½æµ‹è¯•æ•°æ®å­˜å‚¨åˆ° Redisï¼ˆ24å°æ—¶è¿‡æœŸï¼‰
await redis.setex(
  `perf-test:global-fish-audio:v1-v2:${Date.now()}`,
  86400,
  JSON.stringify({
    configDiff: comparison.diff,
    performanceData: {
      v1: {
        avgLatency: 450,
        p95Latency: 800,
        p99Latency: 1200,
        successRate: 99.5,
        errorRate: 0.5,
        throughput: 150,
        testDate: new Date().toISOString(),
      },
      v2: {
        avgLatency: 380,
        p95Latency: 650,
        p99Latency: 950,
        successRate: 99.7,
        errorRate: 0.3,
        throughput: 170,
        testDate: new Date().toISOString(),
      },
    },
    testResults: {
      winner: 'v2',
      latencyImprovement: '15.6%',
      throughputImprovement: '13.3%',
      recommendation: 'Deploy to production',
    },
    notes: 'Load test with 1000 concurrent users over 5 minutes',
  })
);

// æˆ–è€…ä½¿ç”¨æ—¥å¿—ç³»ç»Ÿè®°å½•
logger.info('Version comparison test completed', {
  toolsetId: 'global-fish-audio',
  fromVersion: 1,
  toVersion: 2,
  configDiff: comparison.diff,
  winner: 'v2',
  improvement: '15.6%',
});
```

### 5. å®šæœŸæ¸…ç†æ—§ç‰ˆæœ¬

ä¿ç•™æœ€è¿‘çš„ N ä¸ªç‰ˆæœ¬ï¼Œå…¶ä»–ç‰ˆæœ¬è½¯åˆ é™¤ï¼š

```typescript
async function cleanupOldVersions(toolsetId: string, keepRecent: number = 10) {
  const versions = await prisma.toolsetConfigVersion.findMany({
    where: { toolsetId, deletedAt: null },
    orderBy: { version: 'desc' },
  });

  const toDelete = versions.slice(keepRecent);

  for (const version of toDelete) {
    await prisma.toolsetConfigVersion.update({
      where: { pk: version.pk },
      data: { deletedAt: new Date() },
    });
  }

  console.log(`Cleaned up ${toDelete.length} old versions for ${toolsetId}`);
}
```

---

## æ€»ç»“

é…ç½®ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿæä¾›äº†ä»¥ä¸‹æ ¸å¿ƒèƒ½åŠ›ï¼š

1. **å®‰å…¨æ›´æ–°** - æ–°é…ç½®ä¸ä¼šç«‹å³å½±å“ç”Ÿäº§
2. **å¿«é€Ÿå›æ»š** - å‡ºç°é—®é¢˜å¯ä»¥ç«‹å³æ¢å¤
3. **A/B æµ‹è¯•** - å¯¹æ¯”ä¸åŒé…ç½®çš„æ€§èƒ½
4. **å®Œæ•´å®¡è®¡** - è¿½æº¯æ‰€æœ‰é…ç½®å˜æ›´
5. **é¿å…é‡å¤** - è‡ªåŠ¨æ£€æµ‹ç›¸åŒé…ç½®

é€šè¿‡åˆç†ä½¿ç”¨è¿™äº›åŠŸèƒ½ï¼Œå¯ä»¥å¤§å¤§é™ä½é…ç½®å˜æ›´çš„é£é™©ï¼Œæé«˜ç³»ç»Ÿçš„ç¨³å®šæ€§å’Œå¯ç»´æŠ¤æ€§ã€‚
